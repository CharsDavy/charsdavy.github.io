<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Chars</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://chars.tech/</link>
    <description>Chars's Tech Blog</description>
    <pubDate>Tue, 20 Mar 2018 14:10:12 +0800</pubDate>
    
      <item>
        <title>Tensorflow -- 基准</title>
        <link>/ml/2018/02/05/tensorflow-performance-benchmarks.html</link>
        <guid isPermaLink="true">/ml/2018/02/05/tensorflow-performance-benchmarks.html</guid>
        <description>&lt;h1 id=&quot;基准&quot;&gt;基准&lt;/h1&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;TensorFlow 社区创建了一系列用于多平台测试的图像分类模型参考点。在 &lt;a href=&quot;#methodology&quot;&gt;方法&lt;/a&gt; 章节中会详细说明如何执行测试，并给出使用的脚本链接。&lt;/p&gt;

&lt;h2 id=&quot;图像分类模型的结果&quot;&gt;图像分类模型的结果&lt;/h2&gt;

&lt;p&gt;InceptionV3 (&lt;a href=&quot;https://arxiv.org/abs/1512.00567&quot;&gt;arXiv:1512.00567&lt;/a&gt;), ResNet-50
(&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot;&gt;arXiv:1512.03385&lt;/a&gt;), ResNet-152
(&lt;a href=&quot;https://arxiv.org/abs/1512.03385&quot;&gt;arXiv:1512.03385&lt;/a&gt;), VGG16
(&lt;a href=&quot;https://arxiv.org/abs/1409.1556&quot;&gt;arXiv:1409.1556&lt;/a&gt;), 和
&lt;a href=&quot;http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf&quot;&gt;AlexNet&lt;/a&gt; 使用 &lt;a href=&quot;http://www.image-net.org/&quot;&gt;ImageNet&lt;/a&gt; 数据集测试。这些测试运行在 Google 计算云引擎，亚马逊计算云 (Amazon EC2) 和 NVIDIA® DGX-1™ 。大部分测试使用合成和真实的数据。&lt;/p&gt;

&lt;p&gt;对合成数据的测试是通过使用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;tf.Variable&lt;/code&gt; 设置相同的 shape，除了每个 ImageNet 模型。我们认为，当评估一个平台的基准时包含真实数据是很重要的。底层硬件和框架的加载测试是为了训练实际数据。我们开始合成数据用来移除磁盘 I/O 作为一个变量，并设置一个基准。然后使用真实的数据来验证 TensorFlow 的输入和底层磁盘 I/O 的计算单元。&lt;/p&gt;

&lt;h3 id=&quot;使用-nvidia-dgx-1-nvidia-tesla-p100-训练&quot;&gt;使用 NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 训练&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:80%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_p100_single_server.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;细节和附加结果在 &lt;a href=&quot;#details_for_nvidia_dgx-1tm_nvidia_tesla_p100&quot;&gt;NVIDIA® DGX-1™ (NVIDIA®
Tesla® P100) 的细节&lt;/a&gt; 章节中。&lt;/p&gt;

&lt;h3 id=&quot;使用-nvidia-tesla-k80-训练&quot;&gt;使用 NVIDIA® Tesla® K80 训练&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:80%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_k80_single_server.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;细节和附加结果在 &lt;a href=&quot;#details_for_google_compute_engine_nvidia_tesla_k80&quot;&gt;Google 计算引擎
(NVIDIA® Tesla® K80) 的细节&lt;/a&gt; 和
&lt;a href=&quot;#details_for_amazon_ec2_nvidia_tesla_k80&quot;&gt;Amazon EC2 (NVIDIA® Tesla®
K80) 的细节&lt;/a&gt; 章节中。&lt;/p&gt;

&lt;h3 id=&quot;使用-nvidia-tesla-k80-分布式训练&quot;&gt;使用 NVIDIA® Tesla® K80 分布式训练&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:80%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_k80_aws_distributed.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;细节和附加结果在 &lt;a href=&quot;#details_for_amazon_ec2_distributed_nvidia_tesla_k80&quot;&gt;分布式 Amazon EC2
(NVIDIA® Tesla® K80) 的细节&lt;/a&gt;
章节中。&lt;/p&gt;

&lt;h3 id=&quot;比较合成和真实训练数据&quot;&gt;比较合成和真实训练数据&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;NVIDIA® Tesla® P100&lt;/strong&gt;&lt;/p&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_p100_data_compare_inceptionv3.png&quot; /&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_p100_data_compare_resnet50.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;NVIDIA® Tesla® K80&lt;/strong&gt;&lt;/p&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_k80_data_compare_inceptionv3.png&quot; /&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_k80_data_compare_resnet50.png&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;nvidia-dgx-1-nvidia-tesla-p100-的细节&quot;&gt;NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 的细节&lt;/h2&gt;

&lt;h3 id=&quot;环境配置&quot;&gt;环境配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Instance type&lt;/strong&gt;: NVIDIA® DGX-1™&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GPU:&lt;/strong&gt; 8x NVIDIA® Tesla® P100&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Ubuntu 16.04 LTS with tests run via Docker&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CUDA / cuDNN:&lt;/strong&gt; 8.0 / 5.1&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TensorFlow GitHub hash:&lt;/strong&gt; b1e174e&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Benchmark GitHub hash:&lt;/strong&gt; 9165a70&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Build Command:&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda
//tensorflow/tools/pip_package:build_pip_package&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk:&lt;/strong&gt; Local SSD&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DataSet:&lt;/strong&gt; ImageNet&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test Date:&lt;/strong&gt; May 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3、ResNet-50、ResNet-152 和 VGG16 也用批处理大小为 32 进行测试。这些结果在 &lt;em&gt;其他结果&lt;/em&gt; 章节。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Options&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Batch size per GPU&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;512&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Optimizer&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;用于每个模型的配置。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Model&lt;/th&gt;
      &lt;th&gt;variable_update&lt;/th&gt;
      &lt;th&gt;local_parameter_device&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;InceptionV3&lt;/td&gt;
      &lt;td&gt;parameter_server&lt;/td&gt;
      &lt;td&gt;cpu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResNet50&lt;/td&gt;
      &lt;td&gt;parameter_server&lt;/td&gt;
      &lt;td&gt;cpu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResNet152&lt;/td&gt;
      &lt;td&gt;parameter_server&lt;/td&gt;
      &lt;td&gt;cpu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AlexNet&lt;/td&gt;
      &lt;td&gt;replicated (with NCCL)&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VGG16&lt;/td&gt;
      &lt;td&gt;replicated (with NCCL)&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;结果&quot;&gt;结果&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:80%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_p100_single_server.png&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_dgx1_synth_p100_single_server_scaling.png&quot; /&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_dgx1_real_p100_single_server_scaling.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;142&lt;/td&gt;
      &lt;td&gt;219&lt;/td&gt;
      &lt;td&gt;91.8&lt;/td&gt;
      &lt;td&gt;2987&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;284&lt;/td&gt;
      &lt;td&gt;422&lt;/td&gt;
      &lt;td&gt;181&lt;/td&gt;
      &lt;td&gt;5658&lt;/td&gt;
      &lt;td&gt;295&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;569&lt;/td&gt;
      &lt;td&gt;852&lt;/td&gt;
      &lt;td&gt;356&lt;/td&gt;
      &lt;td&gt;10509&lt;/td&gt;
      &lt;td&gt;584&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;1131&lt;/td&gt;
      &lt;td&gt;1734&lt;/td&gt;
      &lt;td&gt;716&lt;/td&gt;
      &lt;td&gt;17822&lt;/td&gt;
      &lt;td&gt;1081&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;训练真实数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;142&lt;/td&gt;
      &lt;td&gt;218&lt;/td&gt;
      &lt;td&gt;91.4&lt;/td&gt;
      &lt;td&gt;2890&lt;/td&gt;
      &lt;td&gt;154&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;278&lt;/td&gt;
      &lt;td&gt;425&lt;/td&gt;
      &lt;td&gt;179&lt;/td&gt;
      &lt;td&gt;4448&lt;/td&gt;
      &lt;td&gt;284&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;551&lt;/td&gt;
      &lt;td&gt;853&lt;/td&gt;
      &lt;td&gt;359&lt;/td&gt;
      &lt;td&gt;7105&lt;/td&gt;
      &lt;td&gt;534&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;1079&lt;/td&gt;
      &lt;td&gt;1630&lt;/td&gt;
      &lt;td&gt;708&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;898&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;从上图表可以看出，由于最大输入的限制，AlexNet 模型没有使用 8 个 GPU 来训练数据。&lt;/p&gt;

&lt;h3 id=&quot;其他结果&quot;&gt;其他结果&lt;/h3&gt;

&lt;p&gt;以下是批处理大小为 32 的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;128&lt;/td&gt;
      &lt;td&gt;195&lt;/td&gt;
      &lt;td&gt;82.7&lt;/td&gt;
      &lt;td&gt;144&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;259&lt;/td&gt;
      &lt;td&gt;368&lt;/td&gt;
      &lt;td&gt;160&lt;/td&gt;
      &lt;td&gt;281&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;520&lt;/td&gt;
      &lt;td&gt;768&lt;/td&gt;
      &lt;td&gt;317&lt;/td&gt;
      &lt;td&gt;549&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;995&lt;/td&gt;
      &lt;td&gt;1485&lt;/td&gt;
      &lt;td&gt;632&lt;/td&gt;
      &lt;td&gt;820&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;训练真实数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;130&lt;/td&gt;
      &lt;td&gt;193&lt;/td&gt;
      &lt;td&gt;82.4&lt;/td&gt;
      &lt;td&gt;144&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;257&lt;/td&gt;
      &lt;td&gt;369&lt;/td&gt;
      &lt;td&gt;159&lt;/td&gt;
      &lt;td&gt;253&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;507&lt;/td&gt;
      &lt;td&gt;760&lt;/td&gt;
      &lt;td&gt;317&lt;/td&gt;
      &lt;td&gt;457&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;966&lt;/td&gt;
      &lt;td&gt;1410&lt;/td&gt;
      &lt;td&gt;609&lt;/td&gt;
      &lt;td&gt;690&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;google-compute-engine-nvidia-tesla-k80-的细节&quot;&gt;Google Compute Engine (NVIDIA® Tesla® K80) 的细节&lt;/h2&gt;

&lt;h3 id=&quot;环境配置-1&quot;&gt;环境配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Instance type&lt;/strong&gt;: n1-standard-32-k80x8&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GPU:&lt;/strong&gt; 8x NVIDIA® Tesla® K80&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Ubuntu 16.04 LTS&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CUDA / cuDNN:&lt;/strong&gt; 8.0 / 5.1&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TensorFlow GitHub hash:&lt;/strong&gt; b1e174e&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Benchmark GitHub hash:&lt;/strong&gt; 9165a70&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Build Command:&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda
//tensorflow/tools/pip_package:build_pip_package&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk:&lt;/strong&gt; 1.7 TB Shared SSD persistent disk (800 MB/s)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DataSet:&lt;/strong&gt; ImageNet&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test Date:&lt;/strong&gt; May 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 &lt;em&gt;其他结果&lt;/em&gt; 章节。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Options&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Batch size per GPU&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;512&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Optimizer&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;每个模型所用的配置中， variable_update 和 parameter_server 配置相同，local_parameter_device 和 cpu 配置相同。&lt;/p&gt;

&lt;h3 id=&quot;结果-1&quot;&gt;结果&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_gce_synth_k80_single_server_scaling.png&quot; /&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_gce_real_k80_single_server_scaling.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;30.5&lt;/td&gt;
      &lt;td&gt;51.9&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
      &lt;td&gt;656&lt;/td&gt;
      &lt;td&gt;35.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;57.8&lt;/td&gt;
      &lt;td&gt;99.0&lt;/td&gt;
      &lt;td&gt;38.2&lt;/td&gt;
      &lt;td&gt;1209&lt;/td&gt;
      &lt;td&gt;64.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;116&lt;/td&gt;
      &lt;td&gt;195&lt;/td&gt;
      &lt;td&gt;75.8&lt;/td&gt;
      &lt;td&gt;2328&lt;/td&gt;
      &lt;td&gt;120&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;227&lt;/td&gt;
      &lt;td&gt;387&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;4640&lt;/td&gt;
      &lt;td&gt;234&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;训练真实数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;30.6&lt;/td&gt;
      &lt;td&gt;51.2&lt;/td&gt;
      &lt;td&gt;20.0&lt;/td&gt;
      &lt;td&gt;639&lt;/td&gt;
      &lt;td&gt;34.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;58.4&lt;/td&gt;
      &lt;td&gt;98.8&lt;/td&gt;
      &lt;td&gt;38.3&lt;/td&gt;
      &lt;td&gt;1136&lt;/td&gt;
      &lt;td&gt;62.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;115&lt;/td&gt;
      &lt;td&gt;194&lt;/td&gt;
      &lt;td&gt;75.4&lt;/td&gt;
      &lt;td&gt;2067&lt;/td&gt;
      &lt;td&gt;118&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;225&lt;/td&gt;
      &lt;td&gt;381&lt;/td&gt;
      &lt;td&gt;148&lt;/td&gt;
      &lt;td&gt;4056&lt;/td&gt;
      &lt;td&gt;230&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;其他结果-1&quot;&gt;其他结果&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3 (batch size 32)&lt;/th&gt;
      &lt;th&gt;ResNet-50 (batch size 32)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;29.3&lt;/td&gt;
      &lt;td&gt;49.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;55.0&lt;/td&gt;
      &lt;td&gt;95.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;109&lt;/td&gt;
      &lt;td&gt;183&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;216&lt;/td&gt;
      &lt;td&gt;362&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;训练真实数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3 (batch size 32)&lt;/th&gt;
      &lt;th&gt;ResNet-50 (batch size 32)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;29.5&lt;/td&gt;
      &lt;td&gt;49.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;55.4&lt;/td&gt;
      &lt;td&gt;95.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;110&lt;/td&gt;
      &lt;td&gt;186&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;216&lt;/td&gt;
      &lt;td&gt;359&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;amazon-ec2-nvidia-tesla-k80-的细节&quot;&gt;Amazon EC2 (NVIDIA® Tesla® K80) 的细节&lt;/h2&gt;

&lt;h3 id=&quot;环境配置-2&quot;&gt;环境配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Instance type&lt;/strong&gt;: p2.8xlarge&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GPU:&lt;/strong&gt; 8x NVIDIA® Tesla® K80&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Ubuntu 16.04 LTS&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CUDA / cuDNN:&lt;/strong&gt; 8.0 / 5.1&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TensorFlow GitHub hash:&lt;/strong&gt; b1e174e&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Benchmark GitHub hash:&lt;/strong&gt; 9165a70&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Build Command:&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda
//tensorflow/tools/pip_package:build_pip_package&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk:&lt;/strong&gt; 1TB Amazon EFS (burst 100 MiB/sec for 12 hours, continuous 50
MiB/sec)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DataSet:&lt;/strong&gt; ImageNet&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test Date:&lt;/strong&gt; May 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 &lt;em&gt;其他结果&lt;/em&gt; 章节。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Options&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Batch size per GPU&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;512&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Optimizer&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;用于每个模型的配置。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Model&lt;/th&gt;
      &lt;th&gt;variable_update&lt;/th&gt;
      &lt;th&gt;local_parameter_device&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;InceptionV3&lt;/td&gt;
      &lt;td&gt;parameter_server&lt;/td&gt;
      &lt;td&gt;cpu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResNet-50&lt;/td&gt;
      &lt;td&gt;replicated (without NCCL)&lt;/td&gt;
      &lt;td&gt;gpu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResNet-152&lt;/td&gt;
      &lt;td&gt;replicated (without NCCL)&lt;/td&gt;
      &lt;td&gt;gpu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AlexNet&lt;/td&gt;
      &lt;td&gt;parameter_server&lt;/td&gt;
      &lt;td&gt;gpu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VGG16&lt;/td&gt;
      &lt;td&gt;parameter_server&lt;/td&gt;
      &lt;td&gt;gpu&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;结果-2&quot;&gt;结果&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_aws_synth_k80_single_server_scaling.png&quot; /&gt;
  &lt;img style=&quot;width:35%&quot; src=&quot;https://www.tensorflow.org/images/perf_aws_real_k80_single_server_scaling.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;30.8&lt;/td&gt;
      &lt;td&gt;51.5&lt;/td&gt;
      &lt;td&gt;19.7&lt;/td&gt;
      &lt;td&gt;684&lt;/td&gt;
      &lt;td&gt;36.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;58.7&lt;/td&gt;
      &lt;td&gt;98.0&lt;/td&gt;
      &lt;td&gt;37.6&lt;/td&gt;
      &lt;td&gt;1244&lt;/td&gt;
      &lt;td&gt;69.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;117&lt;/td&gt;
      &lt;td&gt;195&lt;/td&gt;
      &lt;td&gt;74.9&lt;/td&gt;
      &lt;td&gt;2479&lt;/td&gt;
      &lt;td&gt;141&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;230&lt;/td&gt;
      &lt;td&gt;384&lt;/td&gt;
      &lt;td&gt;149&lt;/td&gt;
      &lt;td&gt;4853&lt;/td&gt;
      &lt;td&gt;260&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;训练真实数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
      &lt;th&gt;AlexNet&lt;/th&gt;
      &lt;th&gt;VGG16&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;30.5&lt;/td&gt;
      &lt;td&gt;51.3&lt;/td&gt;
      &lt;td&gt;19.7&lt;/td&gt;
      &lt;td&gt;674&lt;/td&gt;
      &lt;td&gt;36.3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;59.0&lt;/td&gt;
      &lt;td&gt;94.9&lt;/td&gt;
      &lt;td&gt;38.2&lt;/td&gt;
      &lt;td&gt;1227&lt;/td&gt;
      &lt;td&gt;67.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;118&lt;/td&gt;
      &lt;td&gt;188&lt;/td&gt;
      &lt;td&gt;75.2&lt;/td&gt;
      &lt;td&gt;2201&lt;/td&gt;
      &lt;td&gt;136&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;228&lt;/td&gt;
      &lt;td&gt;373&lt;/td&gt;
      &lt;td&gt;149&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;242&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由于我们的 EFS 没有提供足够的吞吐量，上面的图表中我们排出了使用 8 个 GPU 来训练 AlexNet 模型的统计。&lt;/p&gt;

&lt;h3 id=&quot;其他结果-2&quot;&gt;其他结果&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3 (batch size 32)&lt;/th&gt;
      &lt;th&gt;ResNet-50 (batch size 32)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;29.9&lt;/td&gt;
      &lt;td&gt;49.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;57.5&lt;/td&gt;
      &lt;td&gt;94.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;114&lt;/td&gt;
      &lt;td&gt;184&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;216&lt;/td&gt;
      &lt;td&gt;355&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;训练真实数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3 (batch size 32)&lt;/th&gt;
      &lt;th&gt;ResNet-50 (batch size 32)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;49.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;57.5&lt;/td&gt;
      &lt;td&gt;95.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;113&lt;/td&gt;
      &lt;td&gt;185&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;212&lt;/td&gt;
      &lt;td&gt;353&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;amazon-ec2-distributed-nvidia-tesla-k80-的细节&quot;&gt;Amazon EC2 Distributed (NVIDIA® Tesla® K80) 的细节&lt;/h2&gt;

&lt;h3 id=&quot;环境配置-3&quot;&gt;环境配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Instance type&lt;/strong&gt;: p2.8xlarge&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GPU:&lt;/strong&gt; 8x NVIDIA® Tesla® K80&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;OS:&lt;/strong&gt; Ubuntu 16.04 LTS&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CUDA / cuDNN:&lt;/strong&gt; 8.0 / 5.1&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;TensorFlow GitHub hash:&lt;/strong&gt; b1e174e&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Benchmark GitHub hash:&lt;/strong&gt; 9165a70&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Build Command:&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;bazel build -c opt --copt=-march=&quot;haswell&quot; --config=cuda
//tensorflow/tools/pip_package:build_pip_package&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Disk:&lt;/strong&gt; 1.0 TB EFS (burst 100 MB/sec for 12 hours, continuous 50 MB/sec)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DataSet:&lt;/strong&gt; ImageNet&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Test Date:&lt;/strong&gt; May 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 &lt;em&gt;其他结果&lt;/em&gt; 章节。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Options&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Batch size per GPU&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Optimizer&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
      &lt;td&gt;sgd&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;用于每个模型的配置。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Model&lt;/th&gt;
      &lt;th&gt;variable_update&lt;/th&gt;
      &lt;th&gt;local_parameter_device&lt;/th&gt;
      &lt;th&gt;cross_replica_sync&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;InceptionV3&lt;/td&gt;
      &lt;td&gt;distributed_replicated&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResNet-50&lt;/td&gt;
      &lt;td&gt;distributed_replicated&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ResNet-152&lt;/td&gt;
      &lt;td&gt;distributed_replicated&lt;/td&gt;
      &lt;td&gt;n/a&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;为了简化服务器设置，EC2 实例（p2.8xlarge）运行了 worker 服务器和 parameter 服务器。相同数量的 worker 服务器和 parameter 服务器使用了下述的配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;InceptionV3: 8 instances / 6 parameter servers&lt;/li&gt;
  &lt;li&gt;ResNet-50: (batch size 32) 8 instances / 4 parameter servers&lt;/li&gt;
  &lt;li&gt;ResNet-152: 8 instances / 4 parameter servers&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;结果-3&quot;&gt;结果&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:80%&quot; src=&quot;https://www.tensorflow.org/images/perf_summary_k80_aws_distributed.png&quot; /&gt;
&lt;/div&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:70%&quot; src=&quot;https://www.tensorflow.org/images/perf_aws_synth_k80_distributed_scaling.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3&lt;/th&gt;
      &lt;th&gt;ResNet-50&lt;/th&gt;
      &lt;th&gt;ResNet-152&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;29.7&lt;/td&gt;
      &lt;td&gt;52.4&lt;/td&gt;
      &lt;td&gt;19.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;229&lt;/td&gt;
      &lt;td&gt;378&lt;/td&gt;
      &lt;td&gt;146&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;459&lt;/td&gt;
      &lt;td&gt;751&lt;/td&gt;
      &lt;td&gt;291&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;902&lt;/td&gt;
      &lt;td&gt;1388&lt;/td&gt;
      &lt;td&gt;565&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;1783&lt;/td&gt;
      &lt;td&gt;2744&lt;/td&gt;
      &lt;td&gt;981&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;其他结果-3&quot;&gt;其他结果&lt;/h3&gt;

&lt;div style=&quot;width:95%; margin:auto; margin-bottom:10px; margin-top:20px;&quot;&gt;
  &lt;img style=&quot;width:50%&quot; src=&quot;https://www.tensorflow.org/images/perf_aws_synth_k80_multi_server_batch32.png&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;训练合成数据&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;GPUs&lt;/th&gt;
      &lt;th&gt;InceptionV3 (batch size 32)&lt;/th&gt;
      &lt;th&gt;ResNet-50 (batch size 32)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;29.2&lt;/td&gt;
      &lt;td&gt;48.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;219&lt;/td&gt;
      &lt;td&gt;333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;427&lt;/td&gt;
      &lt;td&gt;667&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;820&lt;/td&gt;
      &lt;td&gt;1180&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;1608&lt;/td&gt;
      &lt;td&gt;2315&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;方法&quot;&gt;方法&lt;/h2&gt;

&lt;p&gt;上述结果是使用该 &lt;a href=&quot;https://github.com/tensorflow/benchmarks/tree/master/scripts/tf_cnn_benchmarks&quot;&gt;脚本&lt;/a&gt; 运行在各种平台上而生成。&lt;a href=&quot;https://www.tensorflow.org/performance/performance_models&quot;&gt;《High-Performance Models》&lt;/a&gt; 文章详细描述了脚本中的技术，以及如何执行脚本的示例。&lt;/p&gt;

&lt;p&gt;为了创建尽可能重复的结果，每个测试运行 5 次，然后取平均值。在给定的平台上，GPU 是在默认状态下运行的。对于 NVIDIA® Tesla® K80 来说这意味着不使用 &lt;a href=&quot;https://devblogs.nvidia.com/parallelforall/increase-performance-gpu-boost-k80-autoboost/&quot;&gt;GPU
Boost&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对于每个测试，需要完成 10 次预热，然后再平均完成 100 次测试。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;原文地址：&lt;a href=&quot;https://www.tensorflow.org/performance/benchmarks&quot;&gt;https://www.tensorflow.org/performance/benchmarks&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译者：&lt;a href=&quot;https://github.com/charsdavy&quot;&gt;charsdavy&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;校对者：&lt;a href=&quot;https://github.com/joyking7&quot;&gt;joyking7&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt; 是一个翻译优质互联网技术文章的社区，文章来源为 &lt;a href=&quot;https://juejin.im&quot;&gt;掘金&lt;/a&gt; 上的英文分享文章。内容覆盖 &lt;a href=&quot;https://github.com/xitu/gold-miner#android&quot;&gt;Android&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#ios&quot;&gt;iOS&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#前端&quot;&gt;前端&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#后端&quot;&gt;后端&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#区块链&quot;&gt;区块链&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#产品&quot;&gt;产品&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#设计&quot;&gt;设计&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#人工智能&quot;&gt;人工智能&lt;/a&gt;等领域，想要查看更多优质译文请持续关注 &lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt;、&lt;a href=&quot;http://weibo.com/juejinfanyi&quot;&gt;官方微博&lt;/a&gt;、&lt;a href=&quot;https://zhuanlan.zhihu.com/juejinfanyi&quot;&gt;知乎专栏&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 05 Feb 2018 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>个人作品</title>
        <link>/project/2018/02/02/personal-projects.html</link>
        <guid isPermaLink="true">/project/2018/02/02/personal-projects.html</guid>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/cn/app/id1346384976&quot;&gt;牛皮纸&lt;/a&gt; 一款阅读 Github 上 md 文档的工具，支持浏览远程 md 文档。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/cn/app/id1184113889&quot;&gt;日本语社区&lt;/a&gt; 日语学习资源，整合各种文本、音频和视频学习资料。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/cn/app/id1176787145&quot;&gt;今日账单&lt;/a&gt; 帐单记录与数据分析，内含云备份功能，界面简洁清爽。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/cn/app/id1188174656&quot;&gt;Piclip&lt;/a&gt; 即兴想起的一款九宫格切图软件，当然还有六、四等宫格布局。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 02 Feb 2018 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>数据链路层之 LLDP</title>
        <link>/web/2018/01/29/data-link-layer-lldp.html</link>
        <guid isPermaLink="true">/web/2018/01/29/data-link-layer-lldp.html</guid>
        <description>&lt;p&gt;随着网络技术的发展，接入网络的设备的种类越来越多，配置越来越复杂，来自不同设备厂商的设备也往往会增加自己特有的功能，这就导致在一个网络中往往会有很多具有不同特性的、来自不同厂商的设备，为了方便对这样的网络进行管理，就需要使得不同厂商的设备能够在网络中相互发现并交互各自的系统及配置信息。 &lt;/p&gt;

&lt;p&gt;LLDP（Link Layer Discovery Protocol，链路层发现协议）就是用于这个目的的协议。LLDP 定义在 802.1ab 中，它是一个二层协议，它提供了一种标准的链路层发现方式。LLDP 协议使得接入网络的一台设备可以将其主要的&lt;strong&gt;能力，管理地址，设备标识，接口标识&lt;/strong&gt;等信息发送给接入同一个局域网络的其它设备。当一个设备从网络中接收到其它设备的这些信息时，它就将这些信息以MIB的形式存储起来。&lt;/p&gt;

&lt;p&gt;这些 MIB 信息可用于发现设备的物理拓扑结构以及管理配置信息。需要注意的是 LLDP 仅仅被设计用于进行信息通告，它被用于通告一个设备的信息并可以获得其它设备的信息，进而得到相关的 MIB 信息。它不是一个配置、控制协议，无法通过该协议对远端设备进行配置，&lt;strong&gt;它只是提供了关于网络拓扑以及管理配置的信息，这些信息可以被用于管理、配置的目的，如何用取决于信息的使用者。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;结构&quot;&gt;结构&lt;/h2&gt;

&lt;p&gt;LLDP 的框架结构如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-struct.png&quot; alt=&quot;LLDP 结构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此图也表明 LLDP 就是一个信息发现与通告协议，LLDP 的实体主要维护了两个 MIB 库，一个 local system MIB，一个 remote system MIB。从其名字也可以看出，一个用于维护本地相关的设备 MIB 信息，一个用于维护远端设备 MIB 信息。&lt;/p&gt;

&lt;p&gt;LLDP 通过与上图中右侧的几个 MIB 库交互来初始化并维护 local system MIB，并将本地的相关信息通告出去；同时当接收到来自其它设备的信息时就将其更新到remote system MIB 中。通过这种工作方式，一个设备就可以将自己的信息通告出去并获得网络中其它设备的相关信息，最终获得反应网络拓扑以及其它配置信息的两个 MIB 库。这两个库可以被其用户用来完成各种功能。需要说明的是&lt;strong&gt;LLDP 信息的通告以及接收处理不受端口的STP状态的影响。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;基本概念&quot;&gt;基本概念&lt;/h2&gt;

&lt;h3 id=&quot;帧格式&quot;&gt;帧格式&lt;/h3&gt;

&lt;p&gt;封装有 LLDPDU 的报文称为 LLDP 帧，其封装格式有两种：Ethernet II 和 SNAP（Subnetwork Access Protocol，子网访问协议）。&lt;/p&gt;

&lt;h4 id=&quot;ethernet-ii-格式封装的-lldp-帧&quot;&gt;Ethernet II 格式封装的 LLDP 帧&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-ethernet-ii-frame.png&quot; alt=&quot;Ethernet II 格式封装的 LLDP 帧&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是以 Ethernet II 格式封装的 LLDP 帧，其中各字段的含义如下： &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DA：目的 MAC 地址，为固定的组播 MAC 地址 0x0180-C200-000E。 &lt;/li&gt;
  &lt;li&gt;SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 指与设备相邻连接设备的桥 MAC。&lt;/li&gt;
  &lt;li&gt;LLDP Ethertype：帧类型，为 0x88CC。 &lt;/li&gt;
  &lt;li&gt;LLDPDU：LLDP Data Unit，LLDP 数据单元，它是 LLDP 信息交换的主体。&lt;/li&gt;
  &lt;li&gt;FCS：帧检验序列。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;snap-格式封装的-lldp-帧&quot;&gt;SNAP 格式封装的 LLDP 帧&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-snap-frame.png&quot; alt=&quot;SNAP 格式封装的 LLDP 帧&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是以 SNAP 格式封装的 LLDP 帧，其中各字段的含义如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DA：目的 MAC 地址，为固定的组播 MAC 地址 01-80-C2-00-00-0E。 &lt;/li&gt;
  &lt;li&gt;SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 &lt;/li&gt;
  &lt;li&gt;Type：帧类型，为 0xAAAA-0300-0000-88CC。 &lt;/li&gt;
  &lt;li&gt;Data：数据，为 LLDPDU。 &lt;/li&gt;
  &lt;li&gt;FCS：帧检验序列。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;目的地址&quot;&gt;目的地址&lt;/h4&gt;

&lt;p&gt;目的地址实际上包括三个，分别为 01-80-C2-00-00-0E，01-80-C2-00-00-03，01-80-C2-00-00-00。这三个地址分别用于不同的目的，它们可以跨越不同的网络。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;01-80-C2-00-00-0E，也被称为 Nearest Bridge 组地址：无论是 Two-Port MAC Relay (TPMR)组件、S-VLAN 组件、C-VLAN 组件，还是 802.1D 网桥都不能转发目的为该地址的帧。简单的说任何类型的网桥都不能转发目的为该地址的帧，目的为该地址的帧被限制在连接两个网桥接口的连接上传输。&lt;/li&gt;
  &lt;li&gt;01-80-C2-00-00-03，也被称为 Nearest non-TPMR Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件将成为一个中继器，即不接收它。而 S-VLAN（Service Provider VLAN）组件，C-VLAN（Customer VLAN）组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR。&lt;/li&gt;
  &lt;li&gt;01-80-C2-00-00-00，也被称为 Nearest Customer Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件以及 S-VLAN 组件将成为中继器，即不接收它。而 C-VLAN 组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR 以及 S-VLAN。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tpmr-介绍&quot;&gt;TPMR 介绍&lt;/h3&gt;

&lt;p&gt;TPMR 以及 S-VLAN，C-VLAN 都是 802.1Q 中的概念，包括这三者的网络以及各个地址的作用范围如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-mac-addr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-group-mac-addr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-diff-os-mac-addr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C-VLAN：Customer VLAN，是用户网络内部使用的 VLAN；&lt;/li&gt;
  &lt;li&gt;S-VLAN：Service VLAN，服务提供商网络中使用的 VLAN，该 VLAN 标识 VPN 用户或者是用户的业务；&lt;/li&gt;
  &lt;li&gt;Customer Bridge: Customer 网络中的 Bridge，只能识别 C-VLAN；&lt;/li&gt;
  &lt;li&gt;Provider Bridge：服务提供商网络中的 Bridge，根据处理内容的不同又分为S-VLAN Bridge 和 Provider Edge Bridge。其中 S-VLAN Bridge 只能识别 S-VLAN； Provider Edge Bridge 可以同时识别 C-VLAN 和 S-VLAN；&lt;/li&gt;
  &lt;li&gt;C-VLAN Component：在 Bridge 内可识别、插入、删除 C-VLAN 的实体，每个端口一个，对 C-VLAN 的操作互相独立（两个端口上接收到相同的 C-VLAN，但由于属于不同的客户最后的处理结果会不同）；&lt;/li&gt;
  &lt;li&gt;S-VLAN Component：在 Bridge 内可识别、插入、删除 S-VLAN 的实体，由于在一个 Bridge 内不存在相同的 S-VLAN 属于不同服务提供商的情况，因此在一个桥内只有一个 S-VLAN 的实体。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;qinq-介绍&quot;&gt;QinQ 介绍&lt;/h3&gt;

&lt;p&gt;QinQ 的理论基础，是 IEEE 定义的 802.1ad。在这个规范里面，IEEE 提出了一个概念，它认为汇聚和接入层那里有这么两种设备：S-VLAN Bridge 和 Provider Edge Bridge，再往下就是 Customer System 了（注意，这里说 System 而不是 Bridge，是因为 Customer 接进来的未必是二层设备，可能也是三层设备）。VLAN 空间也被分成两个 VLAN 空间，即 S-VLAN 和 C-VLAN，S 即 Service Provider，C 即 Customer。在 S-VLAN Bridge 上，只有 S-VLAN 空间，而在 Provider Edge Bridge 上，则既有 S-VLAN 空间，又有 C-VLAN 空间。相应的，这个 Bridge 就被从逻辑上划分为两部分，支持 S-VLAN 功能的部分称之为 S-VLAN Component，支持 C-VLAN 功能的部分称之为 C-VLAN Component。S-VLAN Bridge 只包含 S-VLAN Component。&lt;/p&gt;

&lt;p&gt;除了两种 Bridge 的概念，802.1ad 还提出了三种 Service 类型和四种 Port 类型，其中一种 Port 是内部 Port，对用户不可见，其它三种 Port 分别对应了三种不同的 Service，即运营商可以通过在交换机上配置三种不同的 Port 类型，来相应的为用户提供三种不同类型的 Service。三种 Service 分别是 Port Based Service，C-Tag Based Service 和 S-Tag Based Service。四种Port 分别是 Customer Network Port （CN）， Customer Edge Port（CE），Provider Network Port（PN），Provider Edge Port（内部 Port）。&lt;/p&gt;

&lt;p&gt;所谓 Port Based Service，就是说某个 Service 是基于 Port 的，从该 Port 进来的所有报文，都被认为是属于某一个特定的 Customer 的，不管它是否带 C-Tag，带了什么样的 C-Tag，这些信息统统被忽视。所有从这个 Port 进来的报文被赋予一个 S-VLAN，该 S-VLAN 被用来标识该 Customer，或说该 Service。提供这种 Service 的 Port 就是CN Port。CN Port 的实质就是运营商为一个 Customer 提供一个专门的 Port，不跟别的 Customer 共享。注意，从这个 Port 上进来的报文不能带 S-Tag，否则会被丢弃。也就是说，对于 S-Tag 而言，这个 Port 是 Access Port，而不是 Trunk Port。这是跟后面的 S-Tag Based service 本质的不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-port-based-pbn.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所谓的 S-Tag Based Service，就是说从一个 Port 上进来的报文，根据 S-VLAN 来把它们划分到不同的 Customer，换句话说，是用 S-VLAN 来标记 Customer。提供这种 Service 的 Port 也是 CN Port，只不过这个时候的 CN Port，必须配置成 Trunk Port，只识别 S-VLAN，根据 S-VLAN 来标识 Customer，转发报文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-port-based-pbn-struct.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所谓的 C-Tag Based Service，就是指报文携带 C-Tag 进入 Port，在该 Port 上基于 C-VLAN 来标识 Customer，一个 Port 上可以支持多个 Customer。用来支持 C-Tag Based Service 的 Port 就是 CE Port，CE Port 是 C-VLAN Component 的一部分，对于 C-VLAN 而言，CE Port 是 Trunk Port。它不识别 S-Tag。&lt;/p&gt;

&lt;p&gt;PN Port 是 S-VLAN Component 的一部分，它跟 CN Port 唯一的不同是 CN Port 面向 Customer Network，而它面向 Provider Network，在实际的交换机中通常被配置成 Uplink Port，而且通常都是 VLAN Trunk Mode（相对于 Access Mode）。&lt;/p&gt;

&lt;p&gt;对于一个拥有 S-VLAN Component 和 C-VLAN Component 的 Provider Edge Bridge 而言，在做 Mac Forwarding/Learning 的时候，有两种模式，一种是用 &lt;code class=&quot;highlighter-rouge&quot;&gt;S-VLAN+MAC&lt;/code&gt;，另外一种则是 &lt;code class=&quot;highlighter-rouge&quot;&gt;S-VLAN+C-VLAN+MAC&lt;/code&gt;，前者即所谓的 C-VLAN Unaware Mode，而后者则是 C-VLAN Aware Mode。&lt;/p&gt;

&lt;p&gt;C-VLAN Aware Mode 带来的好处是显而易见的，因为它将 VLAN 空间从 4K 扩展到了 16M，但是它的问题在于，当前绝大多数芯片都不支持，就算支持了，也不太可能支持到理论上的 16M。&lt;/p&gt;

&lt;h4 id=&quot;一种独创的-qinq-模式&quot;&gt;一种独创的 QinQ 模式&lt;/h4&gt;

&lt;p&gt;现实世界中用户的需求是千奇百怪，有一种需求，是市场上现存的交换机所解决不了的。在讨论这种需求之前，先看一下当前交换机的做法。无论各个厂家的实现差别有多大，但是有一点大家都是一样的，就是在接入交换机上，通过 Port 或者 C-VLAN 来识别用户，然后为每个用户分配一个 S-VLAN，然后用 S-VLAN 来做后续处理，如 ACL/QoS/Mac Learning/Mac Forwarding 等。&lt;/p&gt;

&lt;p&gt;但是运营商，特别是欧美的一些运营商可能有这样的需求，为了描述的方便，我们假设有个运营商 A，它在为它的客户提供服务的时候，有的时候需要租用别的运营商，假设是运营商 B 的网络，在租用网络的时候，A 这些 B 的客户，运营商 B 需要给 A 分配 S-VLAN，而且往往是一个 S-VLAN 多少钱，因为 VLAN 是稀缺资源，特别是网络比较大的时候。这个时候，如果运营商 A 为它自己的客户每个都分配一个 S-VLAN，那么相应的它就需要向 B 也申请很多个 S-VLAN，不划算，这个时候它就想在自己的接入设备上，不用 S-VLAN 来标识 Customer，给所有的 Customer 分配同一个 S-VLAN，用该 S-VLAN 来穿越 B 的网络，这个时候，S-VLAN 的意义不是代表 Customer，而是代表一个 Tunnel。&lt;/p&gt;

&lt;p&gt;问题关键在于，如果不用 S-VLAN 来代表 Customer，在 A 的接入设备上，如何来对不同的 Customer 来做区分处理呢？用 C-VLAN 肯定是不行的，因为不同 Port 上的 C-VLAN 代表的 Customer 可能是不同的。Centec 的交换机，在芯片内部用一个不同于 C-VLAN 和 S-VLAN 的 CustomerID 来标识 Customer，用这个值来做后续的一系列 Customer 的处理，非常强大。&lt;/p&gt;

&lt;h4 id=&quot;qinq-的不足&quot;&gt;QinQ 的不足&lt;/h4&gt;

&lt;p&gt;尽管 QinQ 貌似很好很强大，并且受到热烈追捧，但是这不能掩盖它的先天不足。&lt;/p&gt;

&lt;p&gt;QinQ 的最大不足就是它无法对运营商网络完全隐藏 Customer 信息，因为它可以让运营商 Core Network 的设备看不到 Customer VLAN，但是无法让它们看不到 Customer MAC。而这一点有两个不利的影响，一个是 Scalability 非常差，如果中间的设备都是二层设备，会导致 MAC 表非常大；第二个不利的影响则是，一旦 Customer 网络出现了环路，会导致 Provider Network 里面的设备不断进行 MAC Learning，万一有 ARP 之类报文，还可能冲击 CPU。&lt;/p&gt;

&lt;p&gt;如果 Customer VLAN 对运营商网络不可见，那么就起不到扩展 VLAN 空间的作用，运营商的 VLAN 空间就仍然只有 4K。&lt;/p&gt;

&lt;p&gt;而 PBB，即所谓的 MAC-in-MAC 则能很好的解决 QinQ 的这个不足，因为 PBB 不仅在原来的报文上新增一个 VLAN，还新增 MACSa/MACDa 以及 24 个 bit 的 Isid（用来标识 Service），它可以完全对运营商的 Core Network 设备隐藏 Customer 信息，且能利用 Isid 来支持 16M Customer/Service。&lt;/p&gt;

&lt;p&gt;当然PBB也有PBB的问题，目前看不到它有成为主流技术的趋势。&lt;/p&gt;

&lt;h2 id=&quot;lldpdu&quot;&gt;LLDPDU&lt;/h2&gt;

&lt;p&gt;LLDPDU 是 LLDP 的有效负载，用于承载要发送的消息。LLDPDU 的格式如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-du.png&quot; alt=&quot;LLDPDU&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LLDPDU 采用了 TLV 的格式，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;type+length+value&lt;/code&gt; 的格式，type 表示 TLV 的类型，length 是以字节为单位的 TLV 的长度，value 是该 TLV 的值。其中 Chassis ID TLV，Port ID TLV Time To Live TLV 以及 End Of LLDPDU TLV 是强制的，必须包含的部分，除此之外在 TLV Time To Live TLV 和 End Of LLDPDU TLV 之间可以包含 0 个到多个可选的其它 TLV。&lt;/p&gt;

&lt;h2 id=&quot;tlv&quot;&gt;TLV&lt;/h2&gt;

&lt;p&gt;TLV 是组成 LLDPDU 的单元，每个 TLV 都代表一个信息。LLDPDU 的 TLV 可以分为两大类&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;被认为是网络管理的基础的 TLV 集合，所有的 LLDP 实现都需要支持。&lt;/li&gt;
  &lt;li&gt;组织定义的 TLV 扩展集合，包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;802.1&lt;/code&gt; 组织定义 TLV、&lt;code class=&quot;highlighter-rouge&quot;&gt;802.3&lt;/code&gt; 组织定义 TLV 以及其他组织定义的 TLV。这些 TLV 用于增强对网络设备的管理，可根据实际需要选择是否在 LLDPDU 中发送。 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TLV 的基本格式如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-format.png&quot; alt=&quot;TLV基本格式图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TLV的类型域的定义及分配如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-list.png&quot; alt=&quot;TLV类型域&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;type0-8&lt;/code&gt; 属于基本的 TLV 集合。对于其中的 Mandatory 的 TLV，它是必须包含在 LLDP 中的。 组织定义 TLV 集合的格式如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-frame.png&quot; alt=&quot;TLV集合格式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;OUI：组织机构的 ID。&lt;/li&gt;
  &lt;li&gt;organizationally defined subtype：组织自定义的类型。&lt;/li&gt;
  &lt;li&gt;organizationally defined information string：传输的信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;基础-tlv-集合&quot;&gt;基础 TLV 集合&lt;/h2&gt;

&lt;p&gt;几个强制的必须包含的 TLV 的定义如下。非强制的可以参考 IEEE802.1AB。&lt;/p&gt;

&lt;h3 id=&quot;end-of-lldpdu-tlv&quot;&gt;End Of LLDPDU TLV&lt;/h3&gt;

&lt;p&gt;该 TLV 用于标识 LLDPDU 的结束。其格式如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-end.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于 length=0，因此它不包含 value 域。&lt;/p&gt;

&lt;h3 id=&quot;chassis-id-tlv&quot;&gt;Chassis ID TLV&lt;/h3&gt;

&lt;p&gt;该 TLV 用于通告该 LLDPDU 发送者的 Chassis ID。由于有很多方式可用来标识一个 Chassis，因此在该类 TLV 中包含一个子类型域用于告诉接收者，发送者的 Chassis ID 采用的是哪一种标识方式。其格式如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-chassis.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 LLDPDU 必须包含且仅包含一个该类型的 TLV。由于 Chassis ID 实际上是用于标识设备的，因此在连接可用时它应该保持不变。 Chassis 子类型所可能的取值如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-chassis-list.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;port-id-tlv&quot;&gt;Port ID TLV&lt;/h3&gt;

&lt;p&gt;它用于标识发送该 LLDPDU 的设备的端口。类似于 Chassis ID，有很多方式可以标识一个 Port，因此该 TLV 也包含一个子类型域。其格式如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-port.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个 LLDPDU 必须包含一个且只能包含一个该类型的 TLV。同时，当端口可用时，从该端口发送出去的 LLDPDU 的该 TLV 应该保持不变。 其子类型的可能取值如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-port-list.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;time-to-live-tlv&quot;&gt;Time To Live TLV&lt;/h3&gt;

&lt;p&gt;该 TLV 用于告诉接收端，它接收到的这些信息的有效期有多长。其格式如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-tlv-ttl.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TTL 的时间单位是秒，由于只有 2 个字节长，因而最大有效时间是 65536 秒。如果在这个时间到期了还没有新的 LLDPDU 被收到，则该 TLV 所属的那个 LLDPDU 携带的信息会被从 MIB 中删除。如果收到了新的 LLDPDU，则&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果 TTL 不为 0，则会用新收到的 LLDPDU 的信息替换 MIB 库中的相应的信息（即与该 LLDPDU 的发送者相关的 MIB 信息，LLDP 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 来判断是否来自于同一个源，这也是要求这两者保持不变的原因）。&lt;/li&gt;
  &lt;li&gt;如果 TTL 为 0，则删除相应的 MIB 库中的信息（即与该 LLDPDU 的发送者相关的 MIB 信息）。因此 TTL 为 0 的 LLDPDU 又被称为SHUTDOWN LLDPDU。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一个 LLDPDU 必须包含且只能包含一个该类型的 TLV。&lt;/p&gt;

&lt;h2 id=&quot;工作机制&quot;&gt;工作机制&lt;/h2&gt;

&lt;p&gt;LLDP 是一个用于信息通告和获取的协议，但是需要注意的一点是，LLDP 发送的信息通告不需要确认，不能发送一个请求来请求获取某些信息，也就是说 LLDP 是一个单向的协议，只有主动通告一种工作方式，无需确认，不能查询、请求（比如像 ARP 协议那样请求某个 IP 的 MAC 地址）。&lt;/p&gt;

&lt;p&gt;LLDP 主要完成如下工作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;初始化并维护本地 MIB 库中的信息。&lt;/li&gt;
  &lt;li&gt;从本地 MIB 库中提取信息，并将信息封装到 LLDP 帧中。LLDP 帧的发送有两种触发方式，一是定时器到期触发，一是设备状态发生了变化触发。&lt;/li&gt;
  &lt;li&gt;识别并处理接收到的 LLDPDU 帧。&lt;/li&gt;
  &lt;li&gt;维护远端设备 LLDP MIB 信息库。&lt;/li&gt;
  &lt;li&gt;当本地或远端设备 MIB 信息库中有信息发生变化时，发出通告事件。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;lldpdu-发送&quot;&gt;LLDPDU 发送&lt;/h3&gt;

&lt;h4 id=&quot;发送机制&quot;&gt;发送机制&lt;/h4&gt;

&lt;p&gt;LLDPDU 的发送可以被如下事件触发：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;与本地 MIB 信息库相关联的定时器 txTTR 到期时，这将确保远端接收系统中的相关信息不会因为 TTL 到期而过期。&lt;/li&gt;
  &lt;li&gt;本地 MIB 信息库中的信息发生了改变时，会立即发送 LLDPDU，这将保证改变能及时被更新。&lt;/li&gt;
  &lt;li&gt;如果一个“新邻居”被识别，将会启用快速发送机制，在很短的时间内连续发送指定数量（txFastInit，默认值为 4）的 LLDPDU，以确保“新邻居”能被快速更新。如果远端系统 MIB 信息库因为过载（tooManyNeighbors）而不能容纳新的邻居信息，则会为了避免过多的LLDPDU 传输而抑制快速发送行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LLDP 的常规发送时间是建立在系统的 Tick 之上的，间隔为 1 秒一个，为了防止在共享介质的 LAN（shared media LAN）中同时出现大量的 LLDPDU（因为接入同一个LAN的多个系统的时间是同步的，因而多个系统上的基于 Tick 的1秒定时器可能同时到期），发送定时器引入了一个随机的抖动，这就使得常规的 LLDP 帧的发送间隔时间的平均值仍是 1 秒，但是具体到某一次到期时间可能并不是准确的 1 秒。&lt;/p&gt;

&lt;p&gt;同时为了防止在有多个端口需要发送 LLDPDU 的系统中，所有的端口的定时器都在同一时间到期，因而标准建议将采用某种机制将多个发送实例的定时器到期时间给错开，以避免一个系统在同一时刻发送大量的 LLDPDU。&lt;/p&gt;

&lt;h4 id=&quot;发送状态机&quot;&gt;发送状态机&lt;/h4&gt;

&lt;p&gt;LLDPDU 的发送状态机如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-send-state-machine.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于该状态机：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为了防止过于频繁的重新初始化发送状态机，在 LLDP 的发送状态机中引入了一个延时，该延时限制了在关闭发送状态机后，必须至少等待多长时间才能重新初始化发送状态机。&lt;/li&gt;
  &lt;li&gt;是否发送 SHUTDOWN LLDPDU 由本地的 LLDP 工作状态决定。&lt;/li&gt;
  &lt;li&gt;是否发送正常的 LLDPDU 由 txNow 和 txCredit 决定。这两个变量都由发送定时器状态机更新。txNow 决定是否发送，而 txCredit 则是一个信用量，决定了可以发送的量，如果是 0 则不允许发送，只有大于 0 的值才允许发送，每发送一个该值就减 1。更重要的是在本地信息快速改变时，txCredit 既允许连续发送多个 LLDPDU，但是又对可以连续发送的 LLDPDU 帧数做了限制，这使得本地状态的快速改变可以及时被通告出去，但是又不能无限发送导致网络出现大量 LLDPDU 帧。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;发送定时器状态机&quot;&gt;发送定时器状态机&lt;/h4&gt;

&lt;p&gt;LLDP 发送定时器状态机如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-send-timer-state-machine.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;localChange 表示本地信息是否发生改变；txTTR 表示下一次定时器到期的时间；newNeighbor 表示是否发现了新的邻居，并由接收状态设置，由该状态机清除；txTick 表示基于系统时间的1秒定时器是否到期。&lt;/p&gt;

&lt;p&gt;对于该状态机：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SIGNAL_TX 用于触发发送，它会将 txNow 设置为允许发送，并设置本地信息发生改变为 FALSE，如果当前不是在快速发送状态（txFast = 0）就设置发送定时器下次到期时间为 msgTxInterval（msgTxInterval默认为30秒，取值范围1-3600秒），否则设置发送定时器下次到期时间为 msgFastTx（msgFastTx默认值为1秒，取值范围1-3600秒）。&lt;/li&gt;
  &lt;li&gt;如果本地信息发生了改变，就立即进入 SIGNAL_TX。&lt;/li&gt;
  &lt;li&gt;如果定时器到期，则如果 txFast 大于 0，则将其减 1 并进入 SIGNAL_TX，否则直接进入 SIGNAL_TX。&lt;/li&gt;
  &lt;li&gt;如果发现了新邻居，则首先将发现新邻居的标识更新为没有发现新邻居，然后如果当前已经处于快速发送状态就直接进入发送定时器到期状态（以触发一次立即发送），否则设置 txFast 的值为 txFastInit 的值（txFastInit 默认值为 4，取值范围 1-8）。&lt;/li&gt;
  &lt;li&gt;如果基于系统时间的 1 秒定时器到期，则给 txCredit 增加信用量，其最大值为 txCreditMax，txCreditMax 是一个取值在 1 到 10 之间的值，默认值为 5。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有取值范围的几个变量都是可配置的变量。&lt;/p&gt;

&lt;p&gt;从上述两个状态机的工作状态可以看出，发送定时器状态机用于维护信用量以及是否允许发送 LLDPDU 帧，而发送状态机根据这两个信息来决定是否发送。另外需要注意的是 LLDP 所使用的所有定时器操作都是“基于系统时间的 1 秒定时器的”，每当这个定时器到期时它除了会将 txTick 设置为 TRUE 外，还会处理其它的定时功能。&lt;/p&gt;

&lt;h3 id=&quot;lldpdu-接收&quot;&gt;LLDPDU 接收&lt;/h3&gt;

&lt;h4 id=&quot;接收机制&quot;&gt;接收机制&lt;/h4&gt;

&lt;p&gt;LLDP 帧的接收由 3 个阶段组成：帧的识别、帧的校验、LLDP 远端 MIB 信息库更新。&lt;/p&gt;

&lt;h5 id=&quot;帧的识别&quot;&gt;帧的识别&lt;/h5&gt;

&lt;p&gt;由在 LLDP/LSAP（链路服务访问点）进行，检查的内容是帧的目的地是否是 LLDP 的组播 MAC 地址，帧的类型是否是 LLDP。&lt;/p&gt;

&lt;h5 id=&quot;帧的验证&quot;&gt;帧的验证&lt;/h5&gt;

&lt;p&gt;该过程会首先根据 TLV 的格式定义依次校验 Chassis ID TLV，Port ID TLV， Time To Live TLV，如果这三个 TLV 都存在且有效，才会进一步的解码可选的 TLV 直到遇到 End Of LLDPDU TLV，然后根据获得的信息更新远端 MIB 信息库。&lt;/p&gt;

&lt;h5 id=&quot;远端-mib-信息库更新&quot;&gt;远端 MIB 信息库更新&lt;/h5&gt;

&lt;p&gt;在前两步都通过之后，LLDPDU 的接收者就需要根据解析出来的信息更新远端 MIB 信息库。在 MIB 信息库中，LLDP 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 来标识、存储来自不同源的信息。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果远端MIB库中已经有对应于该 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 的信息，则使用收到的帧中的新的 TTL 来更新 TTL。并用对于收到的新的 LLDPPDU 中的每一种 type，如果有变化就进行更新，如果某种 type 原来不存在，则需要将其添加到 MIB 库中。&lt;/li&gt;
  &lt;li&gt;如果实现不支持某种类型的 type，则
    &lt;ol&gt;
      &lt;li&gt;如果 type 不是 127，则按照基本 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value。&lt;/li&gt;
      &lt;li&gt;如果 type 是 127，则按照组织定义 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value，OUI，组织自定义子类型，以及信息域。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更新时，如果需要添加新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 的表项，或者为某个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 添加新的 TLV，则可能遇到没有内存的问题，标准没有规定必须如何处理，只是给出了一些建议：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;忽略新的 LLDPDU 的信息&lt;/li&gt;
  &lt;li&gt;删除最旧的信息以释放空间给新的信息&lt;/li&gt;
  &lt;li&gt;随机删除一些旧的信息以释放空间给新的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LLDPDU 携带的 TTL（Time To Live）值会影响接收端的处理方式，如果它不为 0，则更新相应信息的老化时间，如果接收到的 LLDPDU 中的 TTL 等于 0，则将立刻老化掉相应的信息（即与该 LLDPDU 的发送者相关的MIB信息）。&lt;/p&gt;

&lt;p&gt;如果一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Chassis ID+Port ID&lt;/code&gt; 标识的信息的 TTL 超时，则相应的 MIB 信息会被删除。&lt;/p&gt;

&lt;h4 id=&quot;接收状态机&quot;&gt;接收状态机&lt;/h4&gt;

&lt;p&gt;LLDPDU 的接收状态机如图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-receive-state-machine.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;lldp-工作模式&quot;&gt;LLDP 工作模式&lt;/h3&gt;

&lt;p&gt;LLDP 可以工作在多种模式下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TxRx：既发送也接收 LLDP 帧。&lt;/li&gt;
  &lt;li&gt;Tx：只发送不接收 LLDP 帧。&lt;/li&gt;
  &lt;li&gt;Rx：只接收不发送 LLDP 帧。&lt;/li&gt;
  &lt;li&gt;Disable：既不发送也不接收 LLDP 帧（准确的说，这并不是一个 LLDP 的状态，这可能是 LLDP 功能被关闭了，也可能是设备就不支持）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于 LLDP 可以单独工作在发送或接收模式下，因此 LLDP 协议的实现需要支持单独初始化发送或者接收功能。当工作模式发生变化时，需要根据老的/新的工作模式来关闭/打开发送或者接收的功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-mib-block.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/data-link-layer-lldp-state-machine-symbol.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，LLDP 相关知识点已经介绍完，希望对大家有所帮助。&lt;/p&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>TensorFlow 广度和深度学习的教程</title>
        <link>/ml/2017/11/30/tensorflow-wide-and-deep.html</link>
        <guid isPermaLink="true">/ml/2017/11/30/tensorflow-wide-and-deep.html</guid>
        <description>&lt;p&gt;在前文 &lt;a href=&quot;https://www.tensorflow.org/tutorials/wide&quot;&gt;《TensorFlow Liner Model Tutorial》&lt;/a&gt; 中，我们使用 &lt;a href=&quot;https://archive.ics.uci.edu/ml/datasets/Census+Income&quot;&gt;人口收入普查数据集&lt;/a&gt; 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？&lt;/p&gt;

&lt;p&gt;在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 &lt;a href=&quot;http://arxiv.org/abs/1606.07792&quot;&gt;研究论文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.tensorflow.org/images/wide_n_deep.svg&quot; alt=&quot;Wide &amp;amp; Deep Spectrum of Models&quot; title=&quot;Wide &amp;amp; Deep&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，我们来看一个简单的例子。&lt;/p&gt;

&lt;p&gt;上图展示了广度模型（具有稀疏特征和转换性质的 logistic 回归模型），深度模型（具有一个嵌入层和多个隐藏层的前馈神经网络），广度和深度模型（两者的联合训练）的区别比较。在高层级里，只需要通过以下三个步骤就能使用 TF.Learn API 配置广度，深度或广度和深度模型。&lt;/p&gt;

&lt;p&gt;1.选择广度部分的特征：选择要使用的稀疏基本列和交叉列。&lt;/p&gt;

&lt;p&gt;2.选择深度部分的特征：选择连续列，每个分类列的嵌入维度和隐藏层大小。&lt;/p&gt;

&lt;p&gt;3.将它们一起放入广度和深度模型（&lt;code class=&quot;highlighter-rouge&quot;&gt;DNNLinearCombinedClassifier&lt;/code&gt;）。&lt;/p&gt;

&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;如果想要尝试本教程中的代码：&lt;/p&gt;

&lt;p&gt;1.安装 TensorFlow ，&lt;a href=&quot;http://chars.tech/2017/09/26/tensorflow-pycharm-mac/&quot;&gt;请前往此处&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;2.下载 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py&quot;&gt;教程代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;3.安装 pandas 数据分析库。因为本教程中需要使用 pandas 数据。虽然 tf.learn 不要求 pandas，但是它支持 pandas。安装 pandas：&lt;/p&gt;

&lt;p&gt;a. 获取 pip：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Ubuntu/Linux 64-bit
$ sudo apt-get install python-pip python-dev

# Mac OS X
$ sudo easy_install pip
$ sudo easy_install --upgrade six
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;b. 使用 pip 安装 pandas&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo pip install pandas
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果你在安装过程中遇到问题，请前往 pandas 网站上的 &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;说明&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;4.执行以下命令来训练教程中描述的线性模型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python wide_n_deep_tutorial.py --model_type=wide_n_deep
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;请继续阅读，了解此代码如何构建其线性模型。&lt;/p&gt;

&lt;h2 id=&quot;定义基本特征列&quot;&gt;定义基本特征列&lt;/h2&gt;

&lt;p&gt;首先，定义我们使用的基本分类和连续特征的列。这些列将被作为模型的广度部分和深度部分的构件块。&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tensorflow&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;gender&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Female&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Male&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;education&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Bachelors&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;HS-grad&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;11th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Masters&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;9th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Some-college&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Assoc-acdm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Assoc-voc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;7th-8th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Doctorate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Prof-school&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;5th-6th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;10th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;1st-4th&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Preschool&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;12th&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;marital_status&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;marital_status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Married-civ-spouse&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Divorced&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Married-spouse-absent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Never-married&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Separated&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Married-AF-spouse&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Widowed&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;relationship&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;relationship&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Husband&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Not-in-family&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Wife&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Own-child&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Unmarried&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Other-relative&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;workclass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_vocabulary_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;workclass&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Self-emp-not-inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Private&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;State-gov&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Federal-gov&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;Local-gov&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;?&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Self-emp-inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Without-pay&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Never-worked&quot;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 展示一个哈希的例子：&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;occupation&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_hash_bucket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;native_country&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categorical_column_with_hash_bucket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;native_country&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 连续基列&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;age&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;education_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;education_num&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;capital_gain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;capital_gain&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;capital_loss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;capital_loss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;hours_per_week&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numeric_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hours_per_week&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 转换&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;age_buckets&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bucketized_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boundaries&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;55&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;65&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;广度模型具有交叉特征列的线性模型&quot;&gt;广度模型：具有交叉特征列的线性模型&lt;/h2&gt;

&lt;p&gt;广度模型是一个具有稀疏和交叉特征列的线性模型：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;base_columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;native_country&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;education&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;relationship&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age_buckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;crossed_columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crossed_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crossed_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;age_buckets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crossed_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;native_country&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash_bucket_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具有交叉特征列的广度模型可以有效地记忆特征之间的稀疏交互。也就是说，交叉特征列不能概括没有在训练数据中出现的特征组合。让我们采用嵌入方式来添加一个深度模型来修复这个问题。&lt;/p&gt;

&lt;h2 id=&quot;深度模型嵌入式神经网络&quot;&gt;深度模型：嵌入式神经网络&lt;/h2&gt;

&lt;p&gt;深度模型是一个前馈神经网络，如前图所示。每一个稀疏，高维度分类特征首先都会被转换成一个低维度密集的实值矢量，通常被称为嵌入式矢量。这些低维度密集的嵌入式矢量与连续特征相连，然后在正向传递中馈入神经网络的隐藏层。嵌入值随机初始化，并与其他模型参数一起训练，以最大化减少训练损失。如果你有兴趣了解更多关于嵌入的知识，请在查阅教程 &lt;a href=&quot;https://www.tensorflow.org/versions/r0.9/tutorials/word2vec/index.html&quot;&gt;Vector Representations of Words&lt;/a&gt; 或在 Wikipedia 上查阅 &lt;a href=&quot;https://en.wikipedia.org/wiki/Word_embedding&quot;&gt;Word Embedding&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;我们将使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;embedding_column&lt;/code&gt; 配置分类嵌入列，并将它们与连续列连接：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;deep_columns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;education&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gender&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;indicator_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;relationship&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 展示一个嵌入例子&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;embedding_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;native_country&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feature_column&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;embedding_column&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;occupation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dimension&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;age&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;education_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;capital_gain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;capital_loss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hours_per_week&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;嵌入的 &lt;code class=&quot;highlighter-rouge&quot;&gt;dimension&lt;/code&gt; 越高，自由度就越高，模型将不得不学习这些特性的表示。为了简单起见，我们设置所有特征列的维度为 8。从经验上看，关于维度的设定最好是从 \log_{2}(n) 或 k\sqrt[4]{n} 值开始，这里的 n 代表特征列中唯一特征的数量，k 是一个很小的常量（通常小于10）。&lt;/p&gt;

&lt;p&gt;通过密集嵌入，深度模型可以更好的概括，并更好对之前没有在训练数据中遇见的特征进行预测。然而，当两个特征列之间的底层交互矩阵是稀疏和高等级时，很难学习特征列的有效低维度表示。在这种情况下，大多数特征对之间的交互应该为零，除了少数几个，但密集的嵌入将导致所有特征对的非零预测，从而可能过度泛化。另一方面，具有交叉特征的线性模型可以用更少的模型参数有效地记住这些“异常规则”。&lt;/p&gt;

&lt;p&gt;现在，我们来看看如何联合训练广度和深度模型，让它们优势和劣势互补。&lt;/p&gt;

&lt;h2 id=&quot;将广度和深度模型结合为一体&quot;&gt;将广度和深度模型结合为一体&lt;/h2&gt;

&lt;p&gt;通过将其最终输出的对数几率作为预测结合起来，然后将预测提供给 logistic 损失函数，将广度模型和深度模型相结合。所有的图形定义和变量分配都已经被处理，所以你只需要创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;DNNLinearCombinedClassifier&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;tempfile&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mkdtemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contrib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;learn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DNNLinearCombinedClassifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;linear_feature_columns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wide_columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dnn_feature_columns&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;deep_columns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dnn_hidden_units&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;训练和评估模型&quot;&gt;训练和评估模型&lt;/h2&gt;

&lt;p&gt;在训练模型之前，请先阅读人口普查数据集，就像在 &lt;a href=&quot;https://www.tensorflow.org/tutorials/wide&quot;&gt;《TensorFlow Liner Model Tutorial》&lt;/a&gt; 中所做的一样。 输入数据处理的代码再次为你提供方便：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pandas&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;urllib&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 为数据集定义列名&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CSV_COLUMNS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;age&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;workclass&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fnlwgt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;education&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;education_num&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;marital_status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;occupation&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;relationship&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;race&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gender&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;capital_gain&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;capital_loss&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hours_per_week&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;native_country&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;income_bracket&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;maybe_download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Maybe downloads training data and returns train and test file names.&quot;&quot;&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_data&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NamedTemporaryFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;urllib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlretrieve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# pylint: disable=line-too-long&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;train_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Training data is downloaded to &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_data&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tempfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NamedTemporaryFile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;urllib&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urlretrieve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;# pylint: disable=line-too-long&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;test_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Test data is downloaded to &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;Input builder function.&quot;&quot;&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read_csv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gfile&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CSV_COLUMNS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;skipinitialspace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;python&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;skiprows&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# 移除 NaN 元素&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dropna&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;how&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;any&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;axis&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;labels&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;income_bracket&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&amp;gt;50K&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;astype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;estimator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pandas_input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;df_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;batch_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;num_threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;阅读数据之后，你可以训练并评估模型：&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 将 num_epochs 设置为 None，以获得无限的数据流&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_steps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 在所有数据被消耗之前，为了运行评估，设置 steps 为 None&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;evaluate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_fn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_file_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_epochs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shuffle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;steps&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;model directory = &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;model_dir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sorted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出的第一行应该类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;accuracy: 0.84429705&lt;/code&gt;。我们可以看到使用广度和深度模型将广度线性模型精度约 83.6% 提高到了约 84.4%。如果你想看端对端的工作示例，你可以下载我们的 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/examples/learn/wide_n_deep_tutorial.py&quot;&gt;示例代码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;请注意，本教程只是一个小型数据基的简单示例，为了让你快速熟悉 API。如果你有大量具有稀疏特征列和大量可能特征值的数据集，广度和深度学习将会更加强大。此外，请随时关注我们的 &lt;a href=&quot;http://arxiv.org/abs/1606.07792&quot;&gt;研究论文&lt;/a&gt;，以了解更多关于在实际中广度和深度学习在大型机器学习方面如何应用的思考。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;原文地址：&lt;a href=&quot;https://www.tensorflow.org/tutorials/wide_and_deep&quot;&gt;https://www.tensorflow.org/tutorials/wide_and_deep&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译文出自：&lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;译者：&lt;a href=&quot;https://github.com/charsdavy&quot;&gt;charsdavy&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;校对者：&lt;a href=&quot;https://github.com/MRNIU&quot;&gt;MRNIU&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt; 是一个翻译优质互联网技术文章的社区，文章来源为 &lt;a href=&quot;https://juejin.im&quot;&gt;掘金&lt;/a&gt; 上的英文分享文章。内容覆盖 &lt;a href=&quot;https://github.com/xitu/gold-miner#android&quot;&gt;Android&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#ios&quot;&gt;iOS&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#前端&quot;&gt;前端&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#后端&quot;&gt;后端&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#区块链&quot;&gt;区块链&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#产品&quot;&gt;产品&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#设计&quot;&gt;设计&lt;/a&gt;、&lt;a href=&quot;https://github.com/xitu/gold-miner#人工智能&quot;&gt;人工智能&lt;/a&gt;等领域，想要查看更多优质译文请持续关注 &lt;a href=&quot;https://github.com/xitu/gold-miner&quot;&gt;掘金翻译计划&lt;/a&gt;、&lt;a href=&quot;http://weibo.com/juejinfanyi&quot;&gt;官方微博&lt;/a&gt;、&lt;a href=&quot;https://zhuanlan.zhihu.com/juejinfanyi&quot;&gt;知乎专栏&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Thu, 30 Nov 2017 22:00:10 +0800</pubDate>
      </item>
    
      <item>
        <title>聊聊 iOS 数据保护</title>
        <link>/pieces/2017/10/17/ios-data-protection.html</link>
        <guid isPermaLink="true">/pieces/2017/10/17/ios-data-protection.html</guid>
        <description>&lt;p&gt;文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。&lt;/p&gt;

&lt;h2 id=&quot;钥匙串keychain&quot;&gt;钥匙串（keychain）&lt;/h2&gt;

&lt;p&gt;keychain服务提供了一种安全的保存私密信息（密码，序列号，私钥，证书等）的方式，每个iOS程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因APP被删除而丢失。&lt;/p&gt;

&lt;p&gt;基于钥匙串的特点，我们在使用时对于新增的数据项目，要注意数据删除的时机。还有一点需要注意的就是，保护属性的指定。如果没有指定保护属性，这将被视为严重的安全漏洞。&lt;/p&gt;

&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;

&lt;h4 id=&quot;备份&quot;&gt;备份&lt;/h4&gt;

&lt;p&gt;当我们备份设备数据时，系统会将用户数据保存在相应的钥匙串中，并依照相应的安全策略保存。主要分成两类：&lt;strong&gt;加密&lt;/strong&gt;和&lt;strong&gt;不加密&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;两者的主要区别在于恢复数据时的范围不同。加密备份的数据可以恢复到任何设备上（ThisDeviceOnly指定的项目除外），而不加密的备份则只能恢复至同一台设备。&lt;/p&gt;

&lt;h4 id=&quot;共享&quot;&gt;共享&lt;/h4&gt;

&lt;p&gt;keychain支持在多个应用之间共享数据。但现实开发中&lt;code class=&quot;highlighter-rouge&quot;&gt;UIPasteboardNameFind&lt;/code&gt;的使用代替了keychain。不过好在Apple在iOS11中已经废弃它。看来Apple想规范开发者对于用户敏感数据的共享使用，同时提醒大家使用更加安全的方式存储用户敏感数据。&lt;/p&gt;

&lt;h3 id=&quot;使用范例&quot;&gt;使用范例&lt;/h3&gt;

&lt;h4 id=&quot;secitemadd&quot;&gt;SecItemAdd&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];
NSData *passwordData = [@&quot;myPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;Conglomco&quot; forKey:(__bridge id)kSecAttrLabel];
[dict setObject:@&quot;This is your password for the Conglomco service.&quot; forKey:(__bridge id)kSecAttrDescription];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];
[dict setObject:passwordData forKey:(__bridge id)kSecValueData];
[dict setObject:(__bridge id)kSecAttrAccessibleWhenUnlocked forKey:(__bridge id)kSecAttrAccessible];

OSStatus error = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);
if (error == errSecSuccess) {
    NSLog(@&quot;Yay&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;secitemdelete&quot;&gt;SecItemDelete&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];

OSStatus error = SecItemDelete((__bridge CFDictionaryRef)dict);
if (error == errSecSuccess) {
	NSLog(@&quot;Yay&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;secitemupdate&quot;&gt;SecItemUpdate&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];
NSData *newPasswordData = [@&quot;newMyPassword&quot; dataUsingEncoding:NSUTF8StringEncoding];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];

NSDictionary *updatedAttribute = [NSDictionary dictionaryWithObject:newPasswordData forKey:(__bridge id)kSecValueData];

OSStatus error = SecItemUpdate((__bridge CFDictionaryRef)dict, (__bridge CFDictionaryRef)updatedAttribute);
if (error == errSecSuccess) {
	NSLog(@&quot;Yay&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;secitemcopymatching&quot;&gt;SecItemCopyMatching&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];

[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];
[dict setObject:@&quot;chars&quot; forKey:(__bridge id)kSecAttrAccount];
[dict setObject:@&quot;cn.zaker.keychain.sample&quot; forKey:(__bridge id)kSecAttrService];
[dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnAttributes];

NSDictionary *result = nil;
OSStatus error = SecItemCopyMatching((__bridge CFDictionaryRef)dict, (void *)&amp;amp;result);
if (error == errSecSuccess) {
	NSLog(@&quot;Yay %@&quot;, result);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;常用方法&quot;&gt;常用方法&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemAdd&lt;/td&gt;
      &lt;td&gt;添加数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemDelete&lt;/td&gt;
      &lt;td&gt;删除数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemUpdate&lt;/td&gt;
      &lt;td&gt;修改数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SecItemCopyMatching&lt;/td&gt;
      &lt;td&gt;查找数据&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;保护属性&quot;&gt;保护属性&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;钥匙串保护属性&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAfterFirstUnlock&lt;/td&gt;
      &lt;td&gt;开机之后密钥不可用，直到用户首次输入密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAlways&lt;/td&gt;
      &lt;td&gt;密钥在设备开机后依旧可用。在iOS9中已经废弃&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAlwaysThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;密钥始终可用，但无法迁移到其他设备&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;作用同上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleWhenUnlocked&lt;/td&gt;
      &lt;td&gt;只要解锁过设备，则密钥保持可用状态&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleWhenUnlockedThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;作用同上&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly&lt;/td&gt;
      &lt;td&gt;作用同上，只有用户设置密码密钥才可用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleAlways&lt;/code&gt; 将会引入一个很明显的安全问题，因为此种保护属性，只要有人窃取了你的设备，他们就能读取钥匙串的内容。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly&lt;/code&gt; 这个属性可以完美的解决上述的安全问题。因为越狱时通常需要重启设备。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleWhenUnlocked&lt;/code&gt; 这个属性要求攻击者必须知道用户密码才能提取隐私数据。它很适合做默认属性值。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly&lt;/code&gt; 是iOS8新增的保护属性。这个属性要求在使用时用户设定了密码，否则使用就失败。&lt;/p&gt;

&lt;h3 id=&quot;基本用法&quot;&gt;基本用法&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;项目类&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassGenericPassword&lt;/td&gt;
      &lt;td&gt;普通密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassInternetPassword&lt;/td&gt;
      &lt;td&gt;专门用于互联网服务的密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassCertificate&lt;/td&gt;
      &lt;td&gt;加密证书&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassKey&lt;/td&gt;
      &lt;td&gt;加密密钥&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;kSecClassIdentity&lt;/td&gt;
      &lt;td&gt;一个密钥对（包括公共证书和私钥）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;icloud同步&quot;&gt;iCloud同步&lt;/h3&gt;

&lt;p&gt;这是iOS7引入的一种新机制，可以把钥匙串项目同步到iCloud，允许用户在多个设备之间共享钥匙串项目。&lt;/p&gt;

&lt;p&gt;默认情况下，应用程序创建的钥匙串项目会禁用这个机制，但可以把&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrSynchronizable&lt;/code&gt;设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;来启用。&lt;/p&gt;

&lt;p&gt;另外请注意，使用此选项时无法指定不兼容的kSecAttrAccessible属性。例如，指定kSecAttrAccessibleWhenUnlockedThisDeviceOnly不起作用，因为ThisDeviceOnly指定的项目不会备份，也不能同步到iCloud、笔记本电脑、台式机或其他同步位置。&lt;/p&gt;

&lt;h2 id=&quot;数据保护&quot;&gt;数据保护&lt;/h2&gt;

&lt;p&gt;Apple 推出了数据保护API作为额外的保护层，它允许开发者指定文件解密密钥的生命周期。可以使用这个API控制文件的访问权限，与钥匙串项目中的kSecAttrAccessible 属性类似。&lt;/p&gt;

&lt;p&gt;数据保护API使用用户密码和层级密钥来加密保护文件的密钥，而当这些文件不能被访问时，会从内存中删除这个层级密钥。&lt;/p&gt;

&lt;h3 id=&quot;文件保护过程&quot;&gt;文件保护过程&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_2.png&quot; alt=&quot;文件保护过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1.文件生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;文件密钥&lt;/code&gt;来加密文件的内容。&lt;/p&gt;

&lt;p&gt;2.生成一个额外的密钥对，用于生成&lt;code class=&quot;highlighter-rouge&quot;&gt;文件公钥&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;文件私钥&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;3.用&lt;code class=&quot;highlighter-rouge&quot;&gt;文件私钥&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Protected Unless Open等级公钥&lt;/code&gt;计算出一个&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;4.用&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt; SHA-1散列值加密文件密钥。&lt;/p&gt;

&lt;p&gt;5.加密过的&lt;code class=&quot;highlighter-rouge&quot;&gt;文件密钥&lt;/code&gt;会存储在文件的元数据中，元数据中还有文件的公钥。&lt;/p&gt;

&lt;p&gt;6.系统丢弃&lt;code class=&quot;highlighter-rouge&quot;&gt;文件私钥&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;7.关闭文件时从内存中删除未加密的文件密钥。&lt;/p&gt;

&lt;p&gt;8.需要再次打开文件时，用&lt;code class=&quot;highlighter-rouge&quot;&gt;Protected Unless Open等级私钥&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;文件公钥&lt;/code&gt;计算&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;9.计算&lt;code class=&quot;highlighter-rouge&quot;&gt;共享密码&lt;/code&gt;的SHA-1散列值，把它当作解密文件的密钥。&lt;/p&gt;

&lt;h3 id=&quot;dataprotectionclass-权限&quot;&gt;DataProtectionClass 权限&lt;/h3&gt;

&lt;p&gt;如果你的应用在设备进入后台或锁定时不需要写入或读取文件，那你就可以在工程中配置一个&lt;code class=&quot;highlighter-rouge&quot;&gt;NSFileProtectionComplete&lt;/code&gt;值来添加权限。这将确保所有受保护的文件数据只能在设备解锁时访问，相当于为所有的应用文件都设置&lt;code class=&quot;highlighter-rouge&quot;&gt;kSecAttrAccessibleWhenUnlocked&lt;/code&gt;选项。&lt;/p&gt;

&lt;p&gt;从Xcode5开始，新工程会默认启用数据保护权限，但是一些旧工程并不会自动开启。&lt;/p&gt;

&lt;p&gt;开启方式如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_1.png?imageView2/2/w/800&quot; alt=&quot;开启DataProtectionClass权限&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;使用范例-1&quot;&gt;使用范例&lt;/h3&gt;

&lt;h4 id=&quot;nsdatawritingfileprotectioncomplete&quot;&gt;NSDataWritingFileProtectionComplete&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSData *data = [self generateData];
NSError *error = nil;
NSString *path = [NSString stringWithFormat:@&quot;%@_demo.pdf&quot;, NSTemporaryDirectory()];
[data writeToFile:path options:NSDataWritingFileProtectionComplete error:&amp;amp;error];
if (error) {
	NSLog(@&quot;%@&quot;, error);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;nsfileprotectioncomplete&quot;&gt;NSFileProtectionComplete&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.txt&quot;];
NSError *error = nil;
NSDictionary *attr = [NSDictionary dictionaryWithObject:NSFileProtectionComplete forKey:NSFileProtectionKey];
[[NSFileManager defaultManager] setAttributes:attr ofItemAtPath:path error:&amp;amp;error];
if (error) {
	NSLog(@&quot;%@&quot;, error);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;sqlite_open_fileprotection_completeunlessopen&quot;&gt;SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@&quot;demo.sqlite&quot;];
sqlite3 *handle = NULL;
sqlite3_open_v2([path UTF8String],
                &amp;amp;handle,
                SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,
                NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;保护等级&quot;&gt;保护等级&lt;/h3&gt;

&lt;h4 id=&quot;completeuntilfirstuserauthentication&quot;&gt;CompleteUntilFirstUserAuthentication&lt;/h4&gt;

&lt;p&gt;这个保护等级是iOS5开始使用的默认值。主要用来防御一些需要重启的攻击。&lt;/p&gt;

&lt;h4 id=&quot;complete&quot;&gt;Complete&lt;/h4&gt;

&lt;p&gt;官方称这是目前最安全的文件保护等级。在这种情况下，锁屏之后系统就会删除内存中的层级密钥，并把文件改为不可读。&lt;/p&gt;

&lt;p&gt;具体使用的范例前文可见。&lt;/p&gt;

&lt;p&gt;使用Complete保护之前，考虑是否合适。如果你的应用进程需要持续写/读一个文件，那这种保护模式就不合适了。&lt;/p&gt;

&lt;h4 id=&quot;completeunlessopen&quot;&gt;CompleteUnlessOpen&lt;/h4&gt;

&lt;p&gt;如果一个文件当前被一个应用打开，那会暂时禁用该文件的保护。它会确保打开的文件在设备被锁定时依然能够写入，并且允许新建文件到磁盘。不过这个等级保护的文件在锁屏时无法打开，除非锁屏时就已经提前打开。&lt;/p&gt;

&lt;h2 id=&quot;commoncrypto加密&quot;&gt;CommonCrypto加密&lt;/h2&gt;

&lt;p&gt;CommonCrypto是Apple官方提供的一套加密框架。在使用这套方案时，主要注意以下几个问题即可。&lt;/p&gt;

&lt;h3 id=&quot;避免弱算法&quot;&gt;避免弱算法&lt;/h3&gt;

&lt;p&gt;众所周知，DES就是一种很典型的弱算法。如果你使用弱算法，那应用就很容易遭受密码攻击和暴力破解。&lt;/p&gt;

&lt;p&gt;我们在实际使用时，可以考虑使用AES算法、MD5算法或MD5加盐算法等。&lt;/p&gt;

&lt;h3 id=&quot;破碎的熵&quot;&gt;破碎的熵&lt;/h3&gt;

&lt;p&gt;我们通常会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;rand&lt;/code&gt;方法来产生随机数，但是系统的这个随机函数并不是真正的随机。它产生的随机数符合正态分布，我们可以使用官方提供的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;SecRandomCopyBytes&lt;/code&gt;获得。也可以自己使用算法产生随机数。&lt;/p&gt;

&lt;p&gt;这里分享一个笔者以前自己实现的随机数案例。&lt;a href=&quot;/2016/04/30/uniform-random/&quot;&gt;《均匀分布随机函数的实现》&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;弱密钥&quot;&gt;弱密钥&lt;/h3&gt;

&lt;p&gt;开发者经常将用户的密码当作加密密钥，尤其在移动设备上，这将导致一个非常脆弱、低熵加密的密钥。&lt;/p&gt;

&lt;p&gt;那么正确的姿势是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CCKeyDerivationPBKDF&lt;/code&gt;方法来生成。&lt;/p&gt;

&lt;h2 id=&quot;touch-id&quot;&gt;Touch ID&lt;/h2&gt;

&lt;h3 id=&quot;使用范例-2&quot;&gt;使用范例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;LocalAuthentication/LocalAuthentication.h&amp;gt;

LAContext *context = [[LAContext alloc] init];
NSError *error = nil;
NSString *reason = @&quot;We use this to verify your identify&quot;;
if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;amp;error]) {
	[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError * _Nullable error) {
		if (success) {
			NSLog(@&quot;Hello, that's your finger!&quot;);
		} else {
			NSLog(@&quot;Couldn't read your fingerprint. Falling back to PIN or somthing.&quot;);
		}
	}];
} else {
	NSLog(@&quot;Error : %@ %@&quot;, error, [error userInfo]);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;touch-id-与普通密码相比的安全性&quot;&gt;Touch ID 与普通密码相比的安全性&lt;/h3&gt;

&lt;p&gt;一个人的指纹是世界上最好的密码之一。它独一无二，高度特异，并且无需记忆。它会伴随人终生，所以你可以一直使用同一个指纹密码。&lt;/p&gt;

&lt;p&gt;比起简单的4位数字锁屏密码一万分之一的破解可能性，能找到同样单个指纹的人的概率为五万分之一，这是非常安全的，比起前者我可以不断尝试，Touch ID 指纹的硬性破解几率几乎没有，因为不可能有五万多个人排队来一一解锁你的设备，况且 Touch ID 会拒绝第五次以后的尝试而要求输入密码。所以我们可以添加更加复杂的密码而不是简单的数字密码来进一步提高安全性。&lt;/p&gt;

&lt;h3 id=&quot;touch-id-指纹识别的原理&quot;&gt;Touch ID 指纹识别的原理&lt;/h3&gt;

&lt;p&gt;在如此快速的识别过程中，Home 按钮上的一圈金属环起到了感应手指的功能，通知 Touch ID 来读取指纹。Touch ID 置于该按钮中，传感器的厚度只有 170 微米，拥有 500 ppi 高分辨率，可读取极小的指纹细节。传感器可从皮肤皮下层指纹的一些小部分拍摄高分辨率图像，然后会分析该信息，根据三种基本指纹类型（弧形纹、箕形纹或斗形纹）将指纹分类，它会绘制比人眼不可见的纹路细节，确保指纹读取准确无误。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_3.png&quot; alt=&quot;touch id sensor&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Touch ID 可从 360 度方向读取指纹，随后创建指纹的某种数学表达式，并将其与已注册的数据进行比较，以确定是否匹配。如果匹配，便可替代密码来解锁设备或通过某个令牌。&lt;/p&gt;

&lt;p&gt;此外，根据苹果官方的描述，Touch ID 会向以注册的指纹数据里持续的添加新的特征数据，随着时间的推移，这能不断提高匹配准确度，也能进一步的提高安全性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_4.png&quot; alt=&quot;touch id ontouch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了上述的内容，苹果还加入可以一些有效的手段来进一步确保安全，例如设备再重新启动或者保持锁定 48 小时后，就只能通过密码而不是指纹来解锁设备。&lt;/p&gt;

&lt;h3 id=&quot;secure-enclave&quot;&gt;Secure Enclave&lt;/h3&gt;

&lt;p&gt;Apple声明指纹的图案不会被保存，存储于设备中的是指纹特征的数学表达式，而且从这些表达式不可能直接反推出指纹图像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_5.png&quot; alt=&quot;touch-id-structure&quot; /&gt;&lt;/p&gt;

&lt;p&gt;指纹的验证运算独立于主要处理器芯片（例如 A7、A8），芯片内有称为 “Secure Enclave” 的高级安全架构，专用于密码指纹数据，并使用 Secure Enclave 的专用密钥加密，以及每次启动以随机的 UID 进行管理。指纹数据仅能被 Secure Enclave 处理和使用，正因为此架构独立于其它设备部件，仅有 Touch ID 使用它，且不能将它用于匹配其他指纹数据库，所以存储的指纹数据不会由 iOS 或其他应用访问，也不会被存储到 Apple 服务器或备份到 iCloud 等地方。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios_data_protection_6.png&quot; alt=&quot;A7-Secure-Enclave&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从硬件上来看指纹特征数据尚不能被 “Secure Enclave” 和 Touch ID 以外的部件访问到，并且两者芯片互相隔离开来，所有软件都没有权利获得指纹数据，仅能得到指纹是否错误的回馈。因为架构的核心秘密仅仅只有苹果公司知道，所以目前几乎没有第三方软件可以访问到这部分敏感信息。&lt;/p&gt;

&lt;p&gt;到此，关于 iOS 数据保护的问题暂时告一段落。欢迎大家评论指正。&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Oct 2017 23:18:19 +0800</pubDate>
      </item>
    
      <item>
        <title>MacOS 搭建 Tensorflow PyCharm 环境</title>
        <link>/ml/2017/09/26/tensorflow-pycharm-mac.html</link>
        <guid isPermaLink="true">/ml/2017/09/26/tensorflow-pycharm-mac.html</guid>
        <description>&lt;p&gt;TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，&lt;a href=&quot;https://github.com/tensorflow/tensorflow&quot;&gt;Github&lt;/a&gt;上star最多的项目就是它了。&lt;/p&gt;

&lt;p&gt;在这之前，笔者写过一篇简单的入门文章&lt;a href=&quot;/2017/06/07/tensorflow-primer-guide/&quot;&gt;《初探 TensorFlow》&lt;/a&gt;。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。&lt;/p&gt;

&lt;h2 id=&quot;基于-anaconda-的安装&quot;&gt;基于 Anaconda 的安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt; 是一个集成许多第三方科学计算库的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; 科学计算环境,&lt;code class=&quot;highlighter-rouge&quot;&gt;Anaconda&lt;/code&gt; 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 作为自己的包管理工具,同时具有自己的计算环境,类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;Virtualenv&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Virtualenv&lt;/code&gt; 一样,不同 &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; 工程需要的依赖包,&lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 将他们存储在不同的地方。 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt; 上安装的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Anaconda&lt;/code&gt; 不会对之前安装的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt; 包进行覆盖.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;安装 &lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;Anaconda&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;建立一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 计算环境&lt;/li&gt;
  &lt;li&gt;激活环境,使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;安装成功后,每次使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt; 的时候需要激活 &lt;code class=&quot;highlighter-rouge&quot;&gt;conda&lt;/code&gt; 环境&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;安装-anaconda-&quot;&gt;安装 Anaconda :&lt;/h3&gt;

&lt;p&gt;参考 Anaconda 的下载页面的&lt;a href=&quot;https://www.anaconda.com/download/&quot;&gt;指导&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;建立环境&quot;&gt;建立环境&lt;/h3&gt;

&lt;p&gt;建立一个 conda 计算环境名字叫&lt;code class=&quot;highlighter-rouge&quot;&gt;tensorflow&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Python 2.7
$ conda create -n tensorflow python=2.7

# Python 3.4
$ conda create -n tensorflow python=3.4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;激活&quot;&gt;激活&lt;/h3&gt;

&lt;p&gt;激活&lt;code class=&quot;highlighter-rouge&quot;&gt;tensorflow&lt;/code&gt;环境,然后使用其中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;pip&lt;/code&gt; 安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;TensorFlow&lt;/code&gt;. 当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;easy_install&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--ignore-installed&lt;/code&gt;标记防止错误的产生。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.tensorflow.org/install/install_mac#the_url_of_the_tensorflow_python_package&quot;&gt;URL of the TensorFlow Python package&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source activate tensorflow
(tensorflow)$  # Your prompt should change

# Ubuntu/Linux 64-bit, CPU only, Python 2.7:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl

# Ubuntu/Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.
# For other versions, see &quot;Install from sources&quot; below.
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl

# Mac OS X, CPU only:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.11.0rc0-py2-none-any.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于 Python 3.x :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source activate tensorflow
(tensorflow)$  # Your prompt should change

# Ubuntu/Linux 64-bit, CPU only, Python 3.4:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl

# Ubuntu/Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.
# For other versions, see &quot;Install from sources&quot; below.
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl

# Mac OS X, CPU only:
(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;conda 环境激活后,你可以测试:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python
&amp;gt;&amp;gt;&amp;gt; import tensorflow as tf
&amp;gt;&amp;gt;&amp;gt; print(tf.__version__)
# 0.11.0rc0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;开启或关闭环境&quot;&gt;开启或关闭环境&lt;/h3&gt;

&lt;p&gt;当你不用 TensorFlow 的时候,关闭环境:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(tensorflow)$ source deactivate

$  # Your prompt should change back
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再次使用的时候再激活 :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source activate tensorflow
(tensorflow)$  # Your prompt should change.
# Run Python programs that use TensorFlow.
...
# When you are done using TensorFlow, deactivate the environment.
(tensorflow)$ source deactivate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;pycharm-配置&quot;&gt;PyCharm 配置&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;正确配置&lt;code class=&quot;highlighter-rouge&quot;&gt;Project&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Interpreter&lt;/code&gt;即可&lt;/p&gt;

&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Preferences&lt;/li&gt;
  &lt;li&gt;Project Interpreter&lt;/li&gt;
  &lt;li&gt;Click More&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;附图&quot;&gt;附图&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开Preferences&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_1.png&quot; alt=&quot;打开Preferences&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_2.png&quot; alt=&quot;选择more&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;打开Project Interpreters&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_3.png&quot; alt=&quot;选择正确的tensorflow路径&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Demo运行结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensorflow_pycharm_config_mac_4.png&quot; alt=&quot;demo运行结果&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 26 Sep 2017 23:03:16 +0800</pubDate>
      </item>
    
      <item>
        <title>iOS App 启动性能优化</title>
        <link>/pieces/2017/09/22/ios-app-launch-time-optimize.html</link>
        <guid isPermaLink="true">/pieces/2017/09/22/ios-app-launch-time-optimize.html</guid>
        <description>&lt;p&gt;应用启动时间，直接影响用户对一款应用的判断和使用体验。&lt;code class=&quot;highlighter-rouge&quot;&gt;ZAKER新闻&lt;/code&gt;本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。&lt;/p&gt;

&lt;h2 id=&quot;启动时间&quot;&gt;启动时间&lt;/h2&gt;

&lt;p&gt;总时间 = T1 + T2&lt;/p&gt;

&lt;h3 id=&quot;t1&quot;&gt;T1&lt;/h3&gt;

&lt;p&gt;加载&lt;code class=&quot;highlighter-rouge&quot;&gt;系统dylib&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;可执行文件&lt;/code&gt;的时间。&lt;/p&gt;

&lt;h3 id=&quot;t2&quot;&gt;T2&lt;/h3&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;结束的时间。&lt;/p&gt;

&lt;h2 id=&quot;app启动过程&quot;&gt;App启动过程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-1.png&quot; alt=&quot;App启动过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1）解析&lt;code class=&quot;highlighter-rouge&quot;&gt;Info.plist&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加载相关信息，例如如闪屏&lt;/li&gt;
  &lt;li&gt;沙箱建立、权限检查&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）&lt;code class=&quot;highlighter-rouge&quot;&gt;Mach-O&lt;/code&gt;加载&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果是胖二进制文件，寻找合适当前CPU类别的部分&lt;/li&gt;
  &lt;li&gt;加载所有依赖的&lt;code class=&quot;highlighter-rouge&quot;&gt;Mach-O&lt;/code&gt;文件（递归调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Mach-O&lt;/code&gt;加载的方法）&lt;/li&gt;
  &lt;li&gt;定位内部、外部指针引用，例如字符串、函数等&lt;/li&gt;
  &lt;li&gt;执行声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribute__((constructor))&lt;/code&gt;的C函数&lt;/li&gt;
  &lt;li&gt;加载类扩展（Category）中的方法&lt;/li&gt;
  &lt;li&gt;C++静态对象加载、调用ObjC的&lt;code class=&quot;highlighter-rouge&quot;&gt; +load &lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3）程序执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationMain()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mach-o&quot;&gt;Mach-O&lt;/h3&gt;

&lt;p&gt;Mach-O 是针对不同运行时可执行文件的文件类型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-4.png&quot; alt=&quot;Mach-O&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;文件类型&quot;&gt;文件类型：&lt;/h4&gt;

&lt;p&gt;Executable： 应用的主要二进制&lt;/p&gt;

&lt;p&gt;Dylib： 动态链接库（又称 DSO 或 DLL）&lt;/p&gt;

&lt;p&gt;Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。&lt;/p&gt;

&lt;p&gt;Image： executable，dylib 或 bundle&lt;/p&gt;

&lt;p&gt;Framework： 包含 Dylib 以及资源文件和头文件的文件夹&lt;/p&gt;

&lt;h3 id=&quot;mach-o-镜像文件&quot;&gt;Mach-O 镜像文件&lt;/h3&gt;

&lt;p&gt;Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。&lt;/p&gt;

&lt;p&gt;segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。&lt;/p&gt;

&lt;p&gt;section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。&lt;/p&gt;

&lt;p&gt;几乎所有 Mach-O 都包含这三个段（segment）： &lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;__LINKEDIT&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__TEXT&lt;/code&gt; 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__DATA&lt;/code&gt; 包含全局变量，静态变量等。可读写（rw-）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__LINKEDIT&lt;/code&gt; 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mach-o-universal-文件&quot;&gt;Mach-O Universal 文件&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Fat_binary&quot;&gt;FAT 二进制&lt;/a&gt;文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。&lt;/p&gt;

&lt;p&gt;按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。&lt;/p&gt;

&lt;h3 id=&quot;什么是image&quot;&gt;什么是image&lt;/h3&gt;

&lt;p&gt;1.executable可执行文件 比如.o文件。&lt;/p&gt;

&lt;p&gt;2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。&lt;/p&gt;

&lt;p&gt;3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。&lt;/p&gt;

&lt;p&gt;除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。&lt;/p&gt;

&lt;h3 id=&quot;什么是imageloader&quot;&gt;什么是ImageLoader&lt;/h3&gt;

&lt;p&gt;image 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。&lt;/p&gt;

&lt;p&gt;两步走：在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。&lt;/p&gt;

&lt;h2 id=&quot;冷启动和热启动&quot;&gt;冷启动和热启动&lt;/h2&gt;

&lt;h3 id=&quot;冷启动&quot;&gt;冷启动&lt;/h3&gt;

&lt;p&gt;应用首次启动。即后台线程中未有当前打开的应用，所有的资源都需要加载并初始化。&lt;/p&gt;

&lt;h3 id=&quot;热启动&quot;&gt;热启动&lt;/h3&gt;

&lt;p&gt;应用非首次启动。即后台线程中保留有当前应用，应用的资源在内存中有保存。&lt;/p&gt;

&lt;h2 id=&quot;启动时间分析&quot;&gt;启动时间分析&lt;/h2&gt;

&lt;p&gt;1）开启时间分析功能&lt;/p&gt;

&lt;p&gt;在Xcode的菜单中选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Project&lt;/code&gt;→&lt;code class=&quot;highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;→&lt;code class=&quot;highlighter-rouge&quot;&gt;Edit Scheme...&lt;/code&gt;，然后找到&lt;code class=&quot;highlighter-rouge&quot;&gt; Run&lt;/code&gt; → &lt;code class=&quot;highlighter-rouge&quot;&gt;Environment Variables&lt;/code&gt; →&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_PRINT_STATISTICSvalue&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;的环境变量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-2.png&quot; alt=&quot;开启时间分析功能&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-launch-time-optimize-3.png&quot; alt=&quot;启动时间&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;load-dylibs-image&quot;&gt;load dylibs image&lt;/h3&gt;

&lt;p&gt;在每个动态库的加载过程中， dyld需要：&lt;/p&gt;

&lt;p&gt;1.分析所依赖的动态库&lt;/p&gt;

&lt;p&gt;2.找到动态库的mach-o文件&lt;/p&gt;

&lt;p&gt;3.打开文件&lt;/p&gt;

&lt;p&gt;4.验证文件&lt;/p&gt;

&lt;p&gt;5.在系统核心注册文件签名&lt;/p&gt;

&lt;p&gt;6.对动态库的每一个segment调用mmap()&lt;/p&gt;

&lt;p&gt;通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：&lt;/p&gt;

&lt;p&gt;1.减少非系统库的依赖&lt;/p&gt;

&lt;p&gt;2.合并非系统库&lt;/p&gt;

&lt;p&gt;3.使用静态资源，比如把代码加入主程序&lt;/p&gt;

&lt;h3 id=&quot;rebasebind&quot;&gt;rebase/bind&lt;/h3&gt;

&lt;p&gt;由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。&lt;/p&gt;

&lt;p&gt;rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。&lt;/p&gt;

&lt;p&gt;优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：&lt;/p&gt;

&lt;p&gt;1.减少Objc类数量， 减少selector数量&lt;/p&gt;

&lt;p&gt;2.减少C++虚函数数量&lt;/p&gt;

&lt;p&gt;3.转而使用swift stuct（其实本质上就是为了减少符号的数量）&lt;/p&gt;

&lt;h3 id=&quot;解读&quot;&gt;解读&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前总共使用了506.48ms&lt;/li&gt;
  &lt;li&gt;在506.48ms中，加载动态库用了46.35ms，指针重定位使用了137.72ms，ObjC类初始化使用了95.39ms，各种初始化使用了226.92ms。&lt;/li&gt;
  &lt;li&gt;在初始化耗费的226.92ms中，用时最多的几个初始化是&lt;code class=&quot;highlighter-rouge&quot;&gt;libSystem.B.dylib&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libBacktraceRecording.dylib&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libglInterpose.dylib&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;libMTLInterpose.dylib&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2）使用instruments工作分析具体时间消耗点&lt;/p&gt;

&lt;h2 id=&quot;耗时的影响因素&quot;&gt;耗时的影响因素&lt;/h2&gt;

&lt;p&gt;1） &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前耗时的影响因素&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;动态库加载越多，启动越慢。&lt;/li&gt;
  &lt;li&gt;ObjC类越多，启动越慢&lt;/li&gt;
  &lt;li&gt;C的&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;函数越多，启动越慢&lt;/li&gt;
  &lt;li&gt;C++静态对象越多，启动越慢&lt;/li&gt;
  &lt;li&gt;ObjC的&lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;越多，启动越慢&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实验证明，在ObjC类的数目一样多的情况下，需要加载的动态库越多，App启动就越慢。同样的，在动态库一样多的情况下，ObjC的类越多，App的启动也越慢。需要加载的动态库从1个上升到10个的时候，用户几乎感知不到任何分别，但从10个上升到100个的时候就会变得十分明显。同理，100个类和1000个类，可能也很难查察觉得出，但1000个类和10000个类的分别就开始明显起来。&lt;/p&gt;

&lt;p&gt;同样的，尽量不要写&lt;code class=&quot;highlighter-rouge&quot;&gt;__attribute__((constructor))&lt;/code&gt;的C函数，也尽量不要用到C++的静态对象；至于ObjC的&lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;方法，似乎大家已经习惯不用它了。任何情况下，能用&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_once()&lt;/code&gt;来完成的，就尽量不要用到以上的方法。&lt;/p&gt;

&lt;p&gt;2） &lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之后耗时的影响因素&lt;/p&gt;

&lt;p&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数开始至&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;结束，我们统一称为&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之后的部分。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数的耗时&lt;/li&gt;
  &lt;li&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;的耗时&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt;及其&lt;code class=&quot;highlighter-rouge&quot;&gt;childViewController&lt;/code&gt;的加载、&lt;code class=&quot;highlighter-rouge&quot;&gt;view&lt;/code&gt;及其&lt;code class=&quot;highlighter-rouge&quot;&gt;subviews&lt;/code&gt;的加载&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;

&lt;h3 id=&quot;移除不需要用到的类&quot;&gt;移除不需要用到的类&lt;/h3&gt;

&lt;p&gt;为了解决这个历史问题，我使用了一个叫做&lt;a href=&quot;https://github.com/dblock/fui&quot;&gt;fui（Find Unused Imports）&lt;/a&gt;的开源项目，它能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。&lt;/p&gt;

&lt;p&gt;使用方法是在&lt;code class=&quot;highlighter-rouge&quot;&gt;Terminal&lt;/code&gt;中&lt;code class=&quot;highlighter-rouge&quot;&gt;cd&lt;/code&gt;到项目所在的目录，然后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;fui find&lt;/code&gt;，然后等上那么几分钟（是的你没有看错，真的需要好几分钟甚至需要更长的时间），就可以得到一个列表了。由于这个工具还不是100%靠谱，可根据这个列表，在Xcode中手动检查并删除不再用到的类。&lt;/p&gt;

&lt;h3 id=&quot;合并功能类似的类和扩展category&quot;&gt;合并功能类似的类和扩展（Category）&lt;/h3&gt;

&lt;h3 id=&quot;优化applicationdidfinishlaunchingwithoptions方法&quot;&gt;优化&lt;code class=&quot;highlighter-rouge&quot;&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;方法&lt;/h3&gt;

&lt;h3 id=&quot;优化rootviewcontroller加载&quot;&gt;优化&lt;code class=&quot;highlighter-rouge&quot;&gt;rootViewController&lt;/code&gt;加载&lt;/h3&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;p&gt;1）&lt;code class=&quot;highlighter-rouge&quot;&gt;NSUserDefaults&lt;/code&gt;是否是瓶颈&lt;/p&gt;

&lt;p&gt;2）还有其他哪些点可以做优化&lt;/p&gt;

&lt;p&gt;参考文档：&lt;a href=&quot;http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/&quot;&gt;《优化 App 的启动时间》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Sep 2017 22:02:16 +0800</pubDate>
      </item>
    
      <item>
        <title>那些设计iOS API需要知道的事</title>
        <link>/pieces/2017/07/10/ios-design-api-guide.html</link>
        <guid isPermaLink="true">/pieces/2017/07/10/ios-design-api-guide.html</guid>
        <description>&lt;p&gt;为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。&lt;/p&gt;

&lt;h2 id=&quot;命名&quot;&gt;命名&lt;/h2&gt;

&lt;h3 id=&quot;命名冲突的问题&quot;&gt;命名冲突的问题&lt;/h3&gt;

&lt;p&gt;Objective-C没有其他语言的那种内置命名空间（namespace）机制。因此，我们只能自己想办法来解决命名冲突问题。最常用的解决方式就是，仿照其他语言（C++）建立自己的namespace，例如，使用前缀。&lt;/p&gt;

&lt;p&gt;所选前缀可以是与公司、应用程序或二者皆有关联之名。例如，ZAKER User Interface可以使用ZUI作为前缀。使用Cocoa创建应用程序时一定要注意，Apple宣称其保留使用所有“两字母前缀”(two-letter prefix)的权利，所以开发者选用的前缀应该是三个字母的。如果开发者使用了两个字母作前缀，那么很有可能开发者自定义的API和Apple的API冲突。&lt;/p&gt;

&lt;p&gt;不仅仅是类名，应用程序中的所有名称都应该加前缀。如果要为既有类新增“分类”(category)，那么一定要给“分类”及“分类”中的方法加上前缀。另外，类的实现文件中所用的纯C函数及全局变量也应该注意添加前缀。&lt;/p&gt;

&lt;p&gt;如果使用了第三方库编写自己的代码，并准备将其发布为程序库供他人开发应用程序所用，则尤其要注意重复符号问题。这种情况下为了避免使用者使用了与你相同的第三方库，应该为第三方库都加上你自己的前缀。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-1.png?imageView/2/w/400&quot; alt=&quot;第三方库引入使用前缀&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;命名方式&quot;&gt;命名方式&lt;/h3&gt;

&lt;p&gt;类、方法和变量的命名是Objective-C编程的重要环节。如果命名方式好，可以提高代码可读性，减少不必要的注释。
初学者通常会觉得Objective-C是门很繁琐的语言，因为其语法结构使得代码读起来和句子一样。命名中一般都带有“in”、“for”、“with”等介词，特别是在命名时还要讲究英文语法。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *text = @&quot;This is a good idea.&quot;;
NSString *newText = [text stringByReplacingOccurrencesOfString:@&quot;idea&quot; withString:@&quot;think&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码虽然用了比较啰嗦的方式描述一个看上去很简单的表达式。对于执行替换的那个方法，代码读起来就像日常语言里的那个句子：“Take text and give me a new string by replacing the occurrences of the string ‘idea’ with the string ‘think’”。
这个句子准确描述了开发者想做的事。在命名不像Objective-C这般繁琐的语言中，类似的程序可能会写成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string text = &quot;This is a good idea.&quot;;
string new Text = text.replace(&quot;idea&quot;, &quot;think&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码这样写，看起来方法名简洁很多，但是带来的代码不可读性却是非常大的。首先，我们不知道 text.replace 方法的两个参数到底按照什么顺序解读（除非查看方法声明）；再者，这两个参数谁替换谁？&lt;/p&gt;

&lt;p&gt;另外，和大多数语言一样，Objective-C也是采用“驼峰式大小写命名法”（camel casing）——以小写字母开头，其后每个单词首字母大写。&lt;/p&gt;

&lt;h4 id=&quot;方法命名&quot;&gt;方法命名&lt;/h4&gt;

&lt;p&gt;清晰的方法名从左至右读起来好似一段文章。并不是说非得按照那些命名规则来给方法起名，不过这样做可以令代码变得更好维护，使他人更容易读懂。
虽然类似C++或Java中那种函数命名简单，但是，若想知道每个参数的用途，就得查看函数原型，这会令代码难于读懂。
NSString这个类展示了一套良好的命名习惯。下面列举几个方法及命名缘由：&lt;/p&gt;

&lt;p&gt;1）&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (instancetype)string;&lt;/code&gt;
工厂方法（factory method），用于创建新的空字符串。方法名清晰地描述了返回值的类型。&lt;/p&gt;

&lt;p&gt;2）&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (instancetype)stringWithString:(NSString *)string;&lt;/code&gt;
工厂方法，根据某字符串创建出与之内容相同的新字符串。与创建空字符串所用的那个工厂方法一样，方法名的第一个单词也指明了返回类型。&lt;/p&gt;

&lt;p&gt;3）&lt;code class=&quot;highlighter-rouge&quot;&gt;+ (instancetype)localizedStringWithFormat:(NSString *)format, ...;&lt;/code&gt;
工厂方法，根据特定格式创建出新的“本地化字符串”（localized string）。返回值类型是方法名的第二个单词（string），因为其前面还有个修饰语（localized）用来描述其逻辑含义。此方法的返回值依然是“字符串”（string），只不过是一种经过本地化处理的特殊字符串。&lt;/p&gt;

&lt;p&gt;4）&lt;code class=&quot;highlighter-rouge&quot;&gt;- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;&lt;/code&gt;
若字符串是以给定的编码格式（ASCII、UTF8、UTF16）来编码的，则返回其字节数组长度。此方法与length相似，但该方法还需一个参数，该参数紧跟着方法名中描述其类型的那个名词（encoding）。&lt;/p&gt;

&lt;p&gt;因此，我们可以总结成几条方法命名规则：&lt;/p&gt;

&lt;p&gt;1）如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。即便有时返回内部对象的一份拷贝，我们也认为那相当于原有对象。这些存取方法应该按照其所对应的属性来命名。&lt;/p&gt;

&lt;p&gt;2）应该把表示参数类型的名词放在参数前面。&lt;/p&gt;

&lt;p&gt;3）如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。&lt;/p&gt;

&lt;p&gt;4）不要使用str这种简称，应该使用string这样的全称。&lt;/p&gt;

&lt;p&gt;5）boolean属性应加is前缀。如果某方法返回非属性的boolean值，那么应该根据其功能，选用has或is当前缀。&lt;/p&gt;

&lt;p&gt;6）将get这个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言式数组”（C-style array）里的那种方法就可以使用这个词做前缀。&lt;/p&gt;

&lt;h4 id=&quot;类与协议命名&quot;&gt;类与协议命名&lt;/h4&gt;

&lt;p&gt;不仅仅是方法，类和协议也应该加上前缀，避免命名空间冲突。例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UIView&lt;/li&gt;
  &lt;li&gt;UIViewController&lt;/li&gt;
  &lt;li&gt;UITableViewDelegate&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;错误模型&quot;&gt;错误模型&lt;/h2&gt;

&lt;p&gt;目前有很多编程语言都有“异常”(exception)机制，Objective-C也不例外。&lt;/p&gt;

&lt;p&gt;“自动引用计数”(ARC, Automatic Reference Counting)在默认情况下不是“异常安全的”。这意味着：如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放了。如果想生成“异常安全”的代码，可以通过设置编译器的标志来实现，不过这将引入额外代码，在不抛出异常时，也照样要执行这部分代码。需要打开的编译器标志叫做&lt;code class=&quot;highlighter-rouge&quot;&gt;-fobjc-arc-exception&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;Objective-C现在所采用的办法是：只在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。这就是说，不用再编写复杂的“异常安全”代码了。&lt;/p&gt;

&lt;p&gt;异常只应该用于极其严重的错误，比如，你编写了某个抽象基类，它的正确用法是先从中继承一个子类，然后使用这个子类。在这种情况下，如果有人直接使用了这个抽象基类，那么可以考虑抛出异常。与其他语言不同，Objective-C中没办法将某个类标识为“抽象类”。要想达成类似效果，最好的办法是在那些子类必须覆写的超类方法里抛出异常。&lt;/p&gt;

&lt;p&gt;异常只用于处理严重错误(fatal error)，对于其他错误，Objective-C语言所用的编程范式为：令方法返回nil/0，或使用NSError，以表明有错误发生。&lt;/p&gt;

&lt;p&gt;NSError对象里封装了三条信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error domain (错误范围，其类型为字符串)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。例如，URL-handling-subsystem，在从URL中解析或获取数据时如果出错了，那么就使用NSURLErrorDomain来表示错误范围。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Error code (错误码，其类型为整数)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;独有的错误码，用以指明在某个范围内具体发生了何种错误。某个特定范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;User info (用户信息，其类型为字典)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有关此错误的额外信息，其中或许包含一段“本地化描述”，或许还包含有导致该错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链”。&lt;/p&gt;

&lt;h2 id=&quot;使用不可变对象&quot;&gt;使用不可变对象&lt;/h2&gt;

&lt;p&gt;设计类的时候，应充分使用属性来封装数据。而在使用属性时，则可将其声明为&lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt;。默认情况下，属性是&lt;code class=&quot;highlighter-rouge&quot;&gt;readwrite&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因为如果把可变对象(mutable object)放入collection之后又修改其内容，那么很容易就会破坏set的内部数据结构，使其失去固有的语义。故此，我们应该尽量减少对象中的可变内容。具体到编程实践中，则应该尽量把对外公布出来的属性设为&lt;code class=&quot;highlighter-rouge&quot;&gt;readonly&lt;/code&gt;，而且只在有必要时才将属性对外公布。&lt;/p&gt;

&lt;p&gt;定义类的公共API时，需要注意，对象里表示各种collection的那些属性究竟应该设成可变的，还是不可变的。如果某个属性可以为外界所增删，那么这个属性就需要用可变的set来实现。在这种情况下，通常应该提供一个readonly属性供外界使用，该属性将返回不可变的set，而此set则是内部那个可变set的一份拷贝。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//  ZKRPointOfInterest.h

#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface ZKRPointOfInterest : NSObject

@property (nonatomic, copy, readonly) NSString *identifier;
@property (nonatomic, copy, readonly) NSString *title;
@property (nonatomic, assign, readonly) CGFloat latitude;
@property (nonatomic, assign, readonly) CGFloat longitude;
@property (nonatomic, strong, readonly) NSSet *locations;

- (instancetype)initWithIdentifier:(NSString *)identifier
                             title:(NSString *)title
                          latitude:(CGFloat)latitude
                         longitude:(CGFloat)longitude;

- (void)addLocation:(ZKRPointOfInterest *)location;
- (void)removeLocation:(ZKRPointOfInterest *)location;

@end

//  ZKRPointOfInterest.m

#import &quot;ZKRPointOfInterest.h&quot;

@implementation ZKRPointOfInterest
{
    NSMutableSet *_internalLocations;
}

- (instancetype)initWithIdentifier:(NSString *)identifier
                             title:(NSString *)title
                          latitude:(CGFloat)latitude
                         longitude:(CGFloat)longitude
{
    self = [super init];
    if (self) {
        
    }
    return self;
}

- (NSSet *)locations
{
    return [_internalLocations copy];
}

- (void)addLocation:(ZKRPointOfInterest *)location
{
    if (location) {
        [_internalLocations addObject:location];
    }
}

- (void)removeLocation:(ZKRPointOfInterest *)location
{
    [_internalLocations removeObject:location];
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;不要在返回的对象上查询类型以确定其是否可变。(即使不用&lt;code class=&quot;highlighter-rouge&quot;&gt;isKindOfClass:&lt;/code&gt;方法来判断返回值类型是否可变)&lt;/p&gt;

&lt;h2 id=&quot;description方法&quot;&gt;description方法&lt;/h2&gt;

&lt;p&gt;在调试程序时，经常需要打印并查看对象信息。一种办法是编写代码把对象的全部属性都log到日志中。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLog(@&quot;object=%@&quot;, object);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在构建需要打印到日志的字符串时，object对象会收到description消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的“%@”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSArray *obj = @[@&quot;A string&quot;, @(123)];
NSLog(@&quot;object=%@&quot;, obj);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object=(
	&quot;A string&quot;,
	123
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果在自定义类上这么做，那么则输出的信息却是如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;object=&amp;lt;ZKRSqure: 0x7656d8a90060&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想要像上面NSArray那样打印出有用的信息，那么我们就应该在自己的类中覆写description方法，否则打印信息时就会调用NSObject类所实现的默认方法。此方法定义在NSObject协议里，不过NSObject类也实现了它。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (NSString *)description
{
    return [NSString stringWithFormat:@&quot;&amp;lt;%@: %p, \&quot;%f %f\&quot;&amp;gt;&quot;, [self class], self, _width, _height];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ZKRRectangle *rectangle = [[ZKRRectangle alloc] initWithWidth:5.0 height:7.0];
NSLog(@&quot;%@&quot;, rectangle);

//Output
&amp;lt;ZKRRectangle: 0x60000002fc20, &quot;5.000000 7.000000&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;NSObject协议中还有个需要注意的方法，就是&lt;code class=&quot;highlighter-rouge&quot;&gt;debugDescription&lt;/code&gt;，此方法用意与&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;相似。二者区别在于，&lt;code class=&quot;highlighter-rouge&quot;&gt;debugDescription&lt;/code&gt;方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，它只是直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;description&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;初始化方法&quot;&gt;初始化方法&lt;/h2&gt;

&lt;p&gt;所有对象均要初始化，在初始化时，有些对象可能无须开发者向其提供额外信息，不过一般来说还是需要提供的。通常情况下，对象若不知道必要的信息，则无法完成其工作。例如，UITAbleViewCell类初始化该类对象时，需要指明其样式及标识符，标识符能够区分不同类型的单元格。由于这种对象的创建成本较高，所以绘制表格时可依照标识符来复用，以提升程序效率。这种可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”(designated initializer)。&lt;/p&gt;

&lt;p&gt;如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法。但是，我们仍然需要选定一个作为全能初始化方法，令其他初始化方法都来调用它。例如，NSDate类&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (instancetype)init NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;
- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;
- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面几个初始化方法中，&lt;code class=&quot;highlighter-rouge&quot;&gt;initWithTimeIntervalSinceReferenceDate:&lt;/code&gt;是全能初始化方法。只有在全能初始化方法中，才会存储内部数据。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//  ZKRRectangle.h

#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface ZKRRectangle : NSObject&amp;lt;NSCopying&amp;gt;

@property (nonatomic, assign, readonly) CGFloat width;
@property (nonatomic, assign, readonly) CGFloat height;

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;

@end

//  ZKRRectangle.m

#import &quot;ZKRRectangle.h&quot;

@implementation ZKRRectangle

- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    self = [super init];
    if (self) {
        _width = [[aDecoder decodeObjectForKey:@&quot;width&quot;] floatValue];
        _height = [[aDecoder decodeObjectForKey:@&quot;height&quot;] floatValue];
    }
    return self;
}

- (instancetype)init
{
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithWidth:height: instad.&quot; userInfo:nil];
    
    return [self initWithWidth:0 height:0];
}

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height
{
    self = [super init];
    if (self) {
        _width = width;
        _height = height;
    }
    return self;
}

@end

//  ZKRSquare.h

#import &quot;ZKRRectangle.h&quot;

@interface ZKRSquare : ZKRRectangle

- (instancetype)initWithDimension:(CGFloat)dimension;

@end

//  ZKRSquare.m

#import &quot;ZKRSquare.h&quot;

@implementation ZKRSquare

- (instancetype)init
{
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];
    
    return [self initWithDimension:0];
}

- (instancetype)initWithDimension:(CGFloat)dimension
{
    return [super initWithWidth:dimension height:dimension];
}

- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height
{
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@&quot;Must use initWithDimension: instad.&quot; userInfo:nil];
    CGFloat dimension = MIN(width, height);
    return [self initWithDimension:dimension];
}

@end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均调用此方法。&lt;/li&gt;
  &lt;li&gt;若全能方法于超类不同，则需要覆写超类中的对应方法。&lt;/li&gt;
  &lt;li&gt;如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nscopying协议&quot;&gt;NSCopying协议&lt;/h2&gt;

&lt;p&gt;使用对象时经常需要拷贝它。在Objective-C中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)copyWithZone:(nullable NSZone *)zone;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为什么会出现NSZone呢？因为以前开发程序时，会据此把内容分成不同的“区”(zone)，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”(default zone)。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。&lt;/p&gt;

&lt;p&gt;copy方法由NSObject实现，该方法只是以“默认区”为参数来调用&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;。我们总是想覆写copy方法，其实真正需要实现的是&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法。若想使某个类支持拷贝功能，只需声明该类遵从NSCopying协议，并实现其中的那个方法即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (id)copyWithZone:(NSZone *)zone
{
    ZKRRectangle *copy = [[[self class] allocWithZone:zone] initWithWidth:_width height:_height];
    return copy;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;说到copy方法，除了NSString这样的不可变类型的copy，与之类似的还有NSMutableString类的&lt;code class=&quot;highlighter-rouge&quot;&gt;mutableCopy&lt;/code&gt;方法。与&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法相对应的可变内容的copy方法&lt;code class=&quot;highlighter-rouge&quot;&gt;mutableCopyWithZone:&lt;/code&gt;方法来自于&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableCopying&lt;/code&gt;协议。如果你的类分为可变版本(mutable)与不可变版本(immutable)，那么就应该实现NSMutableCopying协议。若采用此模式，则在可变类中覆写&lt;code class=&quot;highlighter-rouge&quot;&gt;copyWithZone:&lt;/code&gt;方法时，不要返回可变的拷贝，而应该返回一份不可变的版本。无论当前实例是否可变，需要获取其可变版本的拷贝，均应调用mutableCopy方法；获取不可变版本的拷贝，则总应该通过copy方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-2.png?imageView/2/w/500&quot; alt=&quot;mutableCopy和copy类&quot; /&gt;&lt;/p&gt;

&lt;p&gt;深拷贝就是在拷贝对象自身时，将其底层数据也一并复制过去。
浅拷贝就是在拷贝对象时，只拷贝容器对象本身，而不复制其中数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-design-api-guide-3.png?imageView/2/w/400&quot; alt=&quot;深拷贝和浅拷贝比较&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 10 Jul 2017 06:32:33 +0800</pubDate>
      </item>
    
      <item>
        <title>从iOS的图片圆角想到渲染</title>
        <link>/pieces/2017/07/03/ios-corner-radius.html</link>
        <guid isPermaLink="true">/pieces/2017/07/03/ios-corner-radius.html</guid>
        <description>&lt;p&gt;圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。&lt;/p&gt;

&lt;p&gt;大家常见的圆角代码&lt;code class=&quot;highlighter-rouge&quot;&gt;x.layer.cornerRadius = xx; x.clipsToBounds = YES;&lt;/code&gt;这两行确实实现了圆角视觉效果。其实使用&lt;code class=&quot;highlighter-rouge&quot;&gt;x.layer.cornerRadius = xx;&lt;/code&gt;已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而&lt;code class=&quot;highlighter-rouge&quot;&gt;x.clipsToBounds = YES;&lt;/code&gt;带来的后果就是产生&lt;code class=&quot;highlighter-rouge&quot;&gt;离屏渲染&lt;/code&gt;。可以使用instruments中的CoreAnimation工具，打开&lt;code class=&quot;highlighter-rouge&quot;&gt;Color Offscren-Rednered Yellow&lt;/code&gt;选项，可见黄色区域部分即是离屏渲染部分。&lt;/p&gt;

&lt;p&gt;那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。&lt;/p&gt;

&lt;h2 id=&quot;什么是像素&quot;&gt;什么是像素&lt;/h2&gt;

&lt;p&gt;像素，为视频显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。&lt;/p&gt;

&lt;h2 id=&quot;显示机制&quot;&gt;显示机制&lt;/h2&gt;

&lt;p&gt;一个像素是如何绘制到屏幕上去的？有很多种方式将一些东西映射到显示屏上，他们需要调用不同的框架、许多功能和方法的结合体。这里我们大概看一下屏幕之后发生的事情。&lt;/p&gt;

&lt;p&gt;图像想显示到屏幕上使人肉眼可见都需借助像素的力量。它们密集的排布在手机屏幕上，将任何图形通过不同的色值表现出来。计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上，由图像转化为像素点的过程又可以称之为光栅化，就是从矢量的点线面的描述，变成像素的描述。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/display-screen.png?imageView/2/w/300&quot; alt=&quot;display screen&quot; /&gt;&lt;/p&gt;

&lt;p&gt;回溯历史，可以从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。&lt;/p&gt;

&lt;h3 id=&quot;关于卡顿的简单原理解释&quot;&gt;关于卡顿的简单原理解释&lt;/h3&gt;

&lt;p&gt;在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。&lt;/p&gt;

&lt;p&gt;CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。&lt;/p&gt;

&lt;h2 id=&quot;渲染机制&quot;&gt;渲染机制&lt;/h2&gt;

&lt;p&gt;当像素映射到屏幕上的时候，后台发生了很多事情。但一旦它们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhoneSE 的显示器上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在一些Retina屏幕上，这一数字将达到百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这就是一个很大的工作量。&lt;/p&gt;

&lt;p&gt;简单来说，iOS的显示机制大致如此：
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/pixels-software-stack.png&quot; alt=&quot;pixels software stack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它的并发本性让它能高效的将不同纹理合成起来。所以，开发中我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理。&lt;/p&gt;

&lt;p&gt;GPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使它们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.&lt;/p&gt;

&lt;p&gt;OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。&lt;/p&gt;

&lt;p&gt;OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。&lt;/p&gt;

&lt;p&gt;需要强调的是，GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，最终像素显示到屏幕上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/pixels-hardware.png&quot; alt=&quot;pixels hardware&quot; /&gt;&lt;/p&gt;

&lt;p&gt;正如上图显示，GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。&lt;/p&gt;

&lt;p&gt;另外一个问题就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这些看起来貌似微不足道，但是一些大型的纹理却会非常耗时。&lt;/p&gt;

&lt;p&gt;最终，CPU 开始运行程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。&lt;/p&gt;

&lt;p&gt;在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。&lt;/p&gt;

&lt;p&gt;每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成。&lt;/p&gt;

&lt;p&gt;如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。&lt;/p&gt;

&lt;p&gt;如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用公式来计算每一个像素：&lt;code class=&quot;highlighter-rouge&quot;&gt;R = S + D * ( 1 – Sa )&lt;/code&gt;
结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了它们的透明度。&lt;/p&gt;

&lt;p&gt;接着我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1。如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：&lt;code class=&quot;highlighter-rouge&quot;&gt;R = S&lt;/code&gt;
结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;                       0.5   0               0.5
R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0
                       0     1               0.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。&lt;/p&gt;

&lt;p&gt;记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。&lt;/p&gt;

&lt;h3 id=&quot;为何图片缩放会增加gpu工作量&quot;&gt;为何图片缩放会增加GPU工作量&lt;/h3&gt;

&lt;p&gt;当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。&lt;/p&gt;

&lt;p&gt;当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动，当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。&lt;/p&gt;

&lt;p&gt;在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。&lt;/p&gt;

&lt;p&gt;Core Animation 工具和模拟器有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Color Misaligned Images &lt;/code&gt;选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。&lt;/p&gt;

&lt;p&gt;关于iOS设备的一些尺寸限制可以看这里：&lt;a href=&quot;http://iosres.com/&quot;&gt;iOSRes&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;离屏渲染&quot;&gt;离屏渲染&lt;/h2&gt;

&lt;p&gt;On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。
Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。&lt;/p&gt;

&lt;p&gt;当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。&lt;/p&gt;

&lt;p&gt;离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并/渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。&lt;/p&gt;

&lt;h3 id=&quot;特殊的离屏渲染cpu渲染&quot;&gt;特殊的“离屏渲染”：CPU渲染&lt;/h3&gt;

&lt;p&gt;如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。
整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。&lt;/p&gt;

&lt;h3 id=&quot;离屏渲染的体现&quot;&gt;离屏渲染的体现&lt;/h3&gt;

&lt;p&gt;相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1 创建新缓冲区
要想进行离屏渲染，首先要创建一个新的缓冲区。&lt;/li&gt;
  &lt;li&gt;2 上下文切换
离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;触发离屏渲染&quot;&gt;触发离屏渲染&lt;/h3&gt;

&lt;p&gt;1、drawRect
2、layer.shouldRasterize = true;
3、有mask或者是阴影(layer.masksToBounds, layer.shadow*)；
 3.1) shouldRasterize（光栅化）
 3.2) masks（遮罩）
 3.3) shadows（阴影）
 3.4) edge antialiasing（抗锯齿）
 3.5) group opacity（不透明）
4、Text（UILabel, CATextLayer, Core Text, etc）…
注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会Offscreen Render，因为这些不需要加入Mask。&lt;/p&gt;

&lt;h2 id=&quot;圆角优化&quot;&gt;圆角优化&lt;/h2&gt;

&lt;p&gt;前面说了那么多，这里就给上实际可行方案。圆角的优化目前考虑两方面：一是，从图片入手，将图片切割成指定圆角样式。二是，使用贝塞尔曲线，利用CALayer层绘制指定圆角样式的mask遮盖View。&lt;/p&gt;

&lt;p&gt;UIImage切割：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);
CGContextRef context = UIGraphicsGetCurrentContext();
CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
CGContextScaleCTM(context, 1, -1);
CGContextTranslateCTM(context, 0, -rect.size.height);

CGFloat minSize = MIN(self.size.width, self.size.height);
if (borderWidth &amp;lt; minSize / 2.0) {
    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];
    CGContextSaveGState(context);
    [path addClip];
    CGContextDrawImage(context, rect, self.CGImage);
    CGContextRestoreGState(context);
}

UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
image = [image dd_imageByCornerRadius:radius borderedColor:borderColor borderWidth:borderWidth corners:corners];
UIGraphicsEndImageContext();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;图片绘制：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);
[self drawAtPoint:CGPointZero];
CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);
CGFloat strokeInset = borderWidth / 2.0;
CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);
UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];
path.lineWidth = borderWidth;
[borderColor setStroke];
[path stroke];
UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体源码可以转至github进行star &lt;a href=&quot;https://github.com/charsdavy/DDCornerRadius&quot;&gt;DDCornerRadius&lt;/a&gt; 欢迎issue。&lt;/p&gt;
</description>
        <pubDate>Mon, 03 Jul 2017 22:40:56 +0800</pubDate>
      </item>
    
      <item>
        <title>二叉树的那些使用</title>
        <link>/algorithm/2017/06/14/binary-tree-guide.html</link>
        <guid isPermaLink="true">/algorithm/2017/06/14/binary-tree-guide.html</guid>
        <description>&lt;p&gt;在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。&lt;/p&gt;

&lt;p&gt;二叉树的第i层至多拥有 2^(i-1) 个节点数；深度为k的二叉树至多总共有 2^(k+1) - 1 个节点数，而总计拥有节点数匹配的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。对任何一棵非空的二叉树T，如果其叶片(终端节点)数为n0，分支度为2的节点数为n2，则n0 = n2 + 1。&lt;/p&gt;

&lt;p&gt;与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。&lt;/p&gt;

&lt;p&gt;二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。&lt;/p&gt;

&lt;p&gt;相对于普通二叉树，还有一些特殊二叉树，它们诞生于特殊的场景需求。例如，二叉搜索树就是因搜索需求而诞生的一种特殊的树。&lt;/p&gt;

&lt;p&gt;具体可以参见
&lt;a href=&quot;/2017/06/10/binary-search-tree/&quot;&gt;《聊聊「二叉搜索树」的那些事儿》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文初衷是因为Homebrew 的作者&lt;a href=&quot;https://twitter.com/mxcl/status/608682016205344768&quot;&gt;@Max Howell&lt;/a&gt;的一条twitter&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;类型&quot;&gt;类型&lt;/h2&gt;

&lt;h3 id=&quot;1完全二叉树&quot;&gt;(1)完全二叉树&lt;/h3&gt;
&lt;p&gt;若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第h层有叶子节点，并且叶子节点都是从左到右依次排布，这就是完全二叉树。&lt;/p&gt;
&lt;h3 id=&quot;2满二叉树&quot;&gt;(2)满二叉树&lt;/h3&gt;
&lt;p&gt;除了叶节点外每一个节点都有左右子叶且叶子节点都处在最底层的二叉树。&lt;/p&gt;
&lt;h3 id=&quot;3平衡二叉树&quot;&gt;(3)平衡二叉树&lt;/h3&gt;
&lt;p&gt;平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。&lt;/p&gt;

&lt;h2 id=&quot;相关术语&quot;&gt;相关术语&lt;/h2&gt;
&lt;p&gt;树的节点：包含一个数据元素及若干指向子树的分支。&lt;/p&gt;

&lt;p&gt;孩子节点：节点的子树的根称为该节点的孩子。&lt;/p&gt;

&lt;p&gt;双亲节点：B 节点是A 节点的孩子，则A节点是B 节点的双亲。&lt;/p&gt;

&lt;p&gt;兄弟节点：同一双亲的孩子节点；&lt;/p&gt;

&lt;p&gt;堂兄节点：同一层上节点。&lt;/p&gt;

&lt;p&gt;祖先节点: 从根到该节点的所经分支上的所有节点。&lt;/p&gt;

&lt;p&gt;子孙节点：以某节点为根的子树中任一节点都称为该节点的子孙。&lt;/p&gt;

&lt;p&gt;节点层：根节点的层定义为1；根的孩子为第二层节点，依此类推。&lt;/p&gt;

&lt;p&gt;树的深度：树中最大的节点层。&lt;/p&gt;

&lt;p&gt;节点的度：节点子树的个数。&lt;/p&gt;

&lt;p&gt;树的度： 树中最大的节点度。&lt;/p&gt;

&lt;p&gt;叶子节点：也叫终端节点，是度为 0 的节点。&lt;/p&gt;

&lt;p&gt;分支节点：度不为0的节点。&lt;/p&gt;

&lt;p&gt;有序树：子树有序的树，如：家族树。&lt;/p&gt;

&lt;p&gt;无序树：不考虑子树的顺序。&lt;/p&gt;

&lt;h2 id=&quot;树的结构&quot;&gt;树的结构&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

/** 二叉树节点 */
@interface DDBinaryTreeNode : NSObject

/** 值 */
@property (nonatomic, assign) NSInteger value;
/** 左节点 */
@property (nonatomic, strong) DDBinaryTreeNode *leftNode;
/** 右节点 */
@property (nonatomic, strong) DDBinaryTreeNode *rightNode;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;树的遍历&quot;&gt;树的遍历&lt;/h2&gt;

&lt;p&gt;遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有节点，使每一个节点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示。&lt;/p&gt;

&lt;p&gt;设L、D、R分别表示遍历左子树、访问根节点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先序遍历），LDR（称为中序遍历），LRD （称为后序遍历）。&lt;/p&gt;

&lt;h3 id=&quot;先序遍历&quot;&gt;先序遍历&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)preOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    
    if (handler) {
        handler(rootNode);
    }
    [self preOrderTraverseTree:rootNode.leftNode handler:handler];
    [self preOrderTraverseTree:rootNode.rightNode handler:handler];
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;中序遍历&quot;&gt;中序遍历&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)inOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void (^)(DDBinaryTreeNode *treeNode))handler
{
    if (!rootNode) {
        return;
    }
    [self inOrderTraverseTree:rootNode.leftNode handler:handler];
    if (handler) {
        handler(rootNode);
    }
    [self inOrderTraverseTree:rootNode.rightNode handler:handler];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;后序遍历&quot;&gt;后序遍历&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)postOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    [self postOrderTraverseTree:rootNode.leftNode handler:handler];
    [self postOrderTraverseTree:rootNode.rightNode handler:handler];
    if (handler) {
        handler(rootNode);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;广度优先遍历breadth-first-search&quot;&gt;广度优先遍历(Breadth First Search)&lt;/h3&gt;

&lt;p&gt;从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。
按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)levelTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {
    if (!rootNode) {
        return;
    }
    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列
    [queueArray addObject:rootNode]; //压入根节点
    while (queueArray.count &amp;gt; 0) {
        DDBinaryTreeNode *node = [queueArray firstObject];
        if (handler) {
            handler(node);
        }
        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则
        if (node.leftNode) {
            [queueArray addObject:node.leftNode]; //压入左节点
        }
        if (node.rightNode) {
            [queueArray addObject:node.rightNode]; //压入右节点
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;深度优先遍历depth-first-search&quot;&gt;深度优先遍历(Depth First Search)&lt;/h3&gt;

&lt;p&gt;DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。
如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)depthTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler
{
    if (!rootNode) {
        return;
    }
    
    if (handler) {
        handler(rootNode);
    }
    
    [self depthTraverseTree:rootNode.leftNode handler:handler];
    [self depthTraverseTree:rootNode.rightNode handler:handler];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;树的翻转&quot;&gt;树的翻转&lt;/h2&gt;

&lt;p&gt;翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)invertBinaryTree:(DDBinaryTreeNode *)rootNode {
    if (!rootNode) {
        return nil;
    }
    if (!rootNode.leftNode &amp;amp;&amp;amp; !rootNode.rightNode) {
        return rootNode;
    }
    [self invertBinaryTree:rootNode.leftNode];
    [self invertBinaryTree:rootNode.rightNode];
    DDBinaryTreeNode *tempNode = rootNode.leftNode;
    rootNode.leftNode = rootNode.rightNode;
    rootNode.rightNode = tempNode;
    return rootNode;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;树的查找&quot;&gt;树的查找&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode
{
    if (!rootNode) {
        return nil;
    }
    
    if (rootNode.value == value) {
        return rootNode;
    }
    
    if (value &amp;lt; rootNode.value) {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];
    } else {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相关链接：
&lt;a href=&quot;http://www.cocoachina.com/programmer/20151015/13687.html&quot;&gt;《百度的校园招聘面试经历》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.devtang.com/2015/06/16/talk-about-tech-interview/&quot;&gt;《你会翻转二叉树吗》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 14 Jun 2017 07:30:22 +0800</pubDate>
      </item>
    
      <item>
        <title>聊聊「二叉搜索树」的那些事儿</title>
        <link>/algorithm/2017/06/10/binary-search-tree.html</link>
        <guid isPermaLink="true">/algorithm/2017/06/10/binary-search-tree.html</guid>
        <description>&lt;p&gt;二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。“中序遍历”可以让节点有序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree.png&quot; alt=&quot;binary search tree&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;

&lt;p&gt;二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的节点都是二叉排序树上新的叶子节点，在进行插入操作时，不必移动其它节点，只需改动某个节点的指针，由空变为非空即可。搜索，插入，删除的复杂度等于树高，O(log(n))。&lt;/p&gt;

&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;

&lt;h3 id=&quot;树节点&quot;&gt;树节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

/** 二叉树节点 */
@interface DDBinaryTreeNode : NSObject

/** 值 */
@property (nonatomic, assign) NSInteger value;
/** 左节点 */
@property (nonatomic, strong) DDBinaryTreeNode *leftNode;
/** 右节点 */
@property (nonatomic, strong) DDBinaryTreeNode *rightNode;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建&quot;&gt;创建&lt;/h3&gt;
&lt;p&gt;二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为在查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;

@class DDBinaryTreeNode;

@interface DDBinarySearchTreeHandler : NSObject

/**
 *  创建二叉排序树
 *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值
 *
 *  @param values 数组
 *
 *  @return 二叉树根节点
 */
+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values;

/**
 *  向二叉排序树节点添加一个节点
 *
 *  @param treeNode 根节点
 *  @param value	值
 *
 *  @return 根节点
 */
+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value;

/**
 *  二叉搜索树中某个值的节点
 *
 *  @param value	值
 *  @param rootNode 树根节点
 *
 *  @return 节点
 */
+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values
{
    DDBinaryTreeNode *root = nil;
    for (NSInteger i = 0; i &amp;lt; values.count; i++) {
        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];
        root = [DDBinarySearchTreeHandler addTreeNode:root value:value];
    }
    return root;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加节点&quot;&gt;添加节点&lt;/h3&gt;

&lt;p&gt;根据查找树的性质我们可以很简单的写出添加的代码，一个一个的比较，注意每插入的一个总是叶子节点。再进行调整。最终形成的效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-01.png&quot; alt=&quot;添加节点&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value
{
    if (!treeNode) {
        treeNode = [[DDBinaryTreeNode alloc] init];
        treeNode.value = value;
        NSLog(@&quot;node:%td&quot;, value);
    } else if (value &amp;lt;= treeNode.value) {
        NSLog(@&quot;to left&quot;);
        //值小于根节点，则插入到左子树
        treeNode.leftNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.leftNode value:value];
    } else {
        NSLog(@&quot;to right&quot;);
        //值大于根节点，则插入到右子树
        treeNode.rightNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.rightNode value:value];
    }
    return treeNode;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查找节点&quot;&gt;查找节点&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode
{
    if (!rootNode) {
        return nil;
    }
    
    if (rootNode.value == value) {
        return rootNode;
    }
    
    if (value &amp;lt; rootNode.value) {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];
    } else {
        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除节点&quot;&gt;删除节点&lt;/h3&gt;

&lt;p&gt;对于树来说，删除是最复杂的，主要需要考虑4种情况：叶子节点，只有左子树，只有右子树和左右子树都有。&lt;/p&gt;

&lt;h4 id=&quot;叶子节点&quot;&gt;叶子节点&lt;/h4&gt;

&lt;p&gt;删除的节点没有左子树也没有右子树，也就是删除的节点为叶子节点。这种情况下我们有可以细分为两类，一种是该叶子节点就是二叉排序树的根节点，也就是二叉排序树中只有一个节点的情况。只需要将root指针置为空即可。再一种情况是删除的叶子节点有父节点，直接将父节点连接该删除节点的指针置空即可。&lt;/p&gt;

&lt;h4 id=&quot;只有一个子节点&quot;&gt;只有一个子节点&lt;/h4&gt;

&lt;p&gt;如果删除的节点有左子树那就把左子树顶上去，如果有右子树就把右子树顶上去即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-03.png?v=20170612&quot; alt=&quot;左子树节点&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左右子树都有&quot;&gt;左右子树都有&lt;/h4&gt;

&lt;p&gt;首先可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-04.png?v=20170612&quot; alt=&quot;双孩子节点1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么二叉树操作同样也是一样，我们根据”中序遍历“找到要删除节点的后一个节点，然后顶上去就行了，原理跟”数组”一样一样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/binary-search-tree-05.png?v=20170612.png&quot; alt=&quot;双孩子节点2&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (void)deleteTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode
{
    DDBinaryTreeNode *parent = rootNode;
    DDBinaryTreeNode *current = rootNode;
    // 记录被找到的节点是父节点的左子节点还是右子节点
    BOOL isLeftChild = false;
    // 循环直到找到目标节点的位置,否则返回
    while (current.value != value) {
        parent = current;
        if (current.value &amp;gt; value) {
            isLeftChild = true;
            current = current.leftNode;
        } else {
            isLeftChild = false;
            current = current.rightNode;
        }
        if (current == nil) {
            return;
        }
    }
    // 如果待删除的节点没有任何子节点
    // 直接将该节点的原本指向该节点的指针设置为nil
    if (current.leftNode == nil &amp;amp;&amp;amp; current.rightNode == nil) {
        if (current == rootNode) {
            rootNode = nil;
        }
        if (isLeftChild == true) {
            parent.leftNode = nil;
        } else {
            parent.rightNode = nil;
        }
    }
    // 如果待删除的节点有一个子节点,且其为左子节点
    else if (current.rightNode == nil) {
        // 判断当前节点是否为根节点
        if (current == rootNode) {
            rootNode = current.leftNode;
        } else if (isLeftChild) {
            // 挂载到父节点的左子树
            parent.leftNode = current.leftNode;
        } else {
            // 挂载到父节点的右子树
            parent.rightNode = current.leftNode;
        }
    } else if (current.leftNode == nil) {
        if (current == rootNode) {
            rootNode = current.rightNode;
        } else if (isLeftChild) {
            parent.leftNode = current.rightNode;
        } else {
            parent.rightNode = current.rightNode;
        }
    }
    // 如果待删除的节点有两个子节点
    else if (current.leftNode != nil &amp;amp;&amp;amp; current.rightNode != nil) {
        // 寻找右子树中的最小值
        DDBinaryTreeNode *successor = [DDBinarySearchTreeHandler successor:current];
        if (current == rootNode) {
            rootNode = successor;
        } else if (isLeftChild) {
            parent.leftNode = successor;
        } else {
            parent.rightNode = successor;
        }
        successor.leftNode = current.leftNode;
    }
}

/**
 在树中查找最合适的节点
 */
+ (DDBinaryTreeNode *)successor:(DDBinaryTreeNode *)node {
    DDBinaryTreeNode *successsor = nil;
    DDBinaryTreeNode *successsorParent = nil;
    DDBinaryTreeNode *current = node.rightNode;
    while (current != nil) {
        successsorParent = successsor;
        successsor = current;
        current = current.leftNode;
    }
    if (successsor != node.rightNode) {
        successsorParent.leftNode = successsor.rightNode;
        successsor.rightNode = node.rightNode;
    }
    return successsor;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sat, 10 Jun 2017 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>初探 TensorFlow</title>
        <link>/ml/2017/06/08/tensorflow-primer-guide.html</link>
        <guid isPermaLink="true">/ml/2017/06/08/tensorflow-primer-guide.html</guid>
        <description>&lt;p&gt;TensorFlow 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/tensors_flowing.gif&quot; alt=&quot;tensors_flowing&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;什么是数据流图data-flow-graph&quot;&gt;什么是数据流图（Data Flow Graph）&lt;/h2&gt;
&lt;p&gt;数据流图用“结点”(nodes)和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入(feed in)的起点/输出(push out)的终点，或者是读取/写入持久变量(persistent variable)的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”(tensor)。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。&lt;/p&gt;

&lt;h2 id=&quot;tensorflow的特征&quot;&gt;TensorFlow的特征&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;高度的灵活性&lt;/li&gt;
  &lt;li&gt;真正的可移植性（Portability）&lt;/li&gt;
  &lt;li&gt;将科研和产品联系在一起&lt;/li&gt;
  &lt;li&gt;自动求微分&lt;/li&gt;
  &lt;li&gt;多语言支持&lt;/li&gt;
  &lt;li&gt;性能最优化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;下载与安装&quot;&gt;下载与安装&lt;/h2&gt;

&lt;h3 id=&quot;源码安装&quot;&gt;源码安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# --recurse-submodules 参数是必须的, 用于获取 TesorFlow 依赖的 protobuf 库
$ git clone --recurse-submodules https://github.com/tensorflow/tensorflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;linux-安装&quot;&gt;Linux 安装&lt;/h4&gt;

&lt;h5 id=&quot;安装-bazel&quot;&gt;安装 Bazel&lt;/h5&gt;

&lt;p&gt;首先依照 &lt;a href=&quot;https://bazel.build/versions/master/docs/install.html&quot;&gt;教程&lt;/a&gt; 安装 Bazel 的依赖. 然后使用下列命令下载和编译 Bazel 的源码:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/bazelbuild/bazel.git
$ cd bazel
$ git checkout tags/0.1.0
$ ./compile.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面命令中拉取的代码标签为 0.1.0, 兼容 Tensorflow 目前版本. bazel 的HEAD 版本 (即最新版本) 在这里可能不稳定.&lt;/p&gt;

&lt;p&gt;将执行路径 &lt;code class=&quot;highlighter-rouge&quot;&gt;output/bazel&lt;/code&gt; 添加到 &lt;code class=&quot;highlighter-rouge&quot;&gt;$PATH&lt;/code&gt; 环境变量中.&lt;/p&gt;

&lt;h5 id=&quot;安装其他依赖&quot;&gt;安装其他依赖&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install python-numpy swig python-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mac-os-x-安装&quot;&gt;Mac OS X 安装&lt;/h4&gt;

&lt;p&gt;Mac 和 Linux 需要的软件依赖完全一样, 但是安装过程区别很大. 以下链接用于帮助你 在 Mac OS X 上安装这些依赖:&lt;/p&gt;

&lt;h5 id=&quot;bazel&quot;&gt;Bazel&lt;/h5&gt;

&lt;p&gt;参见&lt;a href=&quot;https://bazel.build/versions/master/docs/install.html&quot;&gt;网页&lt;/a&gt;的 Mac OS X 安装指南.&lt;/p&gt;

&lt;h5 id=&quot;swig&quot;&gt;SWIG&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;http://www.swig.org/Doc3.0/Preface.html#Preface_osx_installation&quot;&gt;Mac OS X 安装教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;注意: 你需要安装&lt;a href=&quot;ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/&quot;&gt;PCRE&lt;/a&gt;, 而不是 PCRE2.&lt;/p&gt;

&lt;h5 id=&quot;numpy&quot;&gt;Numpy&lt;/h5&gt;

&lt;p&gt;参见&lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/install.html&quot;&gt;安装教程&lt;/a&gt;.&lt;/p&gt;

&lt;h5 id=&quot;创建-pip-包并安装&quot;&gt;创建 pip 包并安装&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bazel build -c opt //tensorflow/tools/pip_package:build_pip_package

$ bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg

# .whl 文件的实际名字与你所使用的平台有关
$ pip install /tmp/tensorflow_pkg/tensorflow-0.5.0-cp27-none-linux_x86_64.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;二进制安装&quot;&gt;二进制安装&lt;/h3&gt;

&lt;p&gt;TensorFlow Python API 依赖 Python 2.7 版本.&lt;/p&gt;

&lt;p&gt;在 Linux 和 Mac 下最简单的安装方式, 是使用 &lt;a href=&quot;https://pypi.python.org/pypi/pip&quot;&gt;pip&lt;/a&gt; 安装.&lt;/p&gt;

&lt;p&gt;为了简化安装步骤, 建议使用 virtualenv, 具体安装方法在后文具体说明.&lt;/p&gt;

&lt;h4 id=&quot;ubuntulinux&quot;&gt;Ubuntu/Linux&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 仅使用 CPU 的版本
$ pip install https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl

# 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)
$ pip install https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;mac-os-x&quot;&gt;Mac OS X&lt;/h4&gt;

&lt;p&gt;在 OS X 系统上, 推荐先安装 &lt;a href=&quot;https://brew.sh/&quot;&gt;homebrew&lt;/a&gt;, 然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install python&lt;/code&gt;, 以便能够使用 homebrew 中的 Python 安装 TensorFlow. 另外一种推荐的方式是在 virtualenv 中安装 TensorFlow.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 当前版本只支持 CPU
$ pip install https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;基于-virtualenv-的安装&quot;&gt;基于 VirtualEnv 的安装&lt;/h4&gt;

&lt;p&gt;推荐使用 &lt;a href=&quot;https://pypi.python.org/pypi/virtualenv&quot;&gt;virtualenv&lt;/a&gt; 创建一个隔离的容器, 来安装 TensorFlow. 这是可选的, 但是这样做能使排查安装问题变得更容易.&lt;/p&gt;

&lt;p&gt;首先, 安装所有必备工具:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 在 Linux 上:
$ sudo apt-get install python-pip python-dev python-virtualenv

# 在 Mac 上:
$ sudo easy_install pip  # 如果还没有安装 pip
$ sudo pip install --upgrade virtualenv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接下来, 建立一个全新的 virtualenv 环境. 为了将环境建在 ~/tensorflow 目录下, 执行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ virtualenv --system-site-packages ~/tensorflow
$ cd ~/tensorflow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后, 激活 virtualenv:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source bin/activate  # 如果使用 bash
$ source bin/activate.csh  # 如果使用 csh
(tensorflow)$  # 终端提示符应该发生变化
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 virtualenv 内, 安装 TensorFlow:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(tensorflow)$ pip install --upgrade &amp;lt;$url_to_binary.whl&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;接下来, 使用类似命令运行 TensorFlow 程序:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(tensorflow)$ cd tensorflow/models/image/mnist
(tensorflow)$ python convolutional.py

# 当使用完 TensorFlow
(tensorflow)$ deactivate  # 停用 virtualenv

$  # 你的命令提示符会恢复原样
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;运行-tensorflow&quot;&gt;运行 TensorFlow&lt;/h2&gt;

&lt;p&gt;打开一个 python 终端:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python

&amp;gt;&amp;gt;&amp;gt; import tensorflow as tf
&amp;gt;&amp;gt;&amp;gt; hello = tf.constant('Hello, TensorFlow!')
&amp;gt;&amp;gt;&amp;gt; sess = tf.Session()
&amp;gt;&amp;gt;&amp;gt; print sess.run(hello)
Hello, TensorFlow!
&amp;gt;&amp;gt;&amp;gt; a = tf.constant(10)
&amp;gt;&amp;gt;&amp;gt; b = tf.constant(32)
&amp;gt;&amp;gt;&amp;gt; print sess.run(a+b)
42
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 08 Jun 2017 07:45:11 +0800</pubDate>
      </item>
    
      <item>
        <title>拆解 MySQL 的高阶使用与概念</title>
        <link>/web/2017/05/29/mysql-advanced-study.html</link>
        <guid isPermaLink="true">/web/2017/05/29/mysql-advanced-study.html</guid>
        <description>&lt;p&gt;前面我们主要分享了MySQL中的常见知识与使用。这里我们主要分享一下MySQL中的高阶使用，主要包括：函数、存储过程和存储引擎。&lt;/p&gt;

&lt;p&gt;对于MySQL中的基础知识，可以参见&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/2017/05/16/mysql-study/&quot;&gt;《与 MySQL 的零距离接触》&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-函数&quot;&gt;1 函数&lt;/h1&gt;

&lt;p&gt;函数可以返回任意类型的值，也可以接收这些类型的参数。&lt;/p&gt;

&lt;h2 id=&quot;字符函数&quot;&gt;字符函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CONCAT()&lt;/td&gt;
      &lt;td&gt;字符连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CONCAT_WS()&lt;/td&gt;
      &lt;td&gt;使用指定的分隔符进行字符连接&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FORMAT()&lt;/td&gt;
      &lt;td&gt;数字格式化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LOWER()&lt;/td&gt;
      &lt;td&gt;转换成小写字母&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UPPER()&lt;/td&gt;
      &lt;td&gt;转换成大写字母&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LEFT()&lt;/td&gt;
      &lt;td&gt;获取左侧字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RIGHT()&lt;/td&gt;
      &lt;td&gt;获取右侧字符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LENGTH()&lt;/td&gt;
      &lt;td&gt;获取字符串长度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LTRIM()&lt;/td&gt;
      &lt;td&gt;删除前导空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RTRIM()&lt;/td&gt;
      &lt;td&gt;删除后续空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TRIM()&lt;/td&gt;
      &lt;td&gt;删除前导和后续空格&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUBSTRING()&lt;/td&gt;
      &lt;td&gt;字符串截取&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[NOT] LIKE&lt;/td&gt;
      &lt;td&gt;模式匹配&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;REPLACE()&lt;/td&gt;
      &lt;td&gt;字符串替换&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;函数可以嵌套使用。
&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;（百分号）：代表任意个字符。
&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;（下划线）：代表任意一个字符。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 删除前导'?'符号
SELECT TRIM(LEADING '?' FROM '??MySQL???');
# 删除后续'?'符号
SELECT TRIM(TRAILING '?' FROM '??MySQL???');
# 删除前后'?'符号
SELECT TRIM(BOTH '?' FROM '??My??SQL???');
# 将'?'符号替换成'!'符号
SELECT REPLACE('??My??SQL???', '?', '!');
# 从中'MySQL'第1个开始，截取2个字符
SELECT SUBSTRING('MySQL', 1, 2);
# 从中'MySQL'截取最后1个字符
SELECT SUBSTRING('MySQL', -1);
# 从中'MySQL'第2个开始，截取至结尾
SELECT SUBSTRING('MySQL', 2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;数值运算符函数&quot;&gt;数值运算符函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CEIL()&lt;/td&gt;
      &lt;td&gt;进一取整&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DIV&lt;/td&gt;
      &lt;td&gt;整数除法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FLOOR()&lt;/td&gt;
      &lt;td&gt;舍一取整&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MOD&lt;/td&gt;
      &lt;td&gt;取余数（取模）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POWER()&lt;/td&gt;
      &lt;td&gt;幂运算&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ROUND()&lt;/td&gt;
      &lt;td&gt;四舍五入&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TRUNCATE()&lt;/td&gt;
      &lt;td&gt;数字截取&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;比较运算符函数&quot;&gt;比较运算符函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[NOT]BETWEEN…AND..&lt;/td&gt;
      &lt;td&gt;[不]在范围之内&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[NOT]IN()&lt;/td&gt;
      &lt;td&gt;[不]在列出值范围内&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IS[NOT]NULL&lt;/td&gt;
      &lt;td&gt;[不]为空&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;日期时间函数&quot;&gt;日期时间函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;NOW()&lt;/td&gt;
      &lt;td&gt;当前日期和时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CURDATE()&lt;/td&gt;
      &lt;td&gt;当前日期&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CURTIME()&lt;/td&gt;
      &lt;td&gt;当前时间&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE_ADD()&lt;/td&gt;
      &lt;td&gt;日期变化&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATEDIFF()&lt;/td&gt;
      &lt;td&gt;日期差值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE_FORMAT()&lt;/td&gt;
      &lt;td&gt;日期格式化&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 时间增加1年
SELECT DATE_ADD('2016-05-28', INTERVAL 365 DAY);
# 时间减少1年
SELECT DATE_ADD('2016-05-28', INTERVAL -365 DAY);
# 时间增加3周
SELECT DATE_ADD('2016-05-28', INTERVAL 3 WEEK);
# 日期格式化
SELECT DATE_FORMAT('2016-05-28', '%m/%d/%Y');
# 更多时间格式可以前往MySQL官网查看手册
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;信息函数&quot;&gt;信息函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CONNECTION_ID()&lt;/td&gt;
      &lt;td&gt;连接ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATEBASE()&lt;/td&gt;
      &lt;td&gt;当前数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LAST_INSERT_ID()&lt;/td&gt;
      &lt;td&gt;最后插入记录的ID号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;USER()&lt;/td&gt;
      &lt;td&gt;当前用户&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VERSION()&lt;/td&gt;
      &lt;td&gt;版本信息&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;聚合函数&quot;&gt;聚合函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AVG()&lt;/td&gt;
      &lt;td&gt;平均值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;COUNT()&lt;/td&gt;
      &lt;td&gt;计数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MAX()&lt;/td&gt;
      &lt;td&gt;最大值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MIN()&lt;/td&gt;
      &lt;td&gt;最小值&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SUM()&lt;/td&gt;
      &lt;td&gt;求和&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;加密函数&quot;&gt;加密函数&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;函数名称&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MD5()&lt;/td&gt;
      &lt;td&gt;信息摘要算法&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PASSWORD()&lt;/td&gt;
      &lt;td&gt;密码算法&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;自定义函数&quot;&gt;自定义函数&lt;/h2&gt;

&lt;p&gt;用户自定义函数（user-defined function，UDF）是一种对MySQL扩展的途径，其用法与内置函数相同。UDF是对MySQL扩展的一种途径。&lt;/p&gt;

&lt;h3 id=&quot;必要条件&quot;&gt;必要条件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;参数：可以有零个或多个&lt;/li&gt;
  &lt;li&gt;返回值：只能有一个&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参数和返回值没有必然的联系。&lt;/p&gt;

&lt;h3 id=&quot;创建自定义函数&quot;&gt;创建自定义函数&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE FUNCTION function_name RETURNS {STRING|INTEGER|REAL|DECIMAL} routine_body&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;函数体routine_body&quot;&gt;函数体（routine_body）&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;函数体由合法的SQL语句构成；&lt;/li&gt;
  &lt;li&gt;函数体可以是简单的SELECT或INSERT语句；&lt;/li&gt;
  &lt;li&gt;函数体如果为复合结构则使用BEGIN…END语句；&lt;/li&gt;
  &lt;li&gt;复合结构可以包含声明，循环，控制结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 不带参数
CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');

# 带参数
CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) RETURNS FLOAT(10, 2) UNSIGNED RETURN (num1 + num2) / 2;

# 具有复合结构函数体
# 可能需要使用DELIMITER命令修改分隔符
CREATE FUNCTION f3(username VARCHAR(20)) RETURNS INT UNSIGNED 
BEGIN 
INSERT test(username) VALUES(username);
RETURN LAST_INSERT_ID();
END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;2-存储过程&quot;&gt;2 存储过程&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-22.png&quot; alt=&quot;命令执行流程&quot; /&gt;
存储过程是SQL语句和控制语句的预编译集合，以一个名称存储作为一个单元处理。可以由用户调用执行，允许用户声明变量以及进行流程控制。存储过程可以接收输入类型的参数，也可以接收输出类型的参数，并可以存在多个返回值。执行效率比单一的SQL语句高。&lt;/p&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;增强SQL语句的功能和灵活性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在存储过程中可以写控制语句具有很强的灵活性，可以完成复杂的判断及较复杂的运算。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实现较快的执行速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果某一操作包含了大量的SQL语句，那么这些SQL语句都将被MySQL引擎执行语法分析、编译、执行，所以效率相对过低。而存储过程是预编译的，当客户端第一次调用存储过程时，MySQL的引擎将对它进行语法分析、编译等操作，然后把这个编译的结果存储到内存中，所以说第一次使用的时候效率和以前是相同的。但是以后客户端再次调用这个存储过程时，直接从内存中执行，所以说效率比较高，速度比较快。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;减少网络流量&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果通过客户端每一个单独发送SQL语句让服务器来执行，那么通过http协议来提交的数据量相对来说较大。&lt;/p&gt;

&lt;h2 id=&quot;创建&quot;&gt;创建&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE [DEFINER = {user|CURRENT_USER}] PROCEDURE sp_name ([proc_parameter[, ...]]) [characteristic ...] routine_body
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proc_parameter &lt;/code&gt;:
&lt;code class=&quot;highlighter-rouge&quot;&gt;[IN | OUT | INOUT] param_name type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数：
&lt;code class=&quot;highlighter-rouge&quot;&gt;IN&lt;/code&gt;，表示该参数的值必须在调用存储过程时指定。
&lt;code class=&quot;highlighter-rouge&quot;&gt;OUT&lt;/code&gt;，表示该参数值可以被存储过程改变，并且可以返回。
&lt;code class=&quot;highlighter-rouge&quot;&gt;INOUT&lt;/code&gt;，表示该参数的调用时指定，并且可以被改变和返回。&lt;/p&gt;

&lt;p&gt;特性：
&lt;code class=&quot;highlighter-rouge&quot;&gt;COMMENT&lt;/code&gt;注释
&lt;code class=&quot;highlighter-rouge&quot;&gt;CONTAINS SQL&lt;/code&gt;包含SQL语句，但不包含读或写数据的语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;NO SQL&lt;/code&gt;不包含SQL语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;READS SQL DATA&lt;/code&gt;包含读写数据的语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;MODIFIES SQL DATA&lt;/code&gt;包含写数据的语句。
&lt;code class=&quot;highlighter-rouge&quot;&gt;SQL SECURITY {DEFINER | INVOKER}&lt;/code&gt;指明谁有权限来执行。&lt;/p&gt;

&lt;h2 id=&quot;过程体&quot;&gt;过程体&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;过程体由合法的SQL语句构成；&lt;/li&gt;
  &lt;li&gt;过程体可以是任意SQL语句；
不能通过存储过程来创建数据表、数据库。可以通过存储过程对数据进行增、删、改、查和多表连接操作。&lt;/li&gt;
  &lt;li&gt;过程体如果为复合结构则使用BEGIN…END语句；&lt;/li&gt;
  &lt;li&gt;复合结构中可以包含声明、循环、控制结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;调用&quot;&gt;调用&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CALL sp_name ([parameter[, ...]])
CALL sp_name[()]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;删除&quot;&gt;删除&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP PROCEDURE [IF EXISTS] sp_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;修改&quot;&gt;修改&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER PROCEDURE sp_name [characteristic ...] COMMENT 'string'
| {CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}
| SQL SECURITY {DEFINER | INVOKER}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;存储过程与自定义函数的区别&quot;&gt;存储过程与自定义函数的区别&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;存储过程实现的功能要复杂一些，而函数的针对性更强。&lt;/li&gt;
  &lt;li&gt;存储过程可以返回多个值，函数只能有一个返回值。&lt;/li&gt;
  &lt;li&gt;存储过程一般独立执行，函数可以作为其他SQL语句的组成部分来实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 创建不带参数的存储过程
CREATE PROCEDURE sp1() SELECT VERSION();

# 创建带有IN类型参数的存储过程(users为数据表名)
# 参数的名字不能和数据表中的记录名字一样
CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)
BEGIN
DELETE FROM users WHERE id = p_id;
END

# 创建带有IN和OUT类型参数的存储过程(users为数据表名)
CREATE PROCEDURE removeUserAndReturnUserNumsById(IN p_id INT UNSIGNED, OUT userNums INT UNSIGNED)
BEGIN
DELETE FROM users WHERE id = p_id;
SELECT COUNT(id) FROM users INTO userNums;
END

# 创建带有多个OUT类型参数的存储过程(users为数据表名)
CREATE PROCEDURE removeUserAndReturnInfosByAge(IN p_age SMALLINT UNSIGNED, OUT delUser SMALLINT UNSIGNED,  OUT userNums SMALLINT UNSIGNED)
BEGIN
DELETE FROM users WHERE age = p_age;
SELECT ROW_COUNT INTO delUser;
SELECT COUNT(id) FROM users INTO userNums;
END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-存储引擎&quot;&gt;3 存储引擎&lt;/h1&gt;

&lt;p&gt;MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。
每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;锁
共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化。
排他锁（写锁）：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;锁颗粒
表锁：是一种开销最小的锁策略。
行锁：是一种开销最大的锁策略。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;并发控制
当多个连接记录进行修改时保证数据的一致性和完整性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;事务
事务用于保证数据库的完整性。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例：用户银行转账
&lt;code class=&quot;highlighter-rouge&quot;&gt;用户A&lt;/code&gt; 转账200元 &lt;code class=&quot;highlighter-rouge&quot;&gt;用户B&lt;/code&gt;
实现步骤：
1）从当前账户减掉200元（账户余额大于等于200元）。
2）在对方账户增加200元。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务特性：&lt;/strong&gt;
1）原子性（atomicity）
2）一致性（consistency）
3）隔离性（isolation）
4）持久性（durability）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;外键
是保证数据一致性的策略。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;索引
是对数据表中一列或多列的值进行排序的一种结构。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;类型&quot;&gt;类型&lt;/h2&gt;

&lt;p&gt;MySQL主要支持以下几种引擎类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MyISAM&lt;/li&gt;
  &lt;li&gt;InnoDB&lt;/li&gt;
  &lt;li&gt;Memory&lt;/li&gt;
  &lt;li&gt;CSV&lt;/li&gt;
  &lt;li&gt;Archive&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;各类存储引擎特点&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;特点&lt;/th&gt;
      &lt;th&gt;MyISAM&lt;/th&gt;
      &lt;th&gt;InnoDB&lt;/th&gt;
      &lt;th&gt;Memory&lt;/th&gt;
      &lt;th&gt;Archive&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;存储限制&lt;/td&gt;
      &lt;td&gt;256TB&lt;/td&gt;
      &lt;td&gt;64TB&lt;/td&gt;
      &lt;td&gt;有&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;事务安全&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持索引&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;锁颗粒&lt;/td&gt;
      &lt;td&gt;表锁&lt;/td&gt;
      &lt;td&gt;行锁&lt;/td&gt;
      &lt;td&gt;表锁&lt;/td&gt;
      &lt;td&gt;行锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;数据压缩&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;支持外键&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
      &lt;td&gt;-&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;CSV:实际上是由逗号分隔的数据引擎，在数据库子目录为每一个表创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.csv&lt;/code&gt;的文件，这是一种普通的文本文件，每一个数据行占用一个文本行。不支持索引。&lt;/p&gt;

&lt;p&gt;BlackHole：黑洞引擎，写入的数据都会消失，一般用于做数据复制的中继。&lt;/p&gt;

&lt;p&gt;MyISAM：适用于事务的处理不多的情况。&lt;/p&gt;

&lt;p&gt;InnoDB：适用于事务处理比较多，需要有外键支持的情况。&lt;/p&gt;

&lt;p&gt;索引分类：普通索引、唯一索引、全文索引、btree索引、hash索引…&lt;/p&gt;

&lt;h2 id=&quot;修改存储引擎&quot;&gt;修改存储引擎&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;通过修改MySQL配置文件
&lt;code class=&quot;highlighter-rouge&quot;&gt;default-storage-engine=engine_name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过创建数据表命令实现
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE table_name(...)ENGINE=engine_name&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;通过修改数据表命令实现
&lt;code class=&quot;highlighter-rouge&quot;&gt;ALTER TABLE table_name ENGINE[=]engine_name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-管理工具&quot;&gt;4 管理工具&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;phpMyAdmin
需要有PHP环境&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Navicat&lt;/li&gt;
  &lt;li&gt;MySQL Workbench&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 29 May 2017 23:31:40 +0800</pubDate>
      </item>
    
      <item>
        <title>MySQL 中的SQL</title>
        <link>/web/2017/05/19/mysql-sql-study.html</link>
        <guid isPermaLink="true">/web/2017/05/19/mysql-sql-study.html</guid>
        <description>&lt;p&gt;结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。&lt;/p&gt;

&lt;p&gt;不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。&lt;/p&gt;

&lt;p&gt;文章以MySQL数据库为演示环境，主要分享MySQL中的SQL使用。&lt;/p&gt;

&lt;h2 id=&quot;数据库操作&quot;&gt;数据库操作&lt;/h2&gt;

&lt;h3 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] character_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;表示为必选项，即必填参数。&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;表示选项，即其中选取一项即可。&lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt;表示为可选项。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;character_name &lt;/code&gt;参数为指定数据库的编码方式，不填则使用MySQL配置的字符集编码。&lt;/p&gt;

&lt;h3 id=&quot;查看当前服务器下的数据表列表&quot;&gt;查看当前服务器下的数据表列表&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHOW {DATABASES | SCHEMAS} [LIKE 'pattern' | WHERE expr]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除数据库&quot;&gt;删除数据库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;auto_increment&quot;&gt;AUTO_INCREMENT&lt;/h2&gt;

&lt;p&gt;自动编号，且必须与主键组合使用。&lt;/p&gt;

&lt;p&gt;数值型数据。&lt;/p&gt;

&lt;p&gt;默认情况下，起始值为1，每次的增量为1。&lt;/p&gt;

&lt;h2 id=&quot;约束&quot;&gt;约束&lt;/h2&gt;

&lt;p&gt;1.保证数据的完整性和一致性。&lt;/p&gt;

&lt;p&gt;2.分为表级约束（针对两个或两个以上的字段进行约束）和列级约束（针对某一个字段进行约束）。&lt;/p&gt;

&lt;p&gt;3.类型包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NOT NULL 非空约束&lt;/li&gt;
  &lt;li&gt;PRIMARY KEY 主键约束&lt;/li&gt;
  &lt;li&gt;UNIQUE KEY 唯一约束&lt;/li&gt;
  &lt;li&gt;DEFAULT 默认约束&lt;/li&gt;
  &lt;li&gt;FOREIGN KEY 外键约束&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE t6(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM('1', '2', '3') DEFAULT '3');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-05.png&quot; alt=&quot;t6表结构&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT t6 (username) VALUES ('Chars');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-06.png&quot; alt=&quot;t6表插入值&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;空值与非空值&quot;&gt;空值与非空值&lt;/h3&gt;

&lt;p&gt;NULL，字段值可以为空。&lt;/p&gt;

&lt;p&gt;NOT NULL，字段值禁止为空。不存在表级约束。&lt;/p&gt;

&lt;h3 id=&quot;primary-key&quot;&gt;PRIMARY KEY&lt;/h3&gt;

&lt;p&gt;主键约束。&lt;/p&gt;

&lt;p&gt;每张数据表只能存在一个主键。&lt;/p&gt;

&lt;p&gt;主键保证记录的唯一性。&lt;/p&gt;

&lt;p&gt;主键自动为NOT NULL。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AUTO_INCREMENT&lt;/code&gt;必须与&lt;code class=&quot;highlighter-rouge&quot;&gt;PRIMARY KEY&lt;/code&gt;一起使用。但是，&lt;code class=&quot;highlighter-rouge&quot;&gt;PRIMARY KEY&lt;/code&gt;不一定与&lt;code class=&quot;highlighter-rouge&quot;&gt;AUTO_INCREMENT&lt;/code&gt;一起使用。&lt;/p&gt;

&lt;h3 id=&quot;unique-key&quot;&gt;UNIQUE KEY&lt;/h3&gt;

&lt;p&gt;唯一约束。&lt;/p&gt;

&lt;p&gt;唯一约束可以保证记录的唯一性。&lt;/p&gt;

&lt;p&gt;唯一约束的字段可以为空值（NULL）。&lt;/p&gt;

&lt;p&gt;每张数据表可以存在多个唯一约束。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：UNIQUE KEY与PRIMARY KEY区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PRIMARY KEY每张数据表只能有一个，且不能为空。&lt;/p&gt;

&lt;p&gt;UNIQUE KEY每张数据表可以有多个，且可以为空。&lt;/p&gt;

&lt;h3 id=&quot;default&quot;&gt;DEFAULT&lt;/h3&gt;

&lt;p&gt;默认值。&lt;/p&gt;

&lt;p&gt;当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。&lt;/p&gt;

&lt;p&gt;不存在表级约束。&lt;/p&gt;

&lt;h3 id=&quot;foreign-key&quot;&gt;FOREIGN KEY&lt;/h3&gt;

&lt;p&gt;保持数据一致性，完整性。&lt;/p&gt;

&lt;p&gt;实现一对一或一对多关系。&lt;/p&gt;

&lt;p&gt;关系型数据库名称的来源。&lt;/p&gt;

&lt;h4 id=&quot;外键约束的要求&quot;&gt;外键约束的要求&lt;/h4&gt;

&lt;p&gt;1.父表和子表必须使用相同的存储引擎，而且禁止使用临时表。&lt;/p&gt;

&lt;p&gt;2.数据表的存储引擎只能为InnoDB。&lt;/p&gt;

&lt;p&gt;3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。&lt;/p&gt;

&lt;p&gt;4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。&lt;/p&gt;

&lt;h4 id=&quot;外键约束的参照操作&quot;&gt;外键约束的参照操作&lt;/h4&gt;

&lt;p&gt;1.CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行。&lt;/p&gt;

&lt;p&gt;2.SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL。&lt;/p&gt;

&lt;p&gt;3.RESTRICT：拒绝对父表的删除或更新操作。&lt;/p&gt;

&lt;p&gt;4.NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;物理外键即使用FOREIGN KEY关键字定义表。逻辑外键即定义表的时候按照某种联系，但是不使用FOREIGN KEY关键字修饰。&lt;/p&gt;

&lt;h4 id=&quot;编辑数据表的默认存储引擎&quot;&gt;编辑数据表的默认存储引擎&lt;/h4&gt;

&lt;p&gt;MySQL配置文件&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;default-storage-engine=INNODB&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table provinces(id smallint unsigned primary key auto_increment, pname varchar(20) not null);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid bigint, foreign key(pid) references provinces(id));

# 报错
# ERROR 1215 (HY000): Cannot add foreign key constraint
# 因为类型不匹配

# 正确命令应该是：
create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid smallint unsigned, foreign key(pid) references provinces(id));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-07.png&quot; alt=&quot;provinces表索引结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-08.png&quot; alt=&quot;users表索引结构&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;表级约束和列级约束&quot;&gt;表级约束和列级约束&lt;/h3&gt;

&lt;p&gt;对一个数据列建立的约束，称为列级约束。&lt;/p&gt;

&lt;p&gt;对多个数据列建立的约束，称为表级约束。&lt;/p&gt;

&lt;p&gt;列级约束既可以在列定义时声明，也可以在列定义后声明。&lt;/p&gt;

&lt;p&gt;表级约束只能在列定义后声明。&lt;/p&gt;

&lt;h2 id=&quot;数据表操作&quot;&gt;数据表操作&lt;/h2&gt;

&lt;p&gt;数据表（或称表）是数据库最重要的组成部分之一，是其它对象的基础。数据表即二维表，行称为记录，列称为字段。&lt;/p&gt;

&lt;h3 id=&quot;use&quot;&gt;USE&lt;/h3&gt;

&lt;p&gt;打开数据库&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;USE 数据库名称;&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;创建数据表&quot;&gt;创建数据表&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看数据表列表&quot;&gt;查看数据表列表&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;查看数据表结构&quot;&gt;查看数据表结构&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SHOW COLUMNS FROM tbl_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;插入表记录&quot;&gt;插入表记录&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT [INTO] tbl_name [(col_name,...)] VALUES(val,...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果省略col_name就需要写全数据表所有的值。&lt;/p&gt;

&lt;h3 id=&quot;记录查找&quot;&gt;记录查找&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT expr,... FROM tbl_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加单列数据表字段&quot;&gt;添加单列（数据表字段）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;省略[FIRST&lt;/td&gt;
      &lt;td&gt;AFTER col_name]参数将位于所有列的最后面。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;添加多列数据表字段&quot;&gt;添加多列（数据表字段）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [COLUMN] (col_name column_definition, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除列数据表字段&quot;&gt;删除列（数据表字段）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP [COLUMN] col_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加主键约束&quot;&gt;添加主键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加唯一约束&quot;&gt;添加唯一约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name, ...)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加外键约束&quot;&gt;添加外键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) reference_definition
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加删除默认约束&quot;&gt;添加／删除默认约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除主键约束&quot;&gt;删除主键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP PRIMARY KEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除唯一约束&quot;&gt;删除唯一约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP {INDEX | KEY} index_name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;删除外键约束&quot;&gt;删除外键约束&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;修改列定义&quot;&gt;修改列定义&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;修改列名称&quot;&gt;修改列名称&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST | AFTER col_name]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;数据表更名&quot;&gt;数据表更名&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 方法1
ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name

# 方法2
RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_tbl_name2] ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;数据表数据操作&quot;&gt;数据表数据操作&lt;/h2&gt;

&lt;h3 id=&quot;insert&quot;&gt;INSERT&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 插入记录（可以插入多条记录）
INSERT [INTO] tbl_name [(col_name, ...)] {VALUES|VALUE} ({expr|DEFAULT}, ...), (...), ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 插入记录（不可以插入多条记录）
INSERT [INTO] tbl_name SET col_name = {expr|DEFAULT}, ...

# 说明：与前一种方式的区别在于，此方法可以使用子查询（SubQuery）。由比较运算引发子查询（SubQuery）。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 插入记录
INSERT [INTO] tbl_name [(col_name, ...)] SELECT ...

# 说明：此方法可以将查询结果插入到指定数据表。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.创建“商品分类”表
CREATE TABLE IF NOT EXISTS tdb_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40));

2.查询tdb_goods表的所有记录，并且按&quot;类别&quot;分组
SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;

3.将分组结果写入到tdb_goods_cates数据表
INSERT tdb_goods_cates (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;update&quot;&gt;UPDATE&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 更新记录（单表更新）
UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1 = {expr|DEFAULT} [, col_name2 = {expr|DEFAULT}] ... [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;delete&quot;&gt;DELETE&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 删除记录（单表删除）
DELETE FROM tbl_name [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;select&quot;&gt;SELECT&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查找记录
SELECT select_expr [, select_expr ...] 
[
	FROM table_references
	[WHERE where_condition]
	[GROUP BY {col_name|position} [ASC|DESC], ... ]
	[HAVING where_condition]
	[ORDER BY {col_name|expr|position} [ASC|DESC], ...]
	[LIMIT {[offset,] row_count | row_count OFFSET offset}]
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;select_expr-查询表达式&quot;&gt;select_expr 查询表达式&lt;/h4&gt;

&lt;p&gt;每一个表达式表示想要的一列，必须至少有一个。&lt;/p&gt;

&lt;p&gt;多个列之间以英文逗号分隔。&lt;/p&gt;

&lt;p&gt;星号（&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;）表示多有列。&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name.*&lt;/code&gt;可以表示命名表的所有列。&lt;/p&gt;

&lt;p&gt;查询表达式可以使用[AS] alias_name为其赋予别名。&lt;/p&gt;

&lt;p&gt;别名可用于GROUP BY，ORDER BY或HAVING子句。&lt;/p&gt;

&lt;h4 id=&quot;where-条件表达式&quot;&gt;WHERE 条件表达式&lt;/h4&gt;

&lt;p&gt;对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。&lt;/p&gt;

&lt;p&gt;在WHERE表达式中，可以使用MySQL支持的函数或运算符。&lt;/p&gt;

&lt;h4 id=&quot;group-by-查询结果分组&quot;&gt;GROUP BY 查询结果分组&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[GROUP BY {col_name|position} [ASC|DESC], ... ]&lt;/code&gt;
ASC：生序，默认值。
DESC：降序。&lt;/p&gt;

&lt;h4 id=&quot;having-分组条件&quot;&gt;HAVING 分组条件&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[HAVING where_condition]&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;where_condition&lt;/code&gt;中要么使用聚合函数，要么出现的字段一定要在SELECT中出现。&lt;/p&gt;

&lt;p&gt;聚合函数：count() …&lt;/p&gt;

&lt;h4 id=&quot;order-by-对查询结果进行排序&quot;&gt;ORDER BY 对查询结果进行排序&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[ORDER BY {col_name|expr|position} [ASC|DESC], ...]&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;limit-限制查询返回的数量&quot;&gt;LIMIT 限制查询返回的数量&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[LIMIT {[offset,] row_count | row_count OFFSET offset}]&lt;/code&gt;
offset是从0开始的。&lt;/p&gt;

&lt;h3 id=&quot;create--select&quot;&gt;CREATE … SELECT&lt;/h3&gt;

&lt;p&gt;创建数据表同时将查询结果写入到数据表
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE [IF NOT EXISTS] tbl_name [(create_definition, ...)] select_statement&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过CREATE…SELECT来创建数据表并且同时写入记录
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;子查询&quot;&gt;子查询&lt;/h2&gt;

&lt;p&gt;子查询（Subquery）是指出现在其他SQL语句内的SELECT子句。例如：
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM t1 WHERE col1=(SELECT col2 FROM t2);&lt;/code&gt;
其中&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM t1&lt;/code&gt;称为Outer Query/Outer Statement。&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT col2 FROM t2&lt;/code&gt;称为SubQuery。&lt;/p&gt;

&lt;p&gt;子查询指嵌套在查询内部，且必须始终出现在圆括号内。子查询可以包含多个关键字或条件，如DISTINCT、GROUP BY、ORDER BY、LIMIT函数等。子查询外层的查询可以是：SELECT、INSERT、UPDATE、SET或DO。&lt;/p&gt;

&lt;p&gt;子查询可以返回标量、一行、一列或子查询。&lt;/p&gt;

&lt;h3 id=&quot;数据准备&quot;&gt;数据准备&lt;/h3&gt;

&lt;p&gt;1.创建表&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create table tdb_goods (
	goods_id smallint unsigned primary key auto_increment,
	goods_name varchar(150) not null, 
	goods_cate varchar(40) not null, 
	brand_name varchar(40) not null,
	goods_price decimal(15,3) unsigned default 0 not null, 
	is_show boolean default 1 not null, 
	is_saleoff boolean default 0 not null);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.添加数据&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('Mac Pro MD878CH/A 专业级台式电脑','服务器/工作站','苹果','28888',DEFAULT,DEFAULT);
 
INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(' HMZ-T3W 头戴显示设备','笔记本配件','索尼','6999',DEFAULT,DEFAULT);

INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('商务双肩背包','笔记本配件','索尼','99',DEFAULT,DEFAULT);

INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('X3250 M4机架式服务器 2583i14','服务器/工作站','IBM','6888',DEFAULT,DEFAULT);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;分类&quot;&gt;分类&lt;/h3&gt;

&lt;h4 id=&quot;使用比较运算符的子查询&quot;&gt;使用比较运算符的子查询&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;=、&amp;gt;、&amp;lt;、&amp;gt;=、&amp;lt;=、&amp;lt;&amp;gt;、!=、&amp;lt;=&amp;gt; ...&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;语法结构
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator subquery&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;求所有电脑产品的平均价格,并且保留两位小数，AVG,MAX,MIN、COUNT、SUM为聚合函数
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查询所有价格大于平均价格的商品，并且按价格降序排序
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &amp;gt; 5845.10 ORDER BY goods_price DESC;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用子查询来实现
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &amp;gt; (SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods) ORDER BY goods_price DESC;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;用anysome或all修饰的比较运算符&quot;&gt;用ANY、SOME或ALL修饰的比较运算符&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator ANY(subquery)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator SOME(subquery)&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator ALL(subquery)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ANY、SOME、ALL关键字&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;查询价格大于或等于”超级本”价格的商品，并且按价格降序排列
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY(SELECT goods_price FROM tdb_goods WHERE goods_cate = '超级本') ORDER BY goods_price DESC;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用notin的子查询&quot;&gt;使用[NOT]IN的子查询&lt;/h4&gt;

&lt;p&gt;语法结构
&lt;code class=&quot;highlighter-rouge&quot;&gt;operand comparison_operator [NOT]IN(subquery)&lt;/code&gt;
=ANY运算符与IN等效。
!=ALL或&amp;lt;&amp;gt;ALL运算符与NOT IN等效。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;= ANY 或 = SOME 等价于 IN
&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price IN (SELECT goods_price FROM tdb_goods WHERE goods_cate = '超级本') ORDER BY goods_price DESC;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;使用notexists的子查询&quot;&gt;使用[NOT]EXISTS的子查询&lt;/h4&gt;

&lt;p&gt;如果子查询返回任何行，EXISTS将返回TRUE；否则为FALSE。&lt;/p&gt;

&lt;h2 id=&quot;连接&quot;&gt;连接&lt;/h2&gt;

&lt;p&gt;MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作。&lt;/p&gt;

&lt;h3 id=&quot;多表更新&quot;&gt;多表更新&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UPDATE table_references SET col_name1 = {expr1|DEFAULT} [, col_name2 = {expr2|DEFAULT}] ... [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;table_references &lt;/code&gt;的语法结构：
&lt;code class=&quot;highlighter-rouge&quot;&gt;{[INNER|CROSS] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference ON conditional_expr&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;数据表参照&quot;&gt;数据表参照&lt;/h4&gt;

&lt;p&gt;table_references
&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name [[AS] alias]|table_subquery [AS] alias&lt;/code&gt;
数据表可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name AS alias_name&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;tbl_name alias_name&lt;/code&gt;赋予别名。
&lt;code class=&quot;highlighter-rouge&quot;&gt;table_subquery&lt;/code&gt;可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。&lt;/p&gt;

&lt;h4 id=&quot;连接类型&quot;&gt;连接类型&lt;/h4&gt;

&lt;p&gt;INNER JOIN，内连接。在MySQL中，JOIN，CROSS JOIN和INNER JOIN是等价的。
LEFT [OUTER] JOIN，左外连接。
RIGHT [OUTER] JOIN，右外连接。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过tdb_goods_cates数据表来更新tdb_goods表
&lt;code class=&quot;highlighter-rouge&quot;&gt;UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate = cate_name SET goods_cate = cate_id ;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;多表删除&quot;&gt;多表删除&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DELETE tbl_name [.*] [, tbl_name [.*]] ... FROM table_references [WHERE where_condition]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;内连接&quot;&gt;内连接&lt;/h3&gt;

&lt;p&gt;显示左表及右表符合连接条件的记录。即仅显示符合连接条件的内容。
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-11.png?imageView/2/w/150&quot; alt=&quot;内连接&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;外连接&quot;&gt;外连接&lt;/h3&gt;

&lt;p&gt;A LEFT JOIN B join_condition.
数据表B的结果集依赖数据表A。
数据表A的结果集根据左连接条件依赖所有数据表（B表除外）。
左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下）。
如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。
如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;左外连接
显示左表的全部记录及右表符合连接条件的记录。
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-12.png?imageView/2/w/150&quot; alt=&quot;左外连接&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;右外连接
显示右表的全部记录及左表符合连接条件的记录。
&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-13.png?imageView/2/w/150&quot; alt=&quot;右外连接&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;连接条件&quot;&gt;连接条件&lt;/h3&gt;

&lt;p&gt;使用ON关键字来设定连接条件，也可以使用WHERE来代替。
通常使用ON关键字来设定连接条件，使用WHERE关键字进行结果集记录的过滤。&lt;/p&gt;

&lt;h3 id=&quot;无限级分类表设计&quot;&gt;无限级分类表设计&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;无限分类的数据表设计
&lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE tdb_goods_types(
   type_id   SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
   type_name VARCHAR(20) NOT NULL,
   parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0
);&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;插入数据&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT tdb_goods_types(type_name,parent_id) VALUES('家用电器',DEFAULT);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑、办公',DEFAULT);
INSERT tdb_goods_types(type_name,parent_id) VALUES('大家电',1);
INSERT tdb_goods_types(type_name,parent_id) VALUES('生活电器',1);
INSERT tdb_goods_types(type_name,parent_id) VALUES('平板电视',3);
INSERT tdb_goods_types(type_name,parent_id) VALUES('空调',3);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电风扇',4);
INSERT tdb_goods_types(type_name,parent_id) VALUES('饮水机',4);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑整机',2);
INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑配件',2);
INSERT tdb_goods_types(type_name,parent_id) VALUES('笔记本',9);
INSERT tdb_goods_types(type_name,parent_id) VALUES('超级本',9);
INSERT tdb_goods_types(type_name,parent_id) VALUES('游戏本',9);
INSERT tdb_goods_types(type_name,parent_id) VALUES('CPU',10);
INSERT tdb_goods_types(type_name,parent_id) VALUES('主机',10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;自身连接&quot;&gt;自身连接&lt;/h3&gt;

&lt;p&gt;同一个数据表对其自身进行连接。&lt;/p&gt;
</description>
        <pubDate>Fri, 19 May 2017 23:43:18 +0800</pubDate>
      </item>
    
      <item>
        <title>与 MySQL 的零距离接触</title>
        <link>/web/2017/05/17/mysql-study.html</link>
        <guid isPermaLink="true">/web/2017/05/17/mysql-study.html</guid>
        <description>&lt;p&gt;&lt;a href=&quot;https://www.mysql.com/&quot;&gt;MySQL&lt;/a&gt;是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。&lt;/p&gt;

&lt;p&gt;MySQL是一个开源的关系型数据库管理系统，分为社区版和企业版。&lt;/p&gt;

&lt;h1 id=&quot;1-安装&quot;&gt;1 安装&lt;/h1&gt;

&lt;p&gt;直接前往官网 https://www.mysql.com/ ，进入download页面下载所需对应安装版本。默认配置安装即可。&lt;/p&gt;

&lt;h1 id=&quot;2-配置&quot;&gt;2 配置&lt;/h1&gt;

&lt;p&gt;安装成功之后，需要修改密码。详看&lt;a href=&quot;/2017/03/22/mysql-install-config/&quot;&gt;《MySQL 安装配置》&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;修改编码方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[mysql]
default-character-set=utf8

[mysql]
character-set-server=utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-目录结构&quot;&gt;3 目录结构&lt;/h1&gt;

&lt;p&gt;bin目录，存储可执行文件。&lt;/p&gt;

&lt;p&gt;data目录，存储数据文件。&lt;/p&gt;

&lt;p&gt;docs，文档。&lt;/p&gt;

&lt;p&gt;include目录，存储包含的头文件。&lt;/p&gt;

&lt;p&gt;lib目录，存储库文件。&lt;/p&gt;

&lt;p&gt;share，错误消息和字符集文件。&lt;/p&gt;

&lt;h1 id=&quot;4-命令参数说明&quot;&gt;4 命令参数说明&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-D,–database=name&lt;/td&gt;
      &lt;td&gt;打开指定数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–delimiter=name&lt;/td&gt;
      &lt;td&gt;指定分隔符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-h,–host=name&lt;/td&gt;
      &lt;td&gt;服务器名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-p,–password[=name]&lt;/td&gt;
      &lt;td&gt;密码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-P,–port=#&lt;/td&gt;
      &lt;td&gt;端口号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–prompt=name&lt;/td&gt;
      &lt;td&gt;设置提示符&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u,–user=name&lt;/td&gt;
      &lt;td&gt;用户名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-V,–version&lt;/td&gt;
      &lt;td&gt;输出版本信息并退出&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;mysql提示符&quot;&gt;MySQL提示符&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\D&lt;/td&gt;
      &lt;td&gt;完整的日期&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\d&lt;/td&gt;
      &lt;td&gt;当前数据库&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\h&lt;/td&gt;
      &lt;td&gt;服务器名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\u&lt;/td&gt;
      &lt;td&gt;当前用户&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;命令使用&quot;&gt;命令使用&lt;/h2&gt;

&lt;h3 id=&quot;修改mysql提示符&quot;&gt;修改MySQL提示符&lt;/h3&gt;

&lt;p&gt;1.连接客户端时通过参数指定&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -uroot -proot --prompt 提示符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.连接上客户端后，通过prompt命令修改&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt;prompt 提示符
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mysql常用命令&quot;&gt;MySQL常用命令&lt;/h3&gt;

&lt;p&gt;1.显示当前服务器版本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT VERSION();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2.显示当前日期时间&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT NOW();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3.显示当前用户&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT USER();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;mysql语句规范&quot;&gt;MySQL语句规范&lt;/h3&gt;

&lt;p&gt;1.关键字与函数名称全部大写。&lt;/p&gt;

&lt;p&gt;2.数据库名称、表名称、字段名称全部小写。&lt;/p&gt;

&lt;p&gt;3.SQL语句必须以”;”符号结尾。&lt;/p&gt;

&lt;h1 id=&quot;5-sql&quot;&gt;5 SQL&lt;/h1&gt;

&lt;p&gt;结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言。
不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。&lt;/p&gt;

&lt;p&gt;具体参看文章
&lt;a href=&quot;/2017/05/19/mysql-sql-study/&quot;&gt;《MySQL 中的SQL》&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;6-数据类型&quot;&gt;6 数据类型&lt;/h1&gt;

&lt;p&gt;数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同信息的类型。&lt;/p&gt;

&lt;h2 id=&quot;整型&quot;&gt;整型&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/mysql-study-01.png&quot; alt=&quot;整型表&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;浮点型&quot;&gt;浮点型&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;数据类型&lt;/th&gt;
      &lt;th&gt;存储范围&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FLOAT[(M,D)]&lt;/td&gt;
      &lt;td&gt;-3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。M是数字总位数，D是小数点后面的位数。如果M和D被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数点。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DOUBLE[(M,D)]&lt;/td&gt;
      &lt;td&gt;-1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到1.7976931348623157E+308。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;日期和时间型&quot;&gt;日期和时间型&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;列类型&lt;/th&gt;
      &lt;th&gt;存储需求&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;YEAR&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIME&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATE&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DATETIME&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TIMESTAMP&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;字符型&quot;&gt;字符型&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;列类型&lt;/th&gt;
      &lt;th&gt;存储需求&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;CHAR(M)&lt;/td&gt;
      &lt;td&gt;M个字节，0&amp;lt;=M&amp;lt;=255&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VARCHAR(M)&lt;/td&gt;
      &lt;td&gt;L+1个字节，其中L&amp;lt;=M且0&amp;lt;=M&amp;lt;=65535&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TINYTEXT&lt;/td&gt;
      &lt;td&gt;L+1个字节，其中L&amp;lt;2^8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TEXT&lt;/td&gt;
      &lt;td&gt;L+2个字节，其中L&amp;lt;2^16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MEDIUMTEXT&lt;/td&gt;
      &lt;td&gt;L+3个字节，其中L&amp;lt;2^24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LONGTEXT&lt;/td&gt;
      &lt;td&gt;L+4个字节，其中L&amp;lt;2^32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ENUM(‘VALUE1’,’VALUE2’,…)&lt;/td&gt;
      &lt;td&gt;1或2个字节，取决于枚举值的个数（最多65,535个值）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SET(‘VALUE1’,’VALUE2’,…)&lt;/td&gt;
      &lt;td&gt;1、2、3、4或者8个字节，取决于set成员的数目（最多64个成员）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;更多其他MySQL使用与知识可以参见&lt;a href=&quot;/2017/05/29/mysql-advanced-study/&quot;&gt;《拆解 MySQL 的高阶使用与概念》&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 17 May 2017 07:05:12 +0800</pubDate>
      </item>
    
  </channel>
</rss>