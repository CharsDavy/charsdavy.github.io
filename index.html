<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Chars&#39;s Tech Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="long time no see.">
<meta property="og:type" content="website">
<meta property="og:title" content="Chars's Tech Blog">
<meta property="og:url" content="http://charsdavy.github.io/index.html">
<meta property="og:site_name" content="Chars's Tech Blog">
<meta property="og:description" content="long time no see.">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chars's Tech Blog">
<meta name="twitter:description" content="long time no see.">
  
    <link rel="alternative" href="/atom.xml" title="Chars&#39;s Tech Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/avatar.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Chars Davy</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>About</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
							<li><a href="/atom.xml">RSS</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/charsdavy" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/3875245858/" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="/chars_d@126.com" title="mail">mail</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/charsdavy" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/iOS/" style="font-size: 10px;">开源框架</a> <a href="/tags/algorithm/" style="font-size: 10px;">算法</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/users/bd2336d8f946/latest_articles">Chars</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://casatwy.com/">casatwy</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://cenalulu.github.io/">cenalulu</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">Chars @ ZAKER 立志成为全栈攻城狮。喜欢游泳，羽毛球。 爱好一个人静静写代码，看代码，看书。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Chars Davy</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/img/avatar.png" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Chars Davy</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
					<li><a href="/atom.xml">RSS</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/charsdavy" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/3875245858/" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="/chars_d@126.com" title="mail">mail</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/charsdavy" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-YYModel-reading" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/27/YYModel-reading/" class="article-date">
  	<time datetime="2016-05-27T12:51:21.000Z" itemprop="datePublished">2016-05-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/27/YYModel-reading/">YYModel源代码阅读 - 基础知识</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。</p>
<p>源代码在<a href="https://github.com/ibireme/YYModel" target="_blank" rel="external">Github</a>，大家可以自行<code>git clone</code>或者download。</p>
<p>接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。</p>
<h1 id="NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END"><a href="#NS-ASSUME-NONNULL-BEGIN-amp-NS-ASSUME-NONNULL-END" class="headerlink" title="NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END"></a>NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END</h1><p>这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。</p>
<p>这组宏会引出几个关于Objective-C新特性的知识点：</p>
<ul>
<li><p>Nullability Annotations</p>
</li>
<li><p>Lightweight Generics</p>
</li>
<li><p>__kindof</p>
</li>
</ul>
<h2 id="Nullability-Annotations"><a href="#Nullability-Annotations" class="headerlink" title="Nullability Annotations"></a>Nullability Annotations</h2><p>我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。</p>
<p>为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：<strong>nullability annotations</strong>。这一新特性的核心是两个新的类型注释：<strong> __nullable</strong> 和 <strong>__nonnull</strong> 。从字面上我们可以猜到，<code>__nullable</code>表示对象可以是NULL或nil，而<code>__nonnull</code>表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。</p>
<p>我们来看看以下的实例，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface TestNullabilityClass ()</span><br><span class="line">@property (nonatomic, copy) NSArray * items;</span><br><span class="line">- (id)itemWithName:(NSString * __nonnull)name;</span><br><span class="line">@end</span><br><span class="line">@implementation TestNullabilityClass</span><br><span class="line">...</span><br><span class="line">- (void)testNullability &#123;</span><br><span class="line">    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument</span><br><span class="line">&#125;</span><br><span class="line">- (id)itemWithName:(NSString * __nonnull)name &#123;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>不过这只是一个警告，程序还是能编译通过并运行。</p>
<p>事实上，在任何可以使用const关键字的地方都可以使用<code>__nullable</code>和<code>__nonnull</code>，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的<code>nullable</code>和<code>nonnull</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (nullable id)itemWithName:(NSString * nonnull)name</span><br><span class="line">在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy, nonnull) NSArray * items;</span><br><span class="line">当然也可以用以下这种方式：</span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSArray * __nonnull items;</span><br><span class="line">推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。</span><br></pre></td></tr></table></figure>
<h3 id="Nonnull区域设置-Audited-Regions"><a href="#Nonnull区域设置-Audited-Regions" class="headerlink" title="Nonnull区域设置(Audited Regions)"></a>Nonnull区域设置(Audited Regions)</h3><p>如果需要每个属性或每个方法都去指定<code>nonnull</code>和<code>nullable</code>，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：<strong>NS_ASSUME_NONNULL_BEGIN</strong>和<strong>NS_ASSUME_NONNULL_END</strong>。在这两个宏之间的代码，所有简单指针对象都被假定为 <code>nonnull</code>，因此我们只需要去指定那些<code>nullable</code>的指针。如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NS_ASSUME_NONNULL_BEGIN</span><br><span class="line">@interface TestNullabilityClass ()</span><br><span class="line">@property (nonatomic, copy) NSArray * items;</span><br><span class="line">- (id)itemWithName:(nullable NSString *)name;</span><br><span class="line">@end</span><br><span class="line">NS_ASSUME_NONNULL_END</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。</p>
<p>不过，为了安全起见，苹果还制定了几条规则：</p>
<ul>
<li><p>typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。</p>
</li>
<li><p>复杂的指针类型(如id <em>)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id </em> __nonnull”。</p>
</li>
<li><p>我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。</p>
</li>
</ul>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：</p>
<ul>
<li><p>老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。</p>
</li>
<li><p>老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。</p>
</li>
<li><p>nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。</p>
</li>
</ul>
<p>事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。</p>
<h2 id="Lightweight-Generics"><a href="#Lightweight-Generics" class="headerlink" title="Lightweight Generics"></a>Lightweight Generics</h2><p>Lightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）</p>
<h3 id="带泛型的容器"><a href="#带泛型的容器" class="headerlink" title="带泛型的容器"></a>带泛型的容器</h3><p>这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray&lt;NSString *&gt; *strings = @[@&quot;sun&quot;, @&quot;yuan&quot;];</span><br><span class="line">NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @&#123;@&quot;a&quot;: @1, @&quot;b&quot;: @2&#125;;</span><br></pre></td></tr></table></figure>
<p>返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。</p>
<p>假如向泛型容器中加入错误的对象，编译器会不开心的。</p>
<p>系统中常用的一系列容器类型都增加了泛型支持，甚至连 <code>NSEnumerator</code> 都支持了，这是非常 Nice 的改进。和 <code>Nullability</code> 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly) NSArray *imageURLs;</span><br><span class="line">@property (readonly) NSArray&lt;NSURL *&gt; *imageURLs;</span><br></pre></td></tr></table></figure>
<p>不用多想就清楚下面的数组中存的是什么，避免了 <code>NSString</code> 和 <code>NSURL</code> 的混乱。</p>
<h3 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h3><p>比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface Stack&lt;ObjectType&gt; : NSObject</span><br><span class="line">- (void)pushObject:(ObjectType)object;</span><br><span class="line">- (ObjectType)popObject;</span><br><span class="line">@property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>这个 <code>ObjectType</code> 是传入类型的 <code>placeholder</code>，它只能在 <code>@interface</code> 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 <code>@interface</code> 和 <code>@end</code> 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 只接受 NSNumber * 的泛型</span><br><span class="line">@interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject</span><br><span class="line">// 只接受满足 NSCopying 协议的泛型</span><br><span class="line">@interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject</span><br></pre></td></tr></table></figure>
<p>若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。<br>实例化一个 Stack，一切工作正常：</p>
<p>对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。</p>
<h3 id="协变性和逆变性"><a href="#协变性和逆变性" class="headerlink" title="协变性和逆变性"></a>协变性和逆变性</h3><p>当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack *stack; // Stack *</span><br><span class="line">Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt;</span><br><span class="line">Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt;</span><br></pre></td></tr></table></figure>
<p>当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stack *stack;</span><br><span class="line">Stack&lt;NSString *&gt; *stringStack;</span><br><span class="line">Stack&lt;NSMutableString *&gt; *mutableStringStack; </span><br><span class="line"></span><br><span class="line">stack = stringStack;</span><br><span class="line">stack = mutableStringStack;</span><br><span class="line">stringStack = stack;</span><br><span class="line">stringStack = mutableStringStack;</span><br><span class="line">mutableStringStack = stack;</span><br><span class="line">mutableStringStack = stringStack</span><br></pre></td></tr></table></figure>
<p>在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）</span><br><span class="line">__contravariant - 逆变性，父类型可以强转到子类型（WTF）</span><br></pre></td></tr></table></figure>
<h4 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Stack&lt;__covariant ObjectType&gt; : NSObject</span><br></pre></td></tr></table></figure>
<h4 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface Stack&lt;__contravariant ObjectType&gt; : NSObject</span><br></pre></td></tr></table></figure>
<p>协变是非常好理解的，像 <code>NSArray</code> 的泛型就用了协变的修饰符。</p>
<h2 id="kindof"><a href="#kindof" class="headerlink" title="__kindof"></a>__kindof</h2><p><code>__kindof</code> 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 <code>UITableView</code> 的这个方法来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;</span><br></pre></td></tr></table></figure></p>
<p>使用时前面基本会使用 <code>UITableViewCell</code> 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 <code>UITableViewCell</code> 或 <code>UITableViewCell</code> 子类的实例，于是新的 <code>__kindof</code> 关键字解决了这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;</span><br></pre></td></tr></table></figure>
<p>既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews;</span><br></pre></td></tr></table></figure>
<p>这样，写下面的代码时就没有任何警告了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIButton *button = view.subviews.lastObject;</span><br></pre></td></tr></table></figure>
<h1 id="NS-ENUM-amp-NS-OPTIONS"><a href="#NS-ENUM-amp-NS-OPTIONS" class="headerlink" title="NS_ENUM &amp; NS_OPTIONS"></a>NS_ENUM &amp; NS_OPTIONS</h1><p>枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。</p>
<p>枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。</p>
<p>一般我们声明枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">// 声明枚举类型</span><br><span class="line">enum Direction &#123;up, down, left = 10, right&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[])&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">其中up = 0, down = 1, left = 10, right = 11。</span><br></pre></td></tr></table></figure>
<p>我们会发现枚举中一些不可自定义的部分，例如，枚举名。</p>
<p>NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。</p>
<h2 id="NS-ENUM"><a href="#NS-ENUM" class="headerlink" title="NS_ENUM"></a>NS_ENUM</h2><p>如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#ifndef NS_ENUM</span><br><span class="line">#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>在OS X 10.4 中的原始定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)</span><br><span class="line">#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)</span><br></pre></td></tr></table></figure>
<p>在之前枚举可以这么定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef enum &#123;</span><br><span class="line">    UITableViewCellStyleDefault,</span><br><span class="line">    UITableViewCellStyleValue1,</span><br><span class="line">    UITableViewCellStyleValue2,</span><br><span class="line">    UITableViewCellStyleSubtitle</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef NSInteger UITableViewCellStyle;</span><br></pre></td></tr></table></figure>
<p>现在，有了统一的风格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) &#123;</span><br><span class="line">    UITableViewCellSelectionStyleNone,</span><br><span class="line">    UITableViewCellSelectionStyleBlue,</span><br><span class="line">    UITableViewCellSelectionStyleGray,</span><br><span class="line">    UITableViewCellSelectionStyleDefault</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NS_ENUM</code> 的第一个参数是用于存储的新类型的类型。在64位环境下，<code>UITableViewCellStyle</code> 和 <code>NSInteger</code> 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。</p>
<h2 id="NS-OPTIONS"><a href="#NS-OPTIONS" class="headerlink" title="NS_OPTIONS"></a>NS_OPTIONS</h2><p>语法和 <code>NS_ENUM</code> 完全相同，但这个宏提示编译器值是如何通过位掩码 | 组合在一起的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, AMGResizing) &#123;</span><br><span class="line">    AMGResizingNone            = 0,</span><br><span class="line">    AMGResizingFlexibleWidth   = 1 &lt;&lt; 0,</span><br><span class="line">    AMGResizingFlexibleHeight  = 1 &lt;&lt; 1,</span><br><span class="line">    AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="attribute-always-inline"><a href="#attribute-always-inline" class="headerlink" title="attribute((always_inline))"></a><strong>attribute</strong>((always_inline))</h1><p>我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以<code>inline</code>的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而<code>static</code>会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。</p>
<p><code>__attribute__((always_inline))</code> 的意思是强制内联，所有加了<code>__attribute__((always_inline))</code> 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数<br><code>__attribute__((always_inline)) void a()</code><br>和</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void b()｛  </span><br><span class="line">    a();</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。<br><code>#define __inline __attribute__((always_inline))</code> 的意思就是用<br><code>__inline</code> 代替<code>__attribute__((always_inline))</code><br>内声明a的时候可以直接写成<code>__inline void a()</code> 这样比较方便因为<code>__attribute__((always_inline))</code> 字多。</p>
<h1 id="undef"><a href="#undef" class="headerlink" title="undef"></a>undef</h1><p>这是预编译指令，和<code>#define</code>搭配使用，意思是取消之前的宏定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define PROC_ADD </span><br><span class="line">void main(void) </span><br><span class="line">&#123;</span><br><span class="line">#ifdef PROC_ADD </span><br><span class="line">// Do this code here then undefined it to run the code in the else </span><br><span class="line">// processing work </span><br><span class="line">#undef PROC_ADD </span><br><span class="line">#else </span><br><span class="line">// now that PROC_ADD has been undefined run this code </span><br><span class="line">// processing work </span><br><span class="line">#endif </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h1><p><code>__unsafe_unretained</code>是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。</p>
<p>在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alloc的要release;</span><br><span class="line">retain/copy的要release;</span><br><span class="line">NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;</span><br><span class="line">使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.</span><br><span class="line">注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能.</span><br></pre></td></tr></table></figure>
<h1 id="package"><a href="#package" class="headerlink" title="@package"></a>@package</h1><p>为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。</p>
<p>以下是这些关键字的使用范围：</p>
<ul>
<li>@private</li>
</ul>
<p>The instance variable is accessible only within the class that declares it.</p>
<p>实例变量只能被声明它的类访问.</p>
<ul>
<li>@protected</li>
</ul>
<p>The instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope.</p>
<p>实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是.</p>
<ul>
<li>@public</li>
</ul>
<p>The instance variable is accessible everywhere.</p>
<p>实例变量可以被在任何地方访问.</p>
<ul>
<li>@package</li>
</ul>
<p>Using the modern runtime, an <code>@package</code> instance variable has <code>@public</code> scope inside the executable image that implements the class, but acts like <code>@private</code> outside.使用modern运行时，一个<code>@package</code>实例变量在实现这个类的可执行文件镜像中实际上是<code>@public</code>的，但是在外面就是<code>@private</code>【runtime需要再看一下苹果文档Runtime Programming Guide】</p>
<p>The <code>@package</code> scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.</p>
<p>Objective-C中的<code>@package</code>与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link error</p>
<p>This scope is most useful for instance variables in framework classes, where <code>@private</code> may be too restrictive but <code>@protected</code> or <code>@public</code> too permissive.</p>
<p>这个类型最常用于框架类的实例变量，使用<code>@private</code>太限制，使用<code>@protected</code>或者<code>@public</code>又太开放. |</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">开源框架</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/develop/">移动开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-ios-simultaneously" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/26/ios-simultaneously/" class="article-date">
  	<time datetime="2016-05-26T00:32:15.000Z" itemprop="datePublished">2016-05-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/26/ios-simultaneously/">iOS 并发概念浅析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。接下来，主要分享对一些易混淆概念的理解。</p>
<h1 id="一、线程和任务"><a href="#一、线程和任务" class="headerlink" title="一、线程和任务"></a>一、线程和任务</h1><p>线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考<a href="https://en.wikipedia.org/wiki/Thread_%28computing%29" target="_blank" rel="external">Thread (computing)</a>和<a href="https://en.wikipedia.org/wiki/Task_%28computing" target="_blank" rel="external">Task (computing)</a>。</p>
<h2 id="1）任务（task）"><a href="#1）任务（task）" class="headerlink" title="1）任务（task）"></a>1）任务（task）</h2><p>a）任务（task）是从程序中划分出来，可以独立执行的代码片段；</p>
<p>b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。</p>
<p>需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。</p>
<p>下面的代码是对一个任务的简单封装，并支持任务间的依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//Task是一个任务的简单封装类</span><br><span class="line">class Task &#123;</span><br><span class="line">    let taskBlock: () -&gt; ()</span><br><span class="line">    var dependencies = [Task]() </span><br><span class="line">    init(block: () -&gt; ()) &#123;</span><br><span class="line">        taskBlock = block</span><br><span class="line">    &#125; </span><br><span class="line">    func addDependency(task: Task) &#123;</span><br><span class="line">        dependencies.append(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//初始化两个自定义任务</span><br><span class="line">var taskA = Task()&#123;</span><br><span class="line">    //自定义任务A，自定义需要执行的代码</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">var taskB = Task()&#123;</span><br><span class="line">    //自定义任务B，自定义需要执行的代码</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br><span class="line">//添加依赖关系</span><br><span class="line">taskB.addDependency(taskA)</span><br></pre></td></tr></table></figure>
<h2 id="2）线程（thread）"><a href="#2）线程（thread）" class="headerlink" title="2）线程（thread）"></a>2）线程（thread）</h2><p>a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。</p>
<p>b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。</p>
<p>c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。</p>
<h1 id="二、概念释疑"><a href="#二、概念释疑" class="headerlink" title="二、概念释疑"></a>二、概念释疑</h1><h2 id="1）并行（parallelism）和并发（concurrency）"><a href="#1）并行（parallelism）和并发（concurrency）" class="headerlink" title="1）并行（parallelism）和并发（concurrency）"></a>1）并行（parallelism）和并发（concurrency）</h2><p>并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，而并行是。</p>
<p>单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。</p>
<p>多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//三个线程的并发</span><br><span class="line">thread1 -&gt; |---A---|             -&gt;|---A---|</span><br><span class="line">thread2 ------&gt;    -&gt;|------B----|</span><br><span class="line">thread3 ------------------------------------&gt; |------C------|</span><br></pre></td></tr></table></figure>
<p>上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//三个线程的并行</span><br><span class="line">thread1 -&gt; |-----A-----|</span><br><span class="line">thread2 -&gt;       |------B----|</span><br><span class="line">thread3 -&gt;     |------C------|</span><br></pre></td></tr></table></figure>
<p>上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。</p>
<p>现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰起见，下文中有时会用并行，其实即是并发。）</p>
<h2 id="2）串并行与线程"><a href="#2）串并行与线程" class="headerlink" title="2）串并行与线程"></a>2）串并行与线程</h2><h3 id="串行（serial）和并行"><a href="#串行（serial）和并行" class="headerlink" title="串行（serial）和并行"></a>串行（serial）和并行</h3><p>串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提；并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来；串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//三个串行任务</span><br><span class="line">|-----A-----||------B--------||----C--|</span><br></pre></td></tr></table></figure>
<p>上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//三个并发任务</span><br><span class="line">|-----A-----|</span><br><span class="line">      |------B----|</span><br><span class="line">   |--C---|</span><br></pre></td></tr></table></figure>
<p>上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。</p>
<h3 id="串并行与线程"><a href="#串并行与线程" class="headerlink" title="串并行与线程"></a>串并行与线程</h3><p>串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。</p>
<p>单线程既可以实现串行，也可以实现并行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//单线程串行</span><br><span class="line">1 thread -&gt;   |----A-----||-----B-----------||-------C------|</span><br><span class="line">//单线程并行（理论上，实际中不可行）</span><br><span class="line">         A-Start ---------------------------------------- A-End  </span><br><span class="line">           | B-Start ----------------------------------------|--- B-End  </span><br><span class="line">           |   |     C-Start -------------------- C-End      |     |  </span><br><span class="line">           V   V       V                           V         V     V      </span><br><span class="line">1 thread-&gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--|</span><br></pre></td></tr></table></figure>
<p>需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。</p>
<p>多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//多线程串行</span><br><span class="line">thread1 -&gt; |----A-----|  </span><br><span class="line">                       \  </span><br><span class="line">thread2 ---------------&gt;|-----B-----------|  </span><br><span class="line">                                           \  </span><br><span class="line">thread3 -----------------------------------&gt;|-------C------|</span><br><span class="line">//多线程并发</span><br><span class="line">thread1 -&gt;     |----A-----|</span><br><span class="line">thread2 -----&gt;     |-----B-----------|</span><br><span class="line">thread3 ---------&gt;     |-------C----------|</span><br></pre></td></tr></table></figure>
<h2 id="3）同步（synchronize）、异步（asynchronous）与线程"><a href="#3）同步（synchronize）、异步（asynchronous）与线程" class="headerlink" title="3）同步（synchronize）、异步（asynchronous）与线程"></a>3）同步（synchronize）、异步（asynchronous）与线程</h2><p>同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。</p>
<ul>
<li>同步</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">override viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    dispatch_sync(queue) &#123;</span><br><span class="line">        //block1</span><br><span class="line">        print(&quot;-----1-----&quot;) //1</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;-----2-----&quot;) //2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行//2及以后的代码。输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----1-----</span><br><span class="line">-----2-----</span><br></pre></td></tr></table></figure>
<ul>
<li>异步</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//viewDidLoad()在主线程中执行，因此当前线程为主线程</span><br><span class="line">override viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        //block1</span><br><span class="line">        print(&quot;-----1-----&quot;) //1</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;-----2-----&quot;) //2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行//2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----2-----</span><br><span class="line">-----1-----</span><br></pre></td></tr></table></figure>
<ul>
<li>同异步结合的情形</li>
</ul>
<p>如果同异步结合:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//viewDidLoad()在主线程中执行，因此当前线程为主线程</span><br><span class="line">override viewDidLoad() &#123;</span><br><span class="line">    super.viewDidLoad()</span><br><span class="line">    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span><br><span class="line">    dispatch_async(queue) &#123;</span><br><span class="line">        //block1</span><br><span class="line">        print(&quot;-----A-----&quot;) //1</span><br><span class="line">        dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">            //block2</span><br><span class="line">            print(&quot;-----B-----&quot;) //2</span><br><span class="line">        &#125;</span><br><span class="line">        print(&quot;-----C-----&quot;) //3</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    print(&quot;-----D-----&quot;) //4</span><br><span class="line">    while(true) &#123; &#125; //5</span><br><span class="line">    print(&quot;-----E-----&quot;) //6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行//4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。</p>
<p>block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到//5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到//5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到//5对应的死循环，因此block2很可能不被执行。</p>
<p>//6前有个死循环，因此E一定不会被输出。</p>
<p>因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD</p>
<p>但很可能的输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----D-----</span><br><span class="line">-----A-----</span><br><span class="line">-----C-----</span><br></pre></td></tr></table></figure>
<h2 id="4）同异步与串并行"><a href="#4）同异步与串并行" class="headerlink" title="4）同异步与串并行"></a>4）同异步与串并行</h2><p>串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。<br>就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。</p>
<p>而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。</p>
<p>当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。</p>
<h1 id="三、GCD与NSOperationQueue"><a href="#三、GCD与NSOperationQueue" class="headerlink" title="三、GCD与NSOperationQueue"></a>三、GCD与NSOperationQueue</h1><p>GCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。<br>需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。</p>
<p>关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，推荐<a href="http://www.cocoachina.com/ios/20160201/15179.html" target="_blank" rel="external">《iOS并行开发：从NSOperation和调度队列开始》</a>，其对基本概念、使用方法等的介绍非常清晰详尽，这里就不再赘述，只写一些个人认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html" target="_blank" rel="external">《ConcurrencyProgrammingGuide》</a>是最好的。</p>
<h2 id="1）GCD"><a href="#1）GCD" class="headerlink" title="1）GCD"></a>1）GCD</h2><p>GCD是基于C的API，因此比较底层。</p>
<p>GCD所管理的调度队列（dispatch queue）主要有三类：串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。</p>
<p>我们常用的 dispatch_get_global<em>queue(</em>: _:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。</p>
<p>dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。</p>
<h2 id="2）NSOperationQueue"><a href="#2）NSOperationQueue" class="headerlink" title="2）NSOperationQueue"></a>2）NSOperationQueue</h2><p>NSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。</p>
<p>NSOperationQueue是并发队列，且不遵循先进先出（FIFO）排序原则。</p>
<h1 id="四、总结与感悟"><a href="#四、总结与感悟" class="headerlink" title="四、总结与感悟"></a>四、总结与感悟</h1><p>1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。</p>
<p>2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。</p>
<p>3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。</p>
<p>4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。</p>
<p>5) App的主调度队列是串行单线程队列。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/develop/">移动开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-github-using" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/05/20/github-using/" class="article-date">
  	<time datetime="2016-05-20T14:17:11.000Z" itemprop="datePublished">2016-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/20/github-using/">GitHub 使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="下载github客户端软件"><a href="#下载github客户端软件" class="headerlink" title="下载github客户端软件"></a>下载github客户端软件</h1><ol>
<li>官网<a href="https://help.github.com/" target="_blank" rel="external">下载</a></li>
<li>Google搜索，一般用于windows7以前的系统</li>
</ol>
<h1 id="安装github软件"><a href="#安装github软件" class="headerlink" title="安装github软件"></a>安装github软件</h1><p>根据软件安装指导，按步骤安装即可。</p>
<h1 id="使用git命令提交"><a href="#使用git命令提交" class="headerlink" title="使用git命令提交"></a>使用git命令提交</h1><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Chars Davy&quot;</span><br><span class="line">git config --global user.email chars_d@example.com</span><br></pre></td></tr></table></figure>
<p>重申一遍，只需要做一次这个设置。如果传递了 <code>--global</code> 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要<code>--global</code>选项。</p>
<h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  clone  git://github.com/someone/some_project.git   some_project</span><br></pre></td></tr></table></figure>
<p>上面的命令就是将<code>git://github.com/someone/some_project.git</code>这个URL地址的远程版本库，完全克隆到本地some_project目录下。</p>
<h2 id="git-init-和-git-remote"><a href="#git-init-和-git-remote" class="headerlink" title="git init 和 git remote"></a>git init 和 git remote</h2><p>这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用<code>git init</code>命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用<code>git remote add</code>命令来增加一个远程服务器端，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git  remote  add  origin  git://github.com/someone/another_project.git</span><br></pre></td></tr></table></figure>
<p>上面的命令就会增加URL地址为<code>git: //github.com/someone/another_project.git</code>，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。</p>
<h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add app/model/user.rb</span><br></pre></td></tr></table></figure>
<p>就会增加<code>app/model/user.rb</code>文件到Git的索引中，该功能类似于SVN的add，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure>
<p>上面的命令会将所有改动过的文件及文件夹迭代全部添加进本地代码仓库。</p>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>提交当前工作空间的修改内容，类似于SVN的commit命令，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m story #3, add user model</span><br></pre></td></tr></table></figure>
<p>提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit –m beta</span><br></pre></td></tr></table></figure>
<p>上面的命令会将beta作为log显示在代码提交记录中。</p>
<h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>将本地commit的代码更新到远程版本库中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure>
<p>上面的命令就会将本地的代码更新到名为orgin的远程版本库中。</p>
<h1 id="git代码提交中可能遇到的问题"><a href="#git代码提交中可能遇到的问题" class="headerlink" title="git代码提交中可能遇到的问题"></a>git代码提交中可能遇到的问题</h1><p>问题1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You can&apos;t push to git://github.com/example/example_pro.git</span><br><span class="line">Use https://github.com/ example/example_pro.git</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br><span class="line">git remote add origin git@github.com:user_name/user_repo.git</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure>
<p>原因：</p>
<p>如果在<code>git clone</code>的时候用的是<code>git://github.com:xx/xxx.git</code> 的形式, 那么就会出现这个问题，因为这个protocol是不支持push的，而使用<code>git clone git@github.com:lujinjianst/myNCCL.git</code>就可以用git push。</p>
<p>问题2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Permission denied(publickey).</span><br><span class="line">fatal:Could not read from remote repository.</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<p>在终端输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;chars&quot;//注意,chars为用户名</span><br></pre></td></tr></table></figure>
<p>如果执行成功。返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Generating public/private rsa key pair. </span><br><span class="line">Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa):</span><br></pre></td></tr></table></figure>
<p>在这里就是设置存储地址了.反正我是直接按的回车,然后还会返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty for no passphrase):</span><br></pre></td></tr></table></figure>
<p>再次直接回车。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter same passphrase again:</span><br></pre></td></tr></table></figure>
<p>再次回车。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Your identification has been saved in /home/forwhat.cn/.ssh/id_rsa. </span><br><span class="line">Your public key has been saved in /home/forwhat.cn/.ssh/id_rsa.pub. </span><br><span class="line">The key fingerprint is:</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The key&apos;s randomart image is: </span><br><span class="line">+--[ RSA 2048]----+ </span><br><span class="line">|                 | </span><br><span class="line">|                 | </span><br><span class="line">|                 | </span><br><span class="line">|    o            | </span><br><span class="line">|   + .  S        | </span><br><span class="line">|  . = .  o       | </span><br><span class="line">|   o + +o.o      | </span><br><span class="line">|E o . o.=+.      | </span><br><span class="line">|.+   ==+ooo.     | </span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure>
<p>这样SSH key就生成了。直接cat一下就好了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:~/a$ cat /home/forwhat.cn/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>把显示出来的直接添加到github账户设置里边的SSH keys。<br>回来再git pull就开始远程拷贝代码了。</p>
<p>原因：</p>
<p>没有在github账号添加SSH key。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/tool/">工具</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-uniform-random" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/30/uniform-random/" class="article-date">
  	<time datetime="2016-04-30T01:37:10.000Z" itemprop="datePublished">2016-04-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/30/uniform-random/">均匀分布随机函数的实现</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随机函数就是产生数的函数，C语言里使用rand(),srand()等随机函数实现随机数生成。</p>
<h1 id="函数简介"><a href="#函数简介" class="headerlink" title="函数简介"></a>函数简介</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int rand( void );</span><br></pre></td></tr></table></figure>
<p>返回的是一个界于0～32767（0x7FFF）之间的伪随机数，包括0和32767。<br>C预先生成一组随机数，每次调用随机函数时从指针所指向的位置开始取值，因此使用rand()重复运行程序产生的随机数都是相同的，可以通过srand()函数来改变指针位置。<br>srand()会设置供rand()使用的随机数种子。如果在第一次使用rand()之前没有调用srand()，那么系统会自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void srand( unsigned int seed );</span><br></pre></td></tr></table></figure>
<p>改变随机数表的指针位置（用seed变量控制）。<br>使用系统定时/计数器的值作为随机种子。每个种子对应一组根据算法预先生成的随机数，所以，在相同的平台环境下，不同时间产生的随机数会是不同的，相应的，若将srand（unsigned）time(NULL)改为srand(TP)（TP为任一常量），则无论何时运行、运行多少次得到的“随机数”都会是一组固定的序列，因此srand生成的随机数是伪随机数。<br>一般配合time(NULL)使用，因为时间每时每刻都在改变，产生的seed值都不同。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>使用rand函数生成的随机数严格满足正态分布。而在很多时候，我们希望随机数的生成不要满足正态分布，特别是在处理网络通信报文的时候。<br>例如，我们需要在交换机处理到海量报文时，能够使远端的从设备尽可能的分段同时向局端回应报文，以减轻局部报文处理压力。</p>
<h1 id="均匀分布随机函数实现"><a href="#均匀分布随机函数实现" class="headerlink" title="均匀分布随机函数实现"></a>均匀分布随机函数实现</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p><img src="http://upload-images.jianshu.io/upload_images/1492739-b2f082073e33ca94.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="开发环境"></p>
<h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><p>1）打开Qt Creater，创建GUI工程<br><img src="http://upload-images.jianshu.io/upload_images/1492739-1c06b87e7e219e93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建GUI工程"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1492739-4b288fe958b3e962.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目文件结构"></p>
<p>2）在mainwindow.h中添加函数声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void paintEvent(QPaintEvent *);</span><br></pre></td></tr></table></figure>
<p>3）在mainwindow.cpp中添加函数实现</p>
<p>导入头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QPainter&gt;</span><br></pre></td></tr></table></figure>
<p>实现<code>void paintEvent(QPaintEvent *)</code>函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。</span><br><span class="line"> *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。</span><br><span class="line">*/</span><br><span class="line">void MainWindow::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    QPainter painter(this);</span><br><span class="line">    QPen pen; //画笔</span><br><span class="line">    pen.setColor(QColor(255,0,0)); //设置画笔颜色</span><br><span class="line">    painter.setPen(pen); //添加画笔</span><br><span class="line"></span><br><span class="line">    long int r[kSum] = &#123;0&#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        r[i] = Uniform(0, 300);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;while(i &lt; kSum);</span><br><span class="line"></span><br><span class="line">    while((j + 30) &lt; (kSum + 30))&#123;</span><br><span class="line">        painter.drawPoint(j, r[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4）添加随机函数实现代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define kSum 1000</span><br><span class="line">//算法一</span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数均匀化</span><br><span class="line">*/</span><br><span class="line">double _uniform(double min, double max, long int *seed) &#123;</span><br><span class="line">    double t = 0;</span><br><span class="line">    *seed = 2045 * (*seed) + 1;</span><br><span class="line">    *seed = *seed - (*seed / 1048576) * 1048576;</span><br><span class="line">    t = (*seed) / 1048576.0;</span><br><span class="line">    t = min + (max - min) * t;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数产生随机数</span><br><span class="line">*/</span><br><span class="line">long int Uniform(double min, double max) &#123;</span><br><span class="line">    long int s = 0;</span><br><span class="line">    double r = 0;</span><br><span class="line"></span><br><span class="line">    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/</span><br><span class="line">    s = rand();</span><br><span class="line">    r = _uniform(min, max, &amp;s);</span><br><span class="line"></span><br><span class="line">    return ((long int)r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//算法二</span><br><span class="line">double AverageRandom(double min, double max) &#123;</span><br><span class="line">    int minInteger = (int)(min * 10000);</span><br><span class="line">    int maxInteger = (int)(max * 10000);</span><br><span class="line">    int randInteger = rand() * rand();</span><br><span class="line">    int diffInteger = maxInteger - minInteger;</span><br><span class="line">    int resultInteger = randInteger % diffInteger + minInteger;</span><br><span class="line"></span><br><span class="line">    return (resultInteger/10000.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="http://upload-images.jianshu.io/upload_images/1492739-af95ccbacb9b3231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现效果"></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>从图中可以看出，使用上述函数生成的随机数符合均匀分布。<br>本案例主要使用了Qt的绘图功能，用来直观展示生成随机数的效果。检验随机函数生成随机数的效果。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>最后附上该算法实现的全部代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//mainwindow.h</span><br><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">namespace Ui &#123;</span><br><span class="line">class MainWindow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    explicit MainWindow(QWidget *parent = 0);</span><br><span class="line">    ~MainWindow();</span><br><span class="line">    void paintEvent(QPaintEvent *);</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // MAINWINDOW_H</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">//mainwindow.cpp</span><br><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line">#include &lt;QPainter&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define kSum 1000</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数均匀化</span><br><span class="line">*/</span><br><span class="line">double _uniform(double min, double max, long int *seed) &#123;</span><br><span class="line">    double t = 0;</span><br><span class="line">    *seed = 2045 * (*seed) + 1;</span><br><span class="line">    *seed = *seed - (*seed / 1048576) * 1048576;</span><br><span class="line">    t = (*seed) / 1048576.0;</span><br><span class="line">    t = min + (max - min) * t;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *均匀分布随机函数产生随机数</span><br><span class="line">*/</span><br><span class="line">long int Uniform(double min, double max) &#123;</span><br><span class="line">    long int s = 0;</span><br><span class="line">    double r = 0;</span><br><span class="line"></span><br><span class="line">    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/</span><br><span class="line">    s = rand();</span><br><span class="line">    r = _uniform(min, max, &amp;s);</span><br><span class="line"></span><br><span class="line">    return ((long int)r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。</span><br><span class="line"> *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。</span><br><span class="line">*/</span><br><span class="line">void MainWindow::paintEvent(QPaintEvent *)</span><br><span class="line">&#123;</span><br><span class="line">    QPainter painter(this);</span><br><span class="line">    QPen pen; //画笔</span><br><span class="line">    pen.setColor(QColor(255,0,0)); //设置画笔颜色</span><br><span class="line">    painter.setPen(pen); //添加画笔</span><br><span class="line"></span><br><span class="line">    long int r[kSum] = &#123;0&#125;;</span><br><span class="line">    int i = 0;</span><br><span class="line">    int j = 0;</span><br><span class="line"></span><br><span class="line">    do&#123;</span><br><span class="line">        r[i] = Uniform(0, 300);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;while(i &lt; kSum);</span><br><span class="line"></span><br><span class="line">    while((j + 30) &lt; (kSum + 30))&#123;</span><br><span class="line">        painter.drawPoint(j, r[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//main.cpp</span><br><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line"></span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/algorithm/">算法</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/advance/">进阶</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/10/hello-world/" class="article-date">
  	<time datetime="2016-04-10T10:32:15.000Z" itemprop="datePublished">2016-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/10/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/apply/">应用实战</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Chars Davy
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a>
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script language="javascript" type="text/javascript" src="http://js.users.51.la/18878021.js"></script>
<noscript><a href="http://www.51.la/?18878021" target="_blank"><img alt="&#x6211;&#x8981;&#x5566;&#x514D;&#x8D39;&#x7EDF;&#x8BA1;" src="http://img.users.51.la/18878021.asp" style="border:none" /></a></noscript>

  </div>
</body>
</html>