<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
  Jekyll integration by somiibo.com
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
--><html>
	<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

<title>Python 学习 基础篇</title>
<meta name="description" content="">

<link rel="apple-touch-icon" sizes="180x180" href="/assets/icon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/icon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/icon/favicon-16x16.png">
<link rel="manifest" href="/assets/icon/manifest.json">
<link rel="mask-icon" href="/assets/icon/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/icon/favicon.ico">
<meta name="msapplication-config" content="/assets/icon/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

<!-- CSS -->
<link rel="stylesheet" href="/assets/css/main.css">
<noscript><link rel="stylesheet" href="/assets/css/noscript.css"></noscript>

	</head>
	<body class="is-loading">

		<!-- Wrapper -->
			<div id="wrapper" class="fade-in">

				<!-- Header -->
        <header id="header">
          <a href="/" class="logo">Chars's Tech Blog</a>
        </header>

				<!-- Nav -->
					<nav id="nav">

            <ul class="links">
  <li class=""><a href="/">Home</a></li>
  <li class=" active "><a href="/blog/">Blog</a></li>
  <li class=""><a href="/tags/">Tags</a></li>
  <li class=""><a href="/categories/">Categories</a></li>
  <li class=""><a href="/about/">About</a></li>
<!--   <li class=""><a href="/elements/">Elements Reference</a></li> -->
</ul>


						<ul class="icons">
              <li><a href="https://twitter.com/charsdavy" class="icon fa-twitter" rel="nofollow"><span class="label">Twitter</span></a></li>
              <li><a href="https://facebook.com/wei.deng.1460" class="icon fa-facebook" rel="nofollow"><span class="label">Facebook</span></a></li>
              <li><a href="https://instagram.com/chars.davy" class="icon fa-instagram" rel="nofollow"><span class="label">Instagram</span></a></li>
              <li><a href="https://github.com/charsdavy" class="icon fa-github" rel="nofollow"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
				<div id="main">
          <section class="post">
    				<header class="major">
      				<span class="date">22 Apr 2017</span>
      				<h1>Python 学习 基础篇</h1>
      				<!-- <p><p>全世界大概有几百种编程语言，而其中著名的只有十几种。Python就是著名编程语言之一。它起源于“龟叔”（Guido van Rossum，荷兰人）在1989年圣诞节间的无聊，而为了打发时间所创造。</p>

</p> -->
      			</header>
      			<div class="image main"><img src="" alt=""></div>
      			<p></p>
<p>全世界大概有几百种编程语言，而其中著名的只有十几种。Python就是著名编程语言之一。它起源于“龟叔”（Guido van Rossum，荷兰人）在1989年圣诞节间的无聊，而为了打发时间所创造。</p>

<p>可见业余时间比工作时间创造出来的东西更容易出名哈，当然，这是开玩笑的。“龟叔”赋予Python“优雅、明确、简单”的特点。</p>

<p>那么，Python适合做什么呢？它主要适用领域：Web网站和各种网络服务（YouTube、Instagram、douban、openstack）；系统工具和脚本；作为“胶水”语言把其它语言开发的模块包装起来方便使用。</p>

<p>优点是显著的，但是也少不了缺点。Python不适用的领域：贴近硬件的代码（首选C）；移动开发（iOS／Android都有各自的开发语言）；因为不能做到告诉渲染，所以不适合游戏开发（首选C／C++）。</p>

<h2 id="python和其它语言对比">Python和其它语言对比</h2>

<table>
  <thead>
    <tr>
      <th>语言</th>
      <th>类型</th>
      <th>运行速度</th>
      <th>代码量</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>C</td>
      <td>编译为机器码</td>
      <td>非常快</td>
      <td>非常多</td>
    </tr>
    <tr>
      <td>Java</td>
      <td>编译为字节码</td>
      <td>快</td>
      <td>多</td>
    </tr>
    <tr>
      <td>Python</td>
      <td>解释执行</td>
      <td>慢</td>
      <td>少</td>
    </tr>
  </tbody>
</table>

<p>CPU越来越快，程序的运行速度瓶颈往往不在Python的执行，更多受到网络速度和硬盘速度的制约。</p>

<p>另外，Python发布程序即发布源代码。</p>

<h2 id="安装python">安装Python</h2>

<p>前往<a href="http://www.python.org">官网下载</a>对应平台对应工具。另外Python2.7版本和3.3版本并不兼容，所以开发时请注意使用Python的版本。</p>

<p>作为Mac OS X使用者，其实更推荐<a href="https://www.jetbrains.com/pycharm/">PyCharm IDE</a>。安装之后直接使用即可。</p>

<h2 id="数据类型">数据类型</h2>

<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：</p>

<h3 id="整数">整数</h3>

<p>Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。</p>

<p>计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。</p>

<h3 id="浮点数">浮点数</h3>

<p>浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9 和 12.3x10^8 是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9 就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。</p>

<p>整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。</p>

<h3 id="字符串">字符串</h3>

<p>字符串是以’‘或”“括起来的任意文本，比如’abc’，”xyz”等等。请注意，’‘或”“本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。</p>

<h3 id="布尔值">布尔值</h3>

<p>布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。</p>

<p>布尔值可以用and、or和not运算。</p>

<p>and运算是与运算，只有所有都为 True，and运算结果才是 True。</p>

<p>or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。</p>

<p>not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。</p>

<h3 id="空值">空值</h3>

<p>空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。</p>

<p>此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型。</p>

<h2 id="print-语句">print 语句</h2>

<p>print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print 'hello, world'
</code></pre>
</div>

<p>注意：</p>

<p>1.当我们在Python交互式环境下编写代码时，»&gt;是Python解释器的提示符，不是代码的一部分。</p>

<p>2.当我们在文本编辑器中编写代码时，千万不要自己添加 »&gt;。</p>

<p>print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print 'The quick brown fox', 'jumps over', 'the lazy dog'
The quick brown fox jumps over the lazy dog
</code></pre>
</div>

<p>print会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-1.jpg" alt="print解释图"></p>

<p>print也可以打印整数，或者计算结果：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print 300
300    #运行结果
&gt;&gt;&gt; print 100 + 200
300    #运行结果
</code></pre>
</div>

<p>因此，我们可以把计算100 + 200的结果打印得更漂亮一点：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print '100 + 200 =', 100 + 200
100 + 200 = 300     #运行结果
</code></pre>
</div>

<p>注意: 对于100 + 200，Python解释器自动计算出结果300，但是，’100 + 200 =’是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。</p>

<h2 id="python的注释">Python的注释</h2>
<p>任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。</p>

<p>Python的注释以<code class="highlighter-rouge"> # </code>开头，后面的文字直到行尾都算注释</p>

<div class="highlighter-rouge">
<pre class="highlight"><code># 这一行全部都是注释...
print 'hello' # 这也是注释
</code></pre>
</div>

<p>注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code># 暂时不想运行下面一行代码:
# print 'hello, python.'
</code></pre>
</div>

<h2 id="变量">变量</h2>

<p>在Python中，变量的概念基本上和初中代数的方程变量是一致的。</p>

<p>例如，对于方程式<code class="highlighter-rouge"> y=x*x </code>，x就是变量。当<code class="highlighter-rouge">x=2</code>时，计算结果是4，当<code class="highlighter-rouge">x=5</code>时，计算结果是25。</p>

<p>只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。</p>

<p>在Python程序中，变量是用一个变量名表示，变量名必须是<strong>大小写英文、数字和下划线（_）的组合，且不能用数字开头</strong>，比如：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>a = 1
</code></pre>
</div>

<p>变量<code class="highlighter-rouge">a</code>是一个整数。</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>t_007 = 'T007'
</code></pre>
</div>

<p>变量<code class="highlighter-rouge">t_007</code>是一个字符串。</p>

<p>在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>a = 123    # a是整数
print a
a = 'Chars'   # a变为字符串
print a
</code></pre>
</div>

<p>这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。</p>

<p>静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>int a = 123; // a是整数类型变量
a = "Chars"; // 错误：不能把字符串赋给整型变量
</code></pre>
</div>

<p>和静态语言相比，动态语言更灵活，就是这个原因。</p>

<p>请不要把赋值语句的等号等同于数学的等号。比如下面的代码：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>x = 10
x = x + 2
</code></pre>
</div>

<p>如果从数学上理解<code class="highlighter-rouge">x = x + 2</code>那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式<code class="highlighter-rouge">x + 2</code>，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。</p>

<p>最后，理解变量在计算机内存中的表示也非常重要。当我们写：<code class="highlighter-rouge">a = 'ABC'</code>时，Python解释器干了两件事情：</p>

<ol>
  <li>
    <p>在内存中创建了一个’ABC’的字符串；</p>
  </li>
  <li>
    <p>在内存中创建了一个名为a的变量，并把它指向’ABC’。</p>
  </li>
</ol>

<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>a = 'ABC'
b = a
a = 'XYZ'
print b
</code></pre>
</div>

<p>最后一行打印出变量b的内容到底是<code class="highlighter-rouge">'ABC'</code>呢还是<code class="highlighter-rouge">'XYZ'</code>？如果从数学意义上理解，就会错误地得出b和a相同，也应该是<code class="highlighter-rouge">'XYZ'</code>，但实际上b的值是<code class="highlighter-rouge">'ABC'</code>，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p>

<p>执行<code class="highlighter-rouge">a = 'ABC'</code>，解释器创建了字符串<code class="highlighter-rouge"> 'ABC'</code>和变量<code class="highlighter-rouge"> a</code>，并把a指向<code class="highlighter-rouge"> 'ABC'</code>：</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-2.jpg" alt="变量图1"></p>

<p>执行<code class="highlighter-rouge">b = a</code>，解释器创建了变量 b，并把b指向 a 指向的字符串<code class="highlighter-rouge">'ABC'</code>：</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-3.jpg" alt="变量图2"></p>

<p>执行<code class="highlighter-rouge">a = 'XYZ'</code>，解释器创建了字符串<code class="highlighter-rouge">'XYZ'</code>，并把a的指向改为<code class="highlighter-rouge">'XYZ'</code>，但b并没有更改：</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-4.jpg" alt="变量图3"></p>

<p>所以，最后打印变量b的结果自然是<code class="highlighter-rouge">'ABC'</code>了。</p>

<h2 id="字符串-1">字符串</h2>

<h3 id="定义字符串">定义字符串</h3>

<p>前面我们讲解了什么是字符串。字符串可以用<code class="highlighter-rouge">''</code>或者<code class="highlighter-rouge">""</code>括起来表示。</p>

<p>如果字符串本身包含’怎么办？比如我们要表示字符串 <code class="highlighter-rouge">I'm OK </code>，这时，可以用<code class="highlighter-rouge">" "</code>括起来表示：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>"I'm OK"
</code></pre>
</div>

<p>类似的，如果字符串包含”，我们就可以用’ ‘括起来表示：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>'Learn "Python" in Chars's Blog'
</code></pre>
</div>

<p>如果字符串既包含’又包含”怎么办？</p>

<p>这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用<code class="highlighter-rouge">\</code>进行转义。</p>

<p>要表示字符串 <code class="highlighter-rouge">Bob said "I'm OK"</code>.
由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个<code class="highlighter-rouge">\</code>表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>'Bob said \"I\'m OK\".'
</code></pre>
</div>

<p>注意：转义字符 \ 不计入字符串的内容中。</p>

<p>常用的转义字符还有：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>\n 表示换行
\t 表示一个制表符
\\ 表示 \ 字符本身
</code></pre>
</div>

<h3 id="raw字符串与多行字符串">raw字符串与多行字符串</h3>

<p>如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀<code class="highlighter-rouge"> r </code>，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>r'\(~_~)/ \(~_~)/'
</code></pre>
</div>

<p>但是<code class="highlighter-rouge">r'...'</code>表示法不能表示多行字符串，也不能表示包含<code class="highlighter-rouge">'</code>和 <code class="highlighter-rouge">"</code>的字符串（为什么？）</p>

<p>如果要表示多行字符串，可以用<code class="highlighter-rouge">'''...'''</code>表示：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>'''Line 1
Line 2
Line 3'''
</code></pre>
</div>

<p>上面这个字符串的表示方法和下面的是完全一样的：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>'Line 1\nLine 2\nLine 3'
</code></pre>
</div>

<p>还可以在多行字符串前面添加<code class="highlighter-rouge"> r </code>，把这个多行字符串也变成一个raw字符串：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>r'''Python is created by "Guido".
It is free and easy to learn.
Let's start learn Python in Chars's Blog!'''
</code></pre>
</div>

<h3 id="unicode字符串">Unicode字符串</h3>

<p>字符串还有一个编码问题。</p>

<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。</p>

<p>如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>

<p>类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>

<p>Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。</p>

<p>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。</p>

<p>Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…‘表示，比如：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>print u'中文'
中文
</code></pre>
</div>

<p>注意: 不加 u ，中文就不能正常显示。</p>

<p>Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：</p>

<p>转义：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>u'中文\n日文\n韩文'
</code></pre>
</div>

<p>多行：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>u'''第一行
第二行'''
</code></pre>
</div>

<p>raw+多行：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>ur'''Python的Unicode字符串支持"中文",
"日文",
"韩文"等多种语言'''
</code></pre>
</div>

<p>如果中文字符串在Python环境下遇到<code class="highlighter-rouge"> UnicodeDecodeError</code>，这是因为.py文件保存的格式有问题。可以在第一行添加注释</p>

<div class="highlighter-rouge">
<pre class="highlight"><code># -*- coding: utf-8 -*-
</code></pre>
</div>

<p>目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。</p>

<h2 id="list">List</h2>

<h3 id="创建list">创建list</h3>

<p>Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。</p>

<p>比如，列出班里所有同学的名字，就可以用一个list表示：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; ['Michael', 'Bob', 'Tracy']
['Michael', 'Bob', 'Tracy']
</code></pre>
</div>

<p>list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。</p>

<p>构造list非常简单，按照上面的代码，直接用 [ ] 把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']
&gt;&gt;&gt; classmates # 打印classmates变量的内容
['Michael', 'Bob', 'Tracy']
</code></pre>
</div>

<p>由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Michael', 100, True]
</code></pre>
</div>

<p>一个元素也没有的list，就是空list：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; empty_list = []
</code></pre>
</div>

<h3 id="按照索引访问list">按照索引访问list</h3>

<p>由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。</p>

<p>需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。</p>

<p>因此，要打印第一名同学的名字，用 L[0]:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print L[0]
Adam
</code></pre>
</div>

<p>要打印第二名同学的名字，用 L[1]:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print L[1]
Lisa
</code></pre>
</div>

<p>要打印第三名同学的名字，用 L[2]:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print L[2]
Bart
</code></pre>
</div>

<p>要打印第四名同学的名字，用 L[3]:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print L[3]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
</div>

<p>报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。</p>

<p>所以，使用索引时，<strong>千万注意不要越界</strong>。</p>

<h3 id="倒序访问list">倒序访问list</h3>

<p>我们还是用一个list按分数从高到低表示出班里的3个同学：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>这时，老师说，请分数最低的同学站出来。</p>

<p>要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print L[2]
Bart
</code></pre>
</div>

<p>有没有更简单的方法？有！</p>

<p>Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print L[-1]
Bart
</code></pre>
</div>

<p>Bart同学表示躺枪。</p>

<p>类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print L[-2]
Lisa
&gt;&gt;&gt; print L[-3]
Adam
&gt;&gt;&gt; print L[-4]
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: list index out of range
</code></pre>
</div>

<p>L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。</p>

<p>使用倒序索引时，也要<strong>注意不要越界</strong>。</p>

<h3 id="添加新元素">添加新元素</h3>

<p>现在，班里有3名同学：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？</p>

<p>第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']
&gt;&gt;&gt; L.append('Paul')
&gt;&gt;&gt; print L
['Adam', 'Lisa', 'Bart', 'Paul']
</code></pre>
</div>

<p>append()总是把新的元素添加到 list 的尾部。</p>

<p>如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？</p>

<p>方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']
&gt;&gt;&gt; L.insert(0, 'Paul')
&gt;&gt;&gt; print L
['Paul', 'Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。</p>

<h3 id="删除元素">删除元素</h3>

<p>Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？</p>

<p>如果Paul同学排在最后一个，我们可以用list的pop()方法删除：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']
&gt;&gt;&gt; L.pop()
'Paul'
&gt;&gt;&gt; print L
['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。</p>

<p>如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Paul', 'Bart']
</code></pre>
</div>

<p>要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L.pop(2)
'Paul'
&gt;&gt;&gt; print L
['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<h3 id="替换元素">替换元素</h3>

<p>假设现在班里仍然是3名同学：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。</p>

<p>另一个办法是直接用Paul把Bart给替换掉：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[2] = 'Paul'
&gt;&gt;&gt; print L
L = ['Adam', 'Lisa', 'Paul']
</code></pre>
</div>

<p>对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。</p>

<p>由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[-1] = 'Paul'
</code></pre>
</div>

<h2 id="tuple">Tuple</h2>

<h3 id="创建tuple">创建tuple</h3>

<p>tuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。</p>

<p>同样是表示班里同学的名称，用tuple表示如下：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; t = ('Adam', 'Lisa', 'Bart')
</code></pre>
</div>

<p>创建tuple和创建list唯一不同之处是用( )替代了[ ]。</p>

<p>现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。</p>

<p>获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; t[0] = 'Paul'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment
</code></pre>
</div>

<h3 id="创建单元素tuple">创建单元素tuple</h3>

<p>tuple和list一样，可以包含 0 个、1个和任意多个元素。</p>

<p>包含多个元素的 tuple，前面我们已经创建过了。</p>

<p>包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; t = ()
&gt;&gt;&gt; print t
()
</code></pre>
</div>

<p>创建包含1个元素的 tuple 呢？来试试：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; t = (1)
&gt;&gt;&gt; print t
1
</code></pre>
</div>

<p>好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？</p>

<p>因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。</p>

<p>正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; t = (1,)
&gt;&gt;&gt; print t
(1,)
</code></pre>
</div>

<h3 id="可变的tuple">可变的tuple</h3>

<p>前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])
</code></pre>
</div>

<p>注意到 t 有 3 个元素：’a’，’b’和一个list：[‘A’, ‘B’]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = t[2]
</code></pre>
</div>

<p>然后，我们把list的两个元素改一改：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[0] = 'X'
&gt;&gt;&gt; L[1] = 'Y'
</code></pre>
</div>

<p>再看看tuple的内容：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print t
('a', 'b', ['X', 'Y'])
</code></pre>
</div>

<p>不是说tuple一旦定义后就不可变了吗？怎么现在又变了？</p>

<p>别急，我们先看看定义的时候tuple包含的3个元素：</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-5.jpg" alt="tuple图1"></p>

<p>当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：</p>

<p><img src="http://o88e8any8.bkt.clouddn.com/python-basic-knowledge-6.jpg" alt="tuple图2"></p>

<p>表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。</p>

<p>tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p>

<p>理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>

<h2 id="条件判断和循环">条件判断和循环</h2>

<h3 id="条件判断">条件判断</h3>

<p>计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。</p>

<h4 id="if语句">if语句</h4>

<p>比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>age = 20
if age &gt;= 18:
    print 'your age is', age
    print 'adult'
print 'END'
</code></pre>
</div>

<p>注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。</p>

<p>缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。</p>

<p>注意: if 语句后接表达式，然后用:表示代码块开始。</p>

<p>如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; age = 20
&gt;&gt;&gt; if age &gt;= 18:
...     print 'your age is', age
...     print 'adult'
...
your age is 20
adult
</code></pre>
</div>

<h4 id="if-else语句">if-else语句</h4>

<p>当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if age &gt;= 18:
    print 'adult'
</code></pre>
</div>

<p>如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？</p>

<p>方法是再写一个 if:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if age &lt; 18:
    print 'teenager'
</code></pre>
</div>

<p>或者用 not 运算：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if not age &gt;= 18:
    print 'teenager'
</code></pre>
</div>

<p>细心的读者可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 <code class="highlighter-rouge">if ... else ... </code>语句把它们统一起来：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if age &gt;= 18:
    print 'adult'
else:
    print 'teenager'
</code></pre>
</div>

<p>利用<code class="highlighter-rouge"> if ... else ... </code>语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。</p>

<p>注意: else 后面有个“:”。</p>

<h4 id="if-elif-else语句">if-elif-else语句</h4>

<p>有的时候，一个<code class="highlighter-rouge"> if ... else ... </code>还不够用。比如，根据年龄的划分：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>条件1：18岁或以上：adult
条件2：6岁或以上：teenager
条件3：6岁以下：kid
</code></pre>
</div>

<p>我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if age &gt;= 18:
    print 'adult'
else:
    if age &gt;= 6:
        print 'teenager'
    else:
        print 'kid'
</code></pre>
</div>

<p>这样写出来，我们就得到了一个两层嵌套的<code class="highlighter-rouge"> if ... else ... </code>语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if age &gt;= 18:
    print 'adult'
else:
    if age &gt;= 6:
        print 'teenager'
    else:
        if age &gt;= 3:
            print 'kid'
        else:
            print 'baby'
</code></pre>
</div>

<p>这种缩进只会越来越多，代码也会越来越难看。</p>

<p>要避免嵌套结构的<code class="highlighter-rouge"> if ... else ...</code>，我们可以用<code class="highlighter-rouge"> if ... </code>多个<code class="highlighter-rouge">elif ... else ... </code>的结构，一次写完所有的规则：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if age &gt;= 18:
    print 'adult'
elif age &gt;= 6:
    print 'teenager'
elif age &gt;= 3:
    print 'kid'
else:
    print 'baby'
</code></pre>
</div>

<p>elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。</p>

<p>特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。</p>

<h3 id="循环">循环</h3>

<h4 id="for循环">for循环</h4>

<p>list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>L = ['Adam', 'Lisa', 'Bart']
print L[0]
print L[1]
print L[2]
</code></pre>
</div>

<p>如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。</p>

<p>这时，循环就派上用场了。</p>

<p>Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>L = ['Adam', 'Lisa', 'Bart']
for name in L:
    print name
</code></pre>
</div>

<p>注意:  name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。</p>

<p>这样一来，遍历一个list或tuple就非常容易了。</p>

<h4 id="while循环">while循环</h4>

<p>和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。</p>

<p>比如要从 0 开始打印不大于 N 的整数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>N = 10
x = 0
while x &lt; N:
    print x
    x = x + 1
</code></pre>
</div>

<p>while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。</p>

<p>在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。</p>

<p>如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。</p>

<h4 id="break退出循环">break退出循环</h4>

<p>用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。</p>

<p>比如计算1至100的整数和，我们用while来实现：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>sum = 0
x = 1
while True:
    sum = sum + x
    x = x + 1
    if x &gt; 100:
        break
print sum
</code></pre>
</div>

<p>咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。</p>

<h4 id="continue继续循环">continue继续循环</h4>

<p>在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。</p>

<p>假设我们已经写好了利用for循环计算平均分的代码：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>L = [75, 98, 59, 81, 66, 43, 69, 85]
sum = 0.0
n = 0
for x in L:
    sum = sum + x
    n = n + 1
print sum / n
</code></pre>
</div>

<p>现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>for x in L:
    if x &lt; 60:
        continue
    sum = sum + x
    n = n + 1
</code></pre>
</div>

<h4 id="多重循环">多重循环</h4>

<p>在循环内部，还可以嵌套循环，我们来看一个例子：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>for x in ['A', 'B', 'C']:
    for y in ['1', '2', '3']:
        print x + y
</code></pre>
</div>

<p>x 每循环一次，y 就会循环 3 次。</p>

<h2 id="dict类型">Dict类型</h2>

<p>我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>或者考试的成绩列表：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>[95, 85, 59]
</code></pre>
</div>

<p>但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。</p>

<p>如果把名字和分数关联起来，组成类似的查找表：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>'Adam' ==&gt; 95
'Lisa' ==&gt; 85
'Bart' ==&gt; 59
</code></pre>
</div>

<p>给定一个名字，就可以直接查到分数。</p>

<p>Python的 dict 就是专门干这件事的。用 dict 表示“名字”-“成绩”的查找表如下：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
</code></pre>
</div>

<p>我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。</p>

<p>花括号 {} 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。</p>

<p>由于dict也是集合，len() 函数可以计算任意集合的大小：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; len(d)
3
</code></pre>
</div>

<p>注意: 一个 key-value 算一个，因此，dict大小为3。</p>

<h3 id="访问dict">访问Dict</h3>

<p>我们已经能创建一个dict，用于表示名字和成绩的对应关系：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
</code></pre>
</div>

<p>那么，如何根据名字来查找对应的成绩呢？</p>

<p>可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print d['Adam']
95
&gt;&gt;&gt; print d['Paul']
Traceback (most recent call last):
  File "index.py", line 11, in &lt;module&gt;
    print d['Paul']
KeyError: 'Paul'
</code></pre>
</div>

<p>注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。</p>

<p>要避免 KeyError 发生，有两个办法：</p>

<p>一是先判断一下 key 是否存在，用 in 操作符：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if 'Paul' in d:
    print d['Paul']
</code></pre>
</div>

<p>如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。</p>

<p>二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print d.get('Bart')
59
&gt;&gt;&gt; print d.get('Paul')
None
</code></pre>
</div>

<h3 id="dict特点">Dict特点</h3>

<p>dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。</p>

<p>不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。</p>

<p>由于dict是按 key 查找，所以，在一个dict中，key不能重复。</p>

<p>dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
</code></pre>
</div>

<p>当我们试图打印这个dict时：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print d
{'Lisa': 85, 'Adam': 95, 'Bart': 59}
</code></pre>
</div>

<p>打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。</p>

<p>dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。</p>

<p>可以试试用list作为key时会报什么样的错误。</p>

<p>不可变这个限制仅作用于key，value是否可变无所谓：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="err">'123':</span><span class="w"> </span><span class="err">[1,</span><span class="w"> </span><span class="err">2,</span><span class="w"> </span><span class="err">3],</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="err">key</span><span class="w"> </span><span class="err">是</span><span class="w"> </span><span class="err">str，value是list</span><span class="w">
    </span><span class="err">123:</span><span class="w"> </span><span class="err">'123',</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="err">key</span><span class="w"> </span><span class="err">是</span><span class="w"> </span><span class="err">int，value</span><span class="w"> </span><span class="err">是</span><span class="w"> </span><span class="err">str</span><span class="w">
    </span><span class="err">('a',</span><span class="w"> </span><span class="err">'b'):</span><span class="w"> </span><span class="err">True</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="err">key</span><span class="w"> </span><span class="err">是</span><span class="w"> </span><span class="err">tuple，并且tuple的每个元素都是不可变对象，value是</span><span class="w"> </span><span class="err">boolean</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>最常用的key还是字符串，因为用起来最方便。</p>

<h3 id="更新dict">更新Dict</h3>

<p>dict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>d = {
    'Adam': 95,
    'Lisa': 85,
    'Bart': 59
}
</code></pre>
</div>

<p>要把新同学’Paul’的成绩 72 加进去，用赋值语句：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; d['Paul'] = 72
</code></pre>
</div>

<p>再看看dict的内容：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print d
{'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 59}
</code></pre>
</div>

<p>如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; d['Bart'] = 60
&gt;&gt;&gt; print d
{'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 60}
</code></pre>
</div>

<h3 id="遍历dict">遍历Dict</h3>

<p>由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。</p>

<p>直接使用for循环可以遍历 dict 的 key：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
&gt;&gt;&gt; for key in d:
...     print key
... 
Lisa
Adam
Bart
</code></pre>
</div>

<p>由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。</p>

<h2 id="set类型">Set类型</h2>

<p>dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。</p>

<p>有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。</p>

<p>set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。</p>

<p>创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set(['A', 'B', 'C'])
</code></pre>
</div>

<p>可以查看 set 的内容：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; print s
set(['A', 'C', 'B'])
</code></pre>
</div>

<p>请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。</p>

<p>因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set(['A', 'B', 'C', 'C'])
&gt;&gt;&gt; print s
set(['A', 'C', 'B'])
&gt;&gt;&gt; len(s)
3
</code></pre>
</div>

<p>结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。</p>

<h3 id="访问set">访问Set</h3>

<p>由于set存储的是无序集合，所以我们没法通过索引来访问。</p>

<p>访问 set中的某个元素实际上就是判断一个元素是否在set中。</p>

<p>例如，存储了班里同学名字的set：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart', 'Paul'])
</code></pre>
</div>

<p>我们可以用 in 操作符判断：</p>

<p>Bart是该班的同学吗？</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; 'Bart' in s
True
</code></pre>
</div>

<p>Bill是该班的同学吗？</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; 'Bill' in s
False
</code></pre>
</div>

<p>bart是该班的同学吗？</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; 'bart' in s
False
</code></pre>
</div>

<p>看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。</p>

<h3 id="set的特点">Set的特点</h3>

<p>set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。</p>

<p>set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。</p>

<p>最后，set存储的元素也是没有顺序的。</p>

<p>set的这些特点，可以应用在哪些地方呢？</p>

<p>星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。</p>

<p>假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？</p>

<p>可以用 if 语句判断，但这样做非常繁琐：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>x = '???' # 用户输入的字符串
if x!= 'MON' and x!= 'TUE' and x!= 'WED' ... and x!= 'SUN':
    print 'input error'
else:
    print 'input ok'
</code></pre>
</div>

<p>注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。</p>

<p>如果事先创建好一个set，包含’MON’ ~ ‘SUN’：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>weekdays = set(['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN'])
</code></pre>
</div>

<p>再判断输入是否有效，只需要判断该字符串是否在set中：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>x = '???' # 用户输入的字符串
if x in weekdays:
    print 'input ok'
else:
    print 'input error'
</code></pre>
</div>

<p>这样一来，代码就简单多了。</p>

<h3 id="遍历set">遍历Set</h3>

<p>由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。</p>

<p>直接使用 for 循环可以遍历 set 的元素：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart'])
&gt;&gt;&gt; for name in s:
...     print name
... 
Lisa
Adam
Bart
</code></pre>
</div>

<p>注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。</p>

<h3 id="更新set">更新Set</h3>

<p>由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事：</p>

<p>一是把新的元素添加到set中，二是把已有元素从set中删除。</p>

<p>添加元素时，用set的add()方法：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s.add(4)
&gt;&gt;&gt; print s
set([1, 2, 3, 4])
</code></pre>
</div>

<p>如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s.add(3)
&gt;&gt;&gt; print s
set([1, 2, 3])
</code></pre>
</div>

<p>删除set中的元素时，用set的remove()方法：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set([1, 2, 3, 4])
&gt;&gt;&gt; s.remove(4)
&gt;&gt;&gt; print s
set([1, 2, 3])
</code></pre>
</div>

<p>如果删除的元素不存在set中，remove()会报错：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; s = set([1, 2, 3])
&gt;&gt;&gt; s.remove(4)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
KeyError: 4
</code></pre>
</div>

<p>所以用add()可以直接添加，而remove()前需要判断。</p>

<h2 id="函数">函数</h2>

<p>我们知道圆的面积计算公式为：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>S = πr²
</code></pre>
</div>

<p>当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>r1 = 12.34
r2 = 9.08
r3 = 73.1
s1 = 3.14 * r1 * r1
s2 = 3.14 * r2 * r2
s3 = 3.14 * r3 * r3
</code></pre>
</div>

<p>当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。</p>

<p>有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle 本身只需要写一次，就可以多次调用。</p>

<p>抽象是数学中非常常见的概念。举个例子：</p>

<p>计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>100
∑n
n=1
</code></pre>
</div>

<p>这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。</p>

<p>而且，这种抽象记法是可扩展的，比如：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>100
∑(n²+1)
n=1
</code></pre>
</div>

<p>还原成加法运算就变成了：</p>

<p>(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)
可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。</p>

<p>写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。</p>

<p>Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。</p>

<h3 id="调用函数">调用函数</h3>

<p>Python内置了很多有用的函数，我们可以直接调用。</p>

<p>要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。</p>

<p>可以直接从Python的官方网站查看文档：
http://docs.python.org/2/library/functions.html#abs
也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。</p>

<p>调用 abs 函数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; abs(100)
100
&gt;&gt;&gt; abs(-20)
20
&gt;&gt;&gt; abs(12.34)
12.34
</code></pre>
</div>

<p>调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; abs(1, 2)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: abs() takes exactly one argument (2 given)
</code></pre>
</div>

<p>如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; abs('a')
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: bad operand type for abs(): 'str'
</code></pre>
</div>

<p>而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x==y，返回 0，如果 x&gt;y，返回 1：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; cmp(1, 2)
-1
&gt;&gt;&gt; cmp(2, 1)
1
&gt;&gt;&gt; cmp(3, 3)
0
</code></pre>
</div>

<p>Python内置的常用函数还包括数据类型转换函数，比如   int()函数可以把其他数据类型转换为整数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; int('123')
123
&gt;&gt;&gt; int(12.34)
12
</code></pre>
</div>

<p>str()函数把其他类型转换成 str：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; str(123)
'123'
&gt;&gt;&gt; str(1.23)
'1.23'
</code></pre>
</div>

<h3 id="编写函数">编写函数</h3>

<p>在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。</p>

<p>我们以自定义一个求绝对值的 my_abs 函数为例：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>def my_abs(x):
    if x &gt;= 0:
        return x
    else:
        return -x
</code></pre>
</div>

<p>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。</p>

<p>如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。</p>

<p>return None可以简写为return。</p>

<h3 id="返回多值">返回多值</h3>

<p>函数可以返回多个值吗？答案是肯定的。</p>

<p>比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：</p>

<p><code class="highlighter-rouge"># math</code>包提供了sin()和 cos()函数，我们先用<code class="highlighter-rouge">import</code>引用它：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>import math
def move(x, y, step, angle):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny
</code></pre>
</div>

<p>这样我们就可以同时获得返回值：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print x, y
151.961524227 70.0
</code></pre>
</div>

<p>但其实这只是一种假象，Python函数返回的仍然是单一值：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)
&gt;&gt;&gt; print r
(151.96152422706632, 70.0)
</code></pre>
</div>

<p>用print打印返回结果，原来返回值是一个tuple！</p>

<p>但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p>

<h3 id="递归函数">递归函数</h3>

<p>在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>

<p>举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * … * n，用函数 fact(n)表示，可以看出：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n
</code></pre>
</div>

<p>所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。</p>

<p>于是，fact(n)用递归的方式写出来就是：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>def fact(n):
    if n==1:
        return 1
    return n * fact(n - 1)
</code></pre>
</div>

<p>上面就是一个递归函数。可以试试：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; fact(1)
1
&gt;&gt;&gt; fact(5)
120
&gt;&gt;&gt; fact(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L
</code></pre>
</div>

<p>如果我们计算fact(5)，可以根据函数定义看到计算过程如下：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>===&gt; fact(5)
===&gt; 5 * fact(4)
===&gt; 5 * (4 * fact(3))
===&gt; 5 * (4 * (3 * fact(2)))
===&gt; 5 * (4 * (3 * (2 * fact(1))))
===&gt; 5 * (4 * (3 * (2 * 1)))
===&gt; 5 * (4 * (3 * 2))
===&gt; 5 * (4 * 6)
===&gt; 5 * 24
===&gt; 120
</code></pre>
</div>

<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>

<p><strong>使用递归函数需要注意防止栈溢出。</strong>在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。</p>

<h3 id="定义默认参数">定义默认参数</h3>

<p>定义函数的时候，还可以有默认参数。</p>

<p>例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; int('123')
123
&gt;&gt;&gt; int('123', 8)
83
</code></pre>
</div>

<p>int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。</p>

<p>可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。</p>

<p>我们来定义一个计算 x 的N次方的函数:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>def power(x, n):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>
</div>

<p>假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>def power(x, n=2):
    s = 1
    while n &gt; 0:
        n = n - 1
        s = s * x
    return s
</code></pre>
</div>

<p>这样一来，计算平方就不需要传入两个参数了：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; power(5)
25
</code></pre>
</div>

<p>由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code># OK:
def fn1(a, b=1, c=2):
    pass
# Error:
def fn2(a=1, b):
    pass
</code></pre>
</div>

<h3 id="定义可变参数">定义可变参数</h3>

<p>如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>def fn(*args):
    print args
</code></pre>
</div>

<p>可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; fn()
()
&gt;&gt;&gt; fn('a')
('a',)
&gt;&gt;&gt; fn('a', 'b')
('a', 'b')
&gt;&gt;&gt; fn('a', 'b', 'c')
('a', 'b', 'c')
</code></pre>
</div>

<p>可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。</p>

<p>定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>def average(*args):
    ...
</code></pre>
</div>

<p>这样，在调用的时候，可以这样写：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; average()
0
&gt;&gt;&gt; average(1, 2)
1.5
&gt;&gt;&gt; average(1, 2, 2, 3, 4)
2.4
</code></pre>
</div>

<h2 id="切片">切片</h2>

<h3 id="对list进行切片">对list进行切片</h3>

<p>取一个list的部分元素是非常常见的操作。比如，一个list如下：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']
</code></pre>
</div>

<p>取前3个元素，应该怎么做？</p>

<p>笨办法：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; [L[0], L[1], L[2]]
['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>之所以是笨办法是因为扩展一下，取前N个元素就没辙了。</p>

<p>取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; r = []
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; for i in range(n):
...     r.append(L[i])
... 
&gt;&gt;&gt; r
['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。</p>

<p>对应上面的问题，取前3个元素，用一行代码就可以完成切片：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[0:3]
['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。</p>

<p>如果第一个索引是0，还可以省略：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[:3]
['Adam', 'Lisa', 'Bart']
</code></pre>
</div>

<p>也可以从索引1开始，取出2个元素出来：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[1:3]
['Lisa', 'Bart']
</code></pre>
</div>

<p>只用一个 : ，表示从头到尾：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[:]
['Adam', 'Lisa', 'Bart', 'Paul']
</code></pre>
</div>

<p>因此，L[:]实际上复制出了一个新list。</p>

<p>切片操作还可以指定第三个参数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L[::2]
['Adam', 'Bart']
</code></pre>
</div>

<p>第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。</p>

<p>把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。</p>

<h3 id="倒序切片">倒序切片</h3>

<p>对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']

&gt;&gt;&gt; L[-2:]
['Bart', 'Paul']

&gt;&gt;&gt; L[:-2]
['Adam', 'Lisa']

&gt;&gt;&gt; L[-3:-1]
['Lisa', 'Bart']

&gt;&gt;&gt; L[-4:-1:2]
['Adam', 'Bart']
</code></pre>
</div>

<p>记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。</p>

<h3 id="对字符串切片">对字符串切片</h3>

<p>字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; 'ABCDEFG'[:3]
'ABC'
&gt;&gt;&gt; 'ABCDEFG'[-3:]
'EFG'
&gt;&gt;&gt; 'ABCDEFG'[::2]
'ACEG'
</code></pre>
</div>

<p>在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>

<h2 id="迭代">迭代</h2>

<p>在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。</p>

<p>在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>for (i=0; i&lt;list.length; i++) {
    n = list[i];
}
</code></pre>
</div>

<p>可以看出，Python的for循环抽象程度要高于Java的for循环。</p>

<p>因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。</p>

<p>因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。</p>

<p>注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：</p>

<ol>
  <li>有序集合：list，tuple，str和unicode；</li>
  <li>无序集合：set</li>
  <li>无序集合并且具有 key-value 对：dict
而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。</li>
</ol>

<p>迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。</p>

<h3 id="索引迭代">索引迭代</h3>

<p>Python中，迭代永远是取出元素本身，而非元素的索引。</p>

<p>对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？</p>

<p>方法是使用 enumerate() 函数：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']
&gt;&gt;&gt; for index, name in enumerate(L):
...     print index, '-', name
... 
0 - Adam
1 - Lisa
2 - Bart
3 - Paul
</code></pre>
</div>

<p>使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>['Adam', 'Lisa', 'Bart', 'Paul']
</code></pre>
</div>

<p>变成了类似：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')]
</code></pre>
</div>

<p>因此，迭代的每一个元素实际上是一个tuple：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>for t in enumerate(L):
    index = t[0]
    name = t[1]
    print index, '-', name
</code></pre>
</div>

<p>如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>for index, name in enumerate(L):
    print index, '-', name
</code></pre>
</div>

<p>这样不但代码更简单，而且还少了两条赋值语句。</p>

<p>可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。</p>

<h3 id="迭代dict的value">迭代Dict的value</h3>

<p>我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。</p>

<p>如果我们希望迭代 dict 对象的value，应该怎么做？</p>

<p>dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
print d.values()
# [85, 95, 59]
for v in d.values():
    print v
# 85
# 95
# 59
</code></pre>
</div>

<p>如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
print d.itervalues()
# &lt;dictionary-valueiterator object at 0x106adbb50&gt;
for v in d.itervalues():
    print v
# 85
# 95
# 59
</code></pre>
</div>

<p>那这两个方法有何不同之处呢？</p>

<ol>
  <li>
    <p>values() 方法实际上把一个 dict 转换成了包含 value 的list。</p>
  </li>
  <li>
    <p>但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。</p>
  </li>
  <li>
    <p>打印 itervalues() 发现它返回一个 <dictionary-valueiterator> 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。</dictionary-valueiterator></p>
  </li>
</ol>

<p>如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。</p>

<h3 id="迭代dict的key和value">迭代Dict的key和value</h3>

<p>我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。</p>

<p>首先，我们看看 dict 对象的 items() 方法返回的值：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
&gt;&gt;&gt; print d.items()
[('Lisa', 85), ('Adam', 95), ('Bart', 59)]
</code></pre>
</div>

<p>可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; for key, value in d.items():
...     print key, ':', value
... 
Lisa : 85
Adam : 95
Bart : 59
</code></pre>
</div>

<p>和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。</p>

<h2 id="列表">列表</h2>

<h3 id="列表生成">列表生成</h3>

<p>要生成<code class="highlighter-rouge">list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code>，我们可以用<code class="highlighter-rouge">range(1, 11)</code>：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; range(1, 11)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
</div>

<p>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; L = []
&gt;&gt;&gt; for x in range(1, 11):
...    L.append(x * x)
... 
&gt;&gt;&gt; L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
</div>

<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
</div>

<p>这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。</p>

<p>写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。</p>

<h3 id="复杂表达式">复杂表达式</h3>

<p>使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。</p>

<p>假设有如下的dict：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }
</code></pre>
</div>

<p>完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]
print '&lt;table&gt;'
print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'
print '\n'.join(tds)
print '&lt;/table&gt;'
</code></pre>
</div>

<p>注：字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。</p>

<p>把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&lt;table border="1"&gt;
&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;
&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code></pre>
</div>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Lisa</td>
      <td>85</td>
    </tr>
    <tr>
      <td>Adam</td>
      <td>95</td>
    </tr>
    <tr>
      <td>Bart</td>
      <td>59</td>
    </tr>
  </tbody>
</table>

<h3 id="条件过滤">条件过滤</h3>

<p>列表生成式的 for 循环后面还可以加上 if 判断。例如：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
</div>

<p>如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0]
[4, 16, 36, 64, 100]
</code></pre>
</div>

<p>有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。</p>

<h3 id="多层表达式">多层表达式</h3>

<p>for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。</p>

<p>对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']
['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']
</code></pre>
</div>

<p>翻译成循环代码就像下面这样：</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>L = []
for m in 'ABC':
    for n in '123':
        L.append(m + n)
</code></pre>
</div>


            
            
            
            

            <!-- Tag Buttons -->
            <ul class="actions">
              
              
              <li><a href="/tags/#python" class="button small"># python</a></li>
              
              
              
              <li><a href="/tags/#%E7%A2%8E%E7%A2%8E%E5%BF%B5" class="button small"># 碎碎念</a></li>
              
              
              
              <li><a href="/tags/#%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0" class="button small"># 读书笔记</a></li>
              
                  
            </ul>
          </section>

          <div class="comments-wrapper">
          <!--
          <div id="disqus_thread"></div>
          <script>
              /**
               *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
               *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
               */

              var disqus_config = function () {
                  this.page.url = '/blog/python-basic-knowledge/';  /*Replace PAGE_URL with your page's canonical URL variable*/
                  this.page.identifier = '/blog/python-basic-knowledge/'; /*Replace PAGE_IDENTIFIER with your page's unique identifier variable*/
              };

              (function() {  /* dont endit below this line */
                  var d = document, s = d.createElement('script');

                  s.src = 'https://.disqus.com/embed.js';

                  s.setAttribute('data-timestamp', +new Date());
                  (d.head || d.body).appendChild(s);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>-->

          <!-- 来必力City版安装代码 -->
          <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzY4My8xMDIzOA==">
          <script type="text/javascript">
             (function(d, s) {
                 var j, e = d.getElementsByTagName(s)[0];

                 if (typeof LivereTower === 'function') { return; }

                 j = d.createElement(s);
                 j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                 j.async = true;

                 e.parentNode.insertBefore(j, e);
             })(document, 'script');
          </script>
          <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
          </div>
        </div>
        <!-- /.comments-wrapper -->



					<!-- Footer -->
						<footer>
              <ul class="actions">
                
                  <li><a href="/blog/ios-security-pattern/" class="button special icon fa-arrow-left"></a></li>
                
                <li><a href="/blog/" class="button">All Blog</a></li>
                
                  <li><a href="/blog/japanese-honorific-tongue/" class="button special icon fa-arrow-right"></a></li>
                
              </ul>
						</footer>
					</div>

				<!-- Footer -->
        <footer id="footer">
  <section>
    <form method="POST" action="https://formspree.io/chars.davy@gmail.com">
      <div class="field">
        <label for="name">Name</label>
        <input type="text" name="name" id="name">
      </div>
      <div class="field">
        <label for="email">Email</label>
        <input type="text" name="email" id="email">
      </div>
      <div class="field">
        <label for="message">Message</label>
        <textarea name="message" id="message" rows="3"></textarea>
      </div>
      <ul class="actions">
        <li><input type="submit" value="Send Message"></li>
      </ul>
    </form>
  </section>
  <section class="split contact">
    <section class="alt">
      <h3>Location</h3>
      <p>Guangzhou, China</p>
    </section>
    <section>
      <h3>QQ</h3>
      <p><a href="qq:124808738">124808738</a></p>
    </section>
    <section>
      <h3>Email</h3>
      <p><a href="mailto:chars.davy@gmail.com">chars.davy@gmail.com</a></p>
    </section>
    <section>
      <h3>Social</h3>
      <ul class="icons alt">
        <li><a href="https://twitter.com/charsdavy" class="icon fa-twitter" rel="nofollow"><span class="label">Twitter</span></a></li>
        <li><a href="https://facebook.com/wei.deng.1460" class="icon fa-facebook" rel="nofollow"><span class="label">Facebook</span></a></li>
        <li><a href="https://instagram.com/chars.davy" class="icon fa-instagram" rel="nofollow"><span class="label">Instagram</span></a></li>
        <li><a href="https://github.com/charsdavy" class="icon fa-github" rel="nofollow"><span class="label">GitHub</span></a></li>
      </ul>
    </section>
  </section>
</footer>
<div id="back-top" style="position:fixed;bottom:40px;right:30px;cursor: pointer;">
  <a href="#top" title="返回顶部"><img src="/images/arrow-up.png"></a>
</div>
<script type="text/javascript">
  $("#back-top").hide();
  $(document).ready(function () {
    $(window).scroll(function () {
      if ($(this).scrollTop() > 800) {
        $('#back-top').fadeIn();
      } else {
        $('#back-top').fadeOut();
      }
    });
    $('#back-top a').click(function () {
      $('body,html').animate({
        scrollTop: 0
      }, 1200);
      return false;
    });
  });
</script>
<!-- Copyright -->
<div id="copyright">
  <ul>
<li>2016 - 2018 © Chars</li>
<li>Design by <a href="https://html5up.net" rel="nofollow">HTML5 UP</a>
</li>
<li>Jekyll Integration by <a href="https://soundgrail.com">SoundGrail</a>
</li>
</ul>
</div>


			</div>

      <!-- Scripts -->
  		<!-- DYN -->
<script src="/assets/js/jquery.min.js"></script>
<script src="/assets/js/jquery.scrollex.min.js"></script>
<script src="/assets/js/jquery.scrolly.min.js"></script>
<script src="/assets/js/skel.min.js"></script>
<script src="/assets/js/util.js"></script>
<script src="/assets/js/main.js"></script>

			<script async src="https://www.googletagmanager.com/gtag/js?id=UA-80507808-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());

  gtag('config', 'UA-80507808-1');
</script>


	</body>
</html>
