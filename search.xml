<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[日本，我眼中的样子]]></title>
      <url>/blog/japan-life-experience/</url>
      <content type="text"><![CDATA[来到日本已经有一段时间了，为什么直到现在才开始想起来写一点感想呢。一是，时间不多。二是，之前体验不多。这次来日本，抱着学习、求证的心态。身边的人问起，笔者的回答一向都是，过来“浪”了。因为不是有很具体的目的过来的。在大学毕业时，就因为一些原因，对这边有兴趣。而现在，有机会过来了。那么，就能好好验证之前自己的困惑了。目前为止，最大的体会就是，日本绝对是个生活的好地方。环境很不错，在大马路上走，都基本闻不到尾气。晨跑笔者是直接在马路边、公园里、居住区进行。周末出去逛逛街，看看各种地方。除了这些安静，空寂的街道。在人气比较旺的旅游区，也是大同小异。这个红色的邮筒，超级有个性，很难得见到在发达国家还保持着一些比较原始的习惯，还包括看报纸。久负盛名的团地。至于吃的嘛，那就很随意了。当然，具有标志性的建筑，东京塔，也要来看看的。最后，附上一些生活杂类拍照。看了这么多，应该很多人都会想过来体验一把。客观来说，这边除了工作，其他都很好。为什么这么说呢？工作就涉及到了日本文化问题了，或许有很多人喜欢，但是对于我们这些受欧美影响较多的人来说，或许，当真的亲身体验时，可能又是另一番感受了吧。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[不是结束，只是开始]]></title>
      <url>/blog/just-begin-not-leave/</url>
      <content type="text"><![CDATA[今天自己已经没有上班了，心里却是莫名的失落。没有开心与轻松，自己现在并不累。今天终于发现自己真的很恋旧。在 ZAKER 呆了 912 天，说来也不是很短了。本来以为自己可以继续呆下去，依旧可以做着一边工作一边兼顾自己的项目，在工作中迸发自己的 idea，然后付诸行动。正如离开时对领导所说，自己是带着情怀来的，但是很可惜，要带着遗憾离开。自己在很早就使用 ZAKER 来看新闻，当时来到广州，经过各种面试考验，如愿来到老东家。慢慢的想着要将它变得更好，或者是说自己能够为它的成长贡献力量。两年多下来，看着它慢慢迭代，和两年前比较，已经不是同一个产品啦，变化还是很大的。最开始进来时，就被小组的团队氛围所触动。没错，我们是一个很年轻的团队，大家可以很自然的沟通，可以很放松，可以很时髦，但是我们也很努力。两年多来，自己不断被影响，努力前行。从一个开发新手，到一个完全可以自己 hold 住需求的开发人员。自己的成长，也得到了肯定。期间经历团队同事的离开，经历引导人的离开，这些无不是一种心理磨练。特别是当面试自己的领导同事离开时，那种说出不的滋味。虽然明白天下无不散之宴席，但当自己真的面对时，还是需要心理建设的。苟富贵，勿相忘。江湖再见。这几句话我们会在散场的时候诉说的。或许若干年后，我们会真的体会它的深意。最后，自己也不知道想要写什么，或许就是想留下一个印记吧。ZAKER 我曾经来过，ZAKER 我曾经为你激情付出。ZAKER 希望你越来越好！]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[如何通过浏览器上网]]></title>
      <url>/blog/how-to-surfing-via-browser/</url>
      <content type="text"><![CDATA[当我们在网页浏览器（Web browser）的地址栏中输入 URL 时，Web 页面是如何呈现的吗？Web 页面当然不能凭空显示出来。根据 Web 浏览器地址栏中指定的 URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（client）。Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定，可以说，Web 是建立在 HTTP 协议上通信的。  超文本传输协议（HTTP，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了 HTTP 超文本传输协议标准架构的发展根基。Ted Nelson 组织协调万维网协会（World Wide Web Consortium）和互联网工程工作小组（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的 RFC，其中著名的 RFC 2616 定义了 HTTP 1.1。诞生HTTP 的出生时间是 1989 年 3 月，那时候互联网还属于少数人。CERN（欧洲核子研究组织）的蒂姆 • 伯纳斯 - 李（Tim BernersLee）博士提出了一种能让远隔两地的研究者们共享知识的设想。最初设想的基本理念是：借助多文档之间相互关联形成的超文本（HyperText），连成可相互参阅的 WWW（World Wide Web，万维网）。现在已提出了 3 项 WWW 构建技术，分别是：把 SGML（Standard Generalized Markup Language，标准通用标记语言）作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP ；指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。WWW 这一名称，是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。1990 年 11 月，CERN 成功研发了世界上第一台 Web 服务器和 Web 浏览器。成长HTTP/0.9HTTP 于 1990 年问世。那时的 HTTP 并没有作为正式的标准被建立。现在的 HTTP 其实含有 HTTP1.0 之前版本的意思，因此被称为 HTTP/0.9。HTTP/1.0HTTP 正式作为标准被公布是在 1996 年的 5 月，版本被命名为 HTTP/1.0，并记载于 RFC1945。虽说是初期标准，但该协议标准至今仍被广泛使用在服务器端。HTTP/1.11997 年 1 月公布的 HTTP/1.1 是目前主流的 HTTP 协议版本。当初的标准是 RFC2068，之后发布的修订版 RFC2616 就是当前的最新版本。TCP/IP 简介为了理解 HTTP，我们有必要事先了解一下 TCP/IP 协议族。通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。计算机与网络设备要相互通信，双方就必须基于相同的方法。比如，如何探测到通信目标、由哪一边先发起通信、使用哪种语言进行通信、怎样结束通信等规则都需要事先确定。不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。分层管理TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。分层的好处：若某个地方需要改变设计时，不需要把所有部分整体替换掉，只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。应用层应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）。HTTP 协议也处于该层。传输层传输层为应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。TCP 提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。简单来说，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。而为了准确无误地将数据传输到目标，TCP 采用了三次握手策略。网络层网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。负责传输的 IP 协议IP（Internet Protocol）网际协议位于网络层。需要注意的是可“IP”和“IP 地址”的区别，“IP”其实是一种协议的名称。IP 协议的作用是把各种数据包传送给对方。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。基本上各大网卡制作厂商都被预制分配了 MAC 地址区间段。IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。这时，会采用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。这种机制称为路由选择（routing）。数据链路层用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。在数据链路层还有一个常见的网络协议 LLDP。了解更多可以查看《数据链路层之 LLDP》。通信传输流为了更好的理解上图，我们使用 HTTP 🌰 说明。      作为发送端的客户端在应用层（HTTP 协议）发出一个想看某个 Web 页面的 HTTP 请求。        在传输层（TCP 协议）把从应用层处收到的数据（HTTP 请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。        在网络层（IP 协议），增加作为通信目的地的 MAC 地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。        接收端的服务器在链路层接收到数据，按序往上层发送，一直到应用层。当传输到应用层，才能算真正接收到由客户端发送过来的 HTTP 请求。  发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。DNS 简述DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。🌰 www.chars.tech。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。访问网站至此，大致可以回答开篇的问题了，我们在浏览器输入框中输入想浏览的网页地址之后，发生了哪些事情呢？  客户端发起页面网址请求给 DNS。  DNS 解析出对应 IP 地址返回给客户端。  客户端填充请求 IP 地址。  客户端根据 HTTP 交互封装请求数据包。  请求数据包经过路由机制到达目的地址。  目的地址服务器返回数据给客户端。]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> 网络 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[云南，一片上天眷顾的土地]]></title>
      <url>/blog/yunnan-travel-notes/</url>
      <content type="text"><![CDATA[距离从云南回来已经好些天了。但，脑海中还会时常回忆起那里的景色。或许对于一些人来说，那些也是很通常的环境。旅行，不就是不同环境生活的人，暂时交换体验吗？这次的旅行，发现自己变化很大，从心性上来说，应该成熟些了吧。对于这次的旅行，还是想能够记下来，毕竟对于我来说，是一份很珍贵的记忆。云南（不对，应该还包括四川。因为这次出行，已经各种跨省跨境的游玩了）不仅是个景色优美的地方，而且美食也是很重要的角色。相信我辈吃货们很关注那里有什么好吃的吧。这里首先来推荐几款一定要尝尝的美食吧。这是当时在扎窝洛码头住民宿时老板做的。看着很辣，一向清淡饮食的我被吓着了，试着吃了一口之后，完全停不下来，不仅不辣，还香气扑鼻。好吃！爽！这种黄李子只能在丽江买到，可能是特色水果吧。最棒的吃法是，使用当地泉水或井水，洗干净吃。不要问为什么，你自己去了尝试一下就明白了。至于是不是叫黄李子，这个就很难说了，一路上问了不少人。感觉没有一个是认真回答这个问题的，都随便叫一个名字。哈哈哈，这个“随便”的用法也是和当地人学的。以上这两种菜是在大理洱海畔的双廊一家餐馆吃的，味道嘛，和吃一般蔬菜一样，只不过名字比较有意思。以上三样都是在大理古城逛吃发现的。到了云南，肯定不能不吃云南米线。不过，有点分不清这个和米粉有什么区别啦。当然，吃的东西不仅仅如此，只不过这些都是比较有意思的。除了吃，当然就是玩啦。第一天早上来到丽江，因为太早。从火车站，直接坐18路公交进入市区，18路，记得郴州火车站的公交也是18路。好巧呀。车子可以直接到达丽江古城的忠义市场，以前需要的古城维修费，现在也不需要啦。下车之后找个地方吃了碗当地的云南米线，物价也不是很贵。加下来，绕着古城，找到南门，然后进去逛一逛。清晨空气很棒，古城里的公园很多运动的爷爷奶奶。还看到一对夫妻，前一天晚上就在他们的SUV中度过的，居然还带着宠物狗出门。真的很惬意呀！把行李寄存在客栈之后，就直接去丽江古城逛吃咯。丽江古城由束河古镇、大研古城、白沙古镇组成。最方便、最热闹的是大研古城，也就是人们常说的丽江古城。这里商业气息比较重，有很多小吃和店铺，人流量也是比较大的。虽然束河古城比较清净，但相应的是交通不怎么方便。因为客栈距离丽江古城东门，所以吃住还是很方便的。古城不是封闭的，你可以从任何你喜欢的地方进入。这是在狮子山附近看到的古城全貌。真的很幸运，前一天这里还在下雨，到的这一天却赶上放晴。“大水车”不仅是古城的一个景点，它旁边也是古城北门。这附近有去泸沽湖的汽车，也有去其他景点的车。之前也去过乌镇，这种旧时建筑，可能风格都差不多，美不美，在于你！走累了，坐在这石桥上吃黄李子，桥木有拍，当然看不见啦。逛吃饱了之后，买了两件纳西族的衣服，准备期间穿起来。走出古城，办理好入住。准备出发去“拉市海”。拉市海边的花田和草地，让人眼前一亮，很久不见了。租条皮划艇，自己划着。心之所往，片刻即至。划了半天皮划艇，晚上都不想出门啦，在客栈收拾好，准备次日的行程–玉龙雪山。没错，奔着4680去的。不能不说是遗憾，这个也不由想起大四时候，和室友去爬华山，想看日出。然后那天大雾！这个玉龙雪山是准备了一天的时间，所以除了登4680，还有蓝月谷可以玩。下午5:30准时下山返程，回到客栈。次日，就要去泸沽湖啦。泸沽湖三分之一在云南 ，三分之二在四川，由湖泊和万亩草海组成。云南、 四川两省都可以进入。先来一个全景，不错，这个就是一个未被污染的天然水域。迎面出来凉凉的风，好久没有这样的感觉啦。在泸沽湖，是住在四川境内的扎窝洛码头【老知青之家】民宿，这里是摩梭族人聚居区。在这里，体验当地人生活。来看看漂亮的民宿。老板有两个和我一般年纪的儿子，下午刚好跟着一起去了【摩梭博物馆】这个是“莫言”题字的哟！不清楚是在获奖前还是后啦。晚上还去看了当地的篝火晚会！次日，和两个小老板一起环湖游啦，因为景区现在已经禁止骑行啦，少了一大乐趣！看见水面上的水性杨花了吗？那个就是可以吃的！这两天在泸沽湖呆得都不想离开啦。次日，来到大理古城。晚上逛吃，休息好。因为～次日清晨起来，在古城里逛悠个早餐，租了个小电驴，开启洱海环行！先来到崇圣寺三塔，不错，就是那个明信片经常出现的地方！中午到双廊吃午餐，继续一路向前，出发。晚上回到客栈，都不敢想象，今天环洱海有150公里。到了这个时候，旅行进度条也要撑不住啦。不久就要返程啦。最后一天还是在大理，不过没有具体目标，早上多睡了一会，然后出门觅食。最后在洱海公园好好逛了逛。这次旅行，真的很放松。这期间，可以不管手机上的信息，不用理会各种事物。在那里，都是使用现金，离开网络，离开忙碌的世界。社会在快速发展，人到底是变得更幸福快乐了吗？回来之后，又要开启自己的学习节奏，既然走了这条路，就要坚持下去。现在已经开设了知乎专栏《通俗易懂的算法》、《如何独立开发一个完整应用》，有兴趣的童鞋欢迎关注和推荐给他人。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[什么是大 O 表示法]]></title>
      <url>/blog/big-o-notation/</url>
      <content type="text"><![CDATA[“大O表示法”是一种特殊的表示法，指出了算法的速度有多快。但是它却不是指具体的时间，那么该如何正确理解它呢？算法的运行时间以不同的速度增加“算法的运行时间以不同的速度增加”这句话应该如何理解呢？下面我们通过🌰来看看这句话到底想表达什么。小明现在需要编写一个查找算法，这个算法服务于学校图书馆，目的是帮助童鞋们能够快速的找到自己需要的书籍所在位置。假设小明现在只会“二分查找”和“简单查找”。一方面，二分查找的速度很快，小明必须在 10 秒钟内找到书籍所在位置，否则童鞋们没有更多耐心等待。另一方面，简单查找算法编写起来更容易，因此出现 bug 的可能性更小。为了检验这两种算法的耗时，小明决定计算两种算法在列表包含 100 个元素的情况下需要的时间。假设检查一个元素需要 1 毫秒。使用简单查找时，小明必须检查 100 个元素，因此需要 100 毫秒才能查找完毕。而使用二分查找时，只需检查 7 个元素（log2 100大约为7），因此需要 7 毫秒就能查找完毕。然而，实际要查找的列表可能包含 10 亿个元素，在这种情况下，简单查找需要多长时间呢？二分查找又需要多长时间呢？小明使用包含 10 亿个元素的列表运行二分查找，运行时间为 30 毫秒（log2 1 000 000 000大约为30）。他心里想，二分查找的速度大约为简单查找的 15 倍，因为列表包含 100 个元素时，简单查找需要 100 毫秒，而二分查找需要 7 毫秒。因此，列表包含 10 亿个元素时，简单查找需要 30 × 15 = 450 毫秒，完全符合在 10 秒内查找完毕的要求。小明决定使用简单查找。这是正确的选择吗？不是。实际上，小明错了，而且错得离谱。列表包含 10 亿个元素时，简单查找需要 10 亿毫秒，相当于 11 天！为什么会这样呢？因为二分查找和简单查找的运行时间的增速不同。            简单查找      二分查找      元素个数                  100 毫秒      7 毫秒      100              10 秒      14 毫秒      10 000              11 天      30 毫秒      1 000 000 000      随着元素数量的增加，二分查找需要的额外时间并不多，而简单查找需要的额外时间却很多。因此，随着列表的增长，二分查找的速度比简单查找快得多。小明以为二分查找速度为简单查找的 15 倍，这不对：列表包含 10 亿个元素时，为 3300 万倍。有鉴于此，仅知道算法需要多长时间才能运行完毕还不够，还需知道运行时间如何随列表增长而增加。这正是大O表示法的用武之地。大O表示法指出了算法有多快。例如，假设列表包含 n 个元素。简单查找需要检查每个元素，因此需要执行 n 次操作。使用大O表示法，这个运行时间为 O(n)。单位秒呢？没有！大O表示法指的并非以秒为单位的速度。大O表示法让你能够比较操作数，它指出了算法运行时间的增速。最糟糕情况下的运行时间假设你使用简单查找在电话簿中找人。你知道，简单查找的运行时间为 O(n)，这意味着在最糟情况下，必须查看电话簿中的每个条目。如果要查找的是 Chars ——电话簿中的第一个人，一次就能找到，无需查看每个条目。考虑到一次就找到了 Chars，请问这种算法的运行时间是 O(n)还是 O(1) 呢？简单查找的运行时间总是为 O(n)。查找 Chars 时，一次就找到了，这是最佳的情形，但大O表示法说的是最糟的情形。因此，你可以说，在最糟情况下，必须查看电话簿中的每个条目，对应的运行时间为 O(n)。这是一个保证——你知道简单查找的运行时间不可能超过 O(n)。  说明  除最糟情况下的运行时间外，还应考虑平均情况的运行时间，这很重要。最糟情况和平均情况将在第4章讨论。一些常见的大O运行时间下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。  O (log n )，也叫对数时间 ，这样的算法包括二分查找。  O (n )，也叫线性时间 ，这样的算法包括简单查找。  O (n * log n )，这样的算法包括快速排序——一种速度较快的排序算法。  O (n 2 )，这样的算法包括选择排序——一种速度较慢的排序算法。  O (n !)，这样的算法包括旅行商问题的解决方案——一种非常慢的算法。总结1、算法的速度指的并非时间，而是操作数的增速。2、谈论算法的速度时，说的是随着输入的增加，其运行时间将以什么样的速度增加。3、算法的运行时间用大O表示法表示。4、O(log n) 比 O(n)快，当需要搜索的元素越多时，前者比后者快得越多。写在最后对算法有兴趣的童鞋可以关注专栏《通俗易懂的算法》，也欢迎大家多多投稿分享。同时欢迎大家加入算法交流Q群交流讨论，Q群号：855454453]]></content>
      <categories>
        
          <category> algorithm </category>
        
      </categories>
      <tags>
        
          <tag> 概念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[实现一个 RESTful API 服务器]]></title>
      <url>/blog/restful-api-go/</url>
      <content type="text"><![CDATA[RESTful 是目前最为流行的一种互联网软件结构。因为它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。什么是 RESTREST（REpresentational State Transfer），首次出现在 2000 年 Roy Thomas Fielding 的博士论文中，它指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful 的。  资源（Resources），REST 是“表现层状态转化”，其实它省略了主语。“表现层”其实指的是“资源”的“表现层”。那么什么是资源呢？我们平时网上访问到图片、文字、文档、多媒体等就是资源，一般通过 URI 来定位。也就是说，一个 URI 就表示一个资源。  表现层（Representation），资源是作为一个具体的实体信息，它可以有多种的展现方式。而把实体展现出来就是表现层。例如一个 txt 文本信息，它可以输出成 html、json 等。  状态转化（State Transfer），访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，就涉及到数据和状态的变化。而 HTTP 协议是无状态的，那么这些状态肯定保存在服务器端，所以如果客户端想要通知服务器端改变数据和状态的变化，就要通过某种方式来通知它。客户端能通知服务器端的手段，只能是 HTTP 协议。具体来说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源。综上所述，我们总结一下什么是 RESTful 架构：1、每一个 URI 代表一种资源2、客户端和服务端之间，传递这种资源的某种表现层3、客户端通过四个 HTTP 动词，对服务端资源进行操作，实现“表现层状态转化”将它们概述为图片形式，则 REST 架构图为：REST 的扩展性：什么是 RPCRPC（Remote Procedure Call Protocol）远程过程调用协议，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。它假定某些传输协议的存在，如 TCP 或 UDP，以便为通信程序之间携带信息数据。通过它可以使函数调用模式网络化。在 OSI 网络通信模型中，RPC 跨越了传输层和应用层。RPC 使得开发包括网络分布式多程序在内的应用程序更加容易。工作原理运行时，一次客户端对服务器的 RPC 调用，其内部操作大致有如下步骤：1、调用客户端句柄；执行传送参数2、调用本地系统内核发送网络消息3、消息传送到服务端4、服务器句柄得到消息并取得参数5、执行远程过程6、执行的过程将结果返回服务器句柄7、服务器句柄返回结果，调用远程系统内核8、消息传回本地主机9、客户端句柄由内核接收消息10、客户端接收句柄返回的数据REST vs RPC在做 API 服务器开发时，很多人都会遇到这个问题 —— 选择 REST 还是 RPC。RPC 相比 REST 的优点主要有 3 点：1、RPC+Protobuf 采用的是 TCP 做传输协议，REST 直接使用 HTTP 做应用层协议，这种区别导致 REST 在调用性能上会比 RPC+Protobuf 低2、RPC 不像 REST 那样，每一个操作都要抽象成对资源的增删改查，在实际开发中，有很多操作很难抽象成资源，比如登录操作。所以在实际开发中并不能严格按照 REST 规范来写 API，RPC 就不存在这个问题3、RPC 屏蔽网络细节、易用，和本地调用类似但是 REST 相较 RPC 也有很多优势：1、轻量级，简单易用，维护性和扩展性都比较好2、REST 相对更规范，更标准，更通用，无论哪种语言都支持 HTTP 协议，可以对接外部很多系统，只要满足 HTTP 调用即可，更适合对外，RPC 会有语言限制，不同语言的 RPC 调用起来很麻烦3、JSON 格式可读性更强，开发调试都很方便4、在开发过程中，如果严格按照 REST 规范来写 API，API 看起来更清晰，更容易被大家理解其实业界普遍采用的做法是，内部系统之间调用用 RPC，对外用 REST，因为内部系统之间可能调用很频繁，需要 RPC 的高性能支撑。对外用 REST 更易理解，更通用些。一个基本的 Web Server一个 RESTful 服务本质上首先是一个 Web service。下面是一个最简单的 Web server，对于任何请求都简单的直接返回请求链接：package mainimport (        "fmt"        "html"        "log"        "net/http")func main() {        http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {            fmt.Fprintf(w, "Hello, %q", html.EscapeString(r.URL.Path))    })    log.Fatal(http.ListenAndServe(":8080", nil))}编译运行之后，使用 curl 测试，结果如下：$ curl -v -XGET -H "Content-Type: application/json" http://127.0.0.1:8080/userHello, "/user"路由功能很显然，我们的线上项目不可能使用这么简单的 API 服务器。当用户增加，请求也会不断上涨，该如何处理好这些请求？作者使用了一个开源路由框架 mux。这是一个小巧高效，且使用较广的第三方框架。接下来的篇幅里，作者会使用 mux 搭建一个 API 服务器框架。安装 mux$go get github.com/gorilla/muxRouter//Router.goimport (	"net/http"	"github.com/gorilla/mux")type Route struct {	Name        string	Method      string	Pattern     string	HandlerFunc http.HandlerFunc}type Routes []Routefunc NewRouter() *mux.Router {	router := mux.NewRouter().StrictSlash(true)	for _, route := range routes {		var handler http.Handler		handler = route.HandlerFunc		handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {			handler.ServeHTTP(w, r)		})		router.Methods(route.Method).Path(route.Pattern).Name(route.Name).Handler(handler)	}	return router}var routes = Routes{	Route{		"DeleteItem",		"DELETE",		"/v1/delete",		v1_deleteItem,	},	...}Handler//Handler.gofunc v1_deleteItem(w http.ResponseWriter, r *http.Request) {	w.Header().Set("Content-Type", "application/json; charset=UTF-8")	w.WriteHeader(http.StatusOK)	if err := json.NewEncoder(w).Encode(jsonErr{Code: http.StatusOK, Text: "操作成功"}); err != nil {		log.print("%s\n%s", err.Error(), debug.Stack())	}}整体 mux 功能实现：//main.gofunc main() {	router := NewRouter()	log.print("service running(PID:%d)...", os.Getpid())	log.Fatal(http.ListenAndServe(":8080", router))}API 基本框架已经实现，接下来就是将相应功能实现模块与相应接口对接即可。写在最后对于想要学习作为一个客户端开发者如何独立完成一个具有 API 服务器功能的线上 APP，可以参考专栏《如何独立开发一个完整应用》，专栏中使用线上 APP 靓手艺 作为案例，详细分享了笔者如何实现 APP 全部功能。]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> go </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[CocoaPods 提交代码踩坑]]></title>
      <url>/blog/cocoapods-source-commit/</url>
      <content type="text"><![CDATA[如何提交代码至 CocoaPods？这个问题在 Google 一搜索可以有很多文章出来，不过，其中遇到的坑却无人提及。笔者现在将实际操作工程记录如下，并总结踩坑注意事项：操作顺序、文件配置、命令使用。准备工作提交代码将需要提交至 CocoaPods 的代码提交至代码托管服务器，例如：GitHub。这里需要注意的是，提交的代码需要包含 tag 标签。其实就是 git 里面的 git tag。安装或更新 CocoaPods安装$ gem install cocoapods更新$ pod update注册 Trunk$ pod trunk register e_mail_address 'your_name'注意：记得去注册邮箱激活查看注册信息$ pod trunk me  - Name:     charsdavy  - Email:    chars.davy@gmail.com  - Since:    July 15th, 21:38  - Pods:    - JCCNavigationController  - Sessions:    - July 15th, 21:38 - November 21st, 01:45. IP: xx.xx.xx.xx创建 .podspec 文件.podspec 文件的作用是为了让 CocoaPods 搜索引擎知道该代码的作者、版本号、概要、描述、源代码地址、部署版本、依赖的框架等描述信息。.podspec文件可以自动生成：$ pod spec create JCCNavigationController // 生成 JCCNavigationController.podspec 文件JCCNavigationController.podspec 文件内容：##  Be sure to run `pod spec lint JCCNavigationController.podspec' to ensure this is a#  valid spec and to remove all comments including this before submitting the spec.##  To learn more about Podspec attributes see http://docs.cocoapods.org/specification.html#  To see working Podspecs in the CocoaPods repo see https://github.com/CocoaPods/Specs/#Pod::Spec.new do |s|  # ―――  Spec Metadata  ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  These will help people to find your library, and whilst it  #  can feel like a chore to fill in it's definitely to your advantage. The  #  summary should be tweet-length, and the description more in depth.  #  s.name         = "JCCNavigationController"  s.version      = "1.0"  s.summary      = "A navigation bar integrated transition animation effect."  # This description is used to generate tags and improve search results.  #   * Think: What does it do? Why did you write it? What is the focus?  #   * Try to keep it short, snappy and to the point.  #   * Write the description between the DESC delimiters below.  #   * Finally, don't worry about the indent, CocoaPods strips it!  s.description  = &lt;&lt;-DESC                  With zoom interactive animation, A navigation bar integrated transition animation effect.                  DESC  s.homepage     = "https://github.com/charsdavy/JCCNavigationController"  s.screenshots  = "https://raw.githubusercontent.com/charsdavy/JCCNavigationController/master/Screenshot.gif"  # s.screenshots  = "www.example.com/screenshots_1.gif", "www.example.com/screenshots_2.gif"  # ―――  Spec License  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  Licensing your code is important. See http://choosealicense.com for more info.  #  CocoaPods will detect a license file if there is a named LICENSE*  #  Popular ones are 'MIT', 'BSD' and 'Apache License, Version 2.0'.  #  s.license      = { :type =&gt; "MIT", :file =&gt; "LICENSE" }  # s.license      = { :type =&gt; "MIT", :file =&gt; "FILE_LICENSE" }  # ――― Author Metadata  ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  Specify the authors of the library, with email addresses. Email addresses  #  of the authors are extracted from the SCM log. E.g. $ git log. CocoaPods also  #  accepts just a name if you'd rather not provide an email address.  #  #  Specify a social_media_url where others can refer to, for example a twitter  #  profile URL.  #  s.author             = { "charsdavy" =&gt; "charsdavy@gamil.com" }  s.social_media_url   = "https://twitter.com/charsdavy"  s.swift_version = "4.0"  # ――― Platform Specifics ――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  If this Pod runs only on iOS or OS X, then specify the platform and  #  the deployment target. You can optionally include the target after the platform.  #  s.platform     = :ios  s.platform     = :ios, "8.0"  #  When using multiple platforms  s.ios.deployment_target = "8.0"  # s.osx.deployment_target = "10.7"  # s.watchos.deployment_target = "2.0"  # s.tvos.deployment_target = "9.0"  # ――― Source Location ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  Specify the location from where the source should be retrieved.  #  Supports git, hg, bzr, svn and HTTP.  #  s.source       = { :git =&gt; "https://github.com/charsdavy/JCCNavigationController.git", :tag =&gt; "#{s.version}" }  # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  CocoaPods is smart about how it includes source code. For source files  #  giving a folder will include any swift, h, m, mm, c &amp; cpp files.  #  For header files it will include any header in the folder.  #  Not including the public_header_files will make all headers public.  #  s.source_files  = "JCCNavigationController/*.swift"  # s.exclude_files = "Classes/Exclude"  # s.public_header_files = "Classes/**/*.h"  # ――― Resources ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  A list of resources included with the Pod. These are copied into the  #  target bundle with a build phase script. Anything else will be cleaned.  #  You can preserve files from being cleaned, please don't preserve  #  non-essential files like tests, examples and documentation.  #  # s.resource  = "icon.png"  # s.resources = "Resources/*.png"  # s.preserve_paths = "FilesToSave", "MoreFilesToSave"  # ――― Project Linking ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  Link your library with frameworks, or libraries. Libraries do not include  #  the lib prefix of their name.  #  # s.framework  = "SomeFramework"  # s.frameworks = "SomeFramework", "AnotherFramework"  # s.library   = "iconv"  # s.libraries = "iconv", "xml2"  # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― #  #  #  If your library depends on compiler flags you can set them in the xcconfig hash  #  where they will only apply to your library. If you depend on other Podspecs  #  you can include multiple dependencies to ensure it works.  # s.requires_arc = true  # s.xcconfig = { "HEADER_SEARCH_PATHS" =&gt; "$(SDKROOT)/usr/include/libxml2" }  # s.dependency "JSONKit", "~&gt; 1.4"end以上文件，需要注意 s.platform 这个字段，文本中的注释说的很明白，默认是全平台都支持的，如果只支持某一个平台，则需要细心配置完善。验证 .podspec 文件是否合法$ pod spec lint JCCNavigationController.podspec如果配置文件仍存在错误，则根据错误提示修复错误。如果只有以下一个错误，则只需提交代码即可：ERROR | unknown: Encountered an unknown error (uninitialized constant REST::DisconnectedError) during validation.提交 .podspec 文件将 .podspec 文件提交至代码托管服务器，例如，将 JCCNavigationController.podspec 文件提交至 JCCNavigationController 项目。提交代码至 CocoaPods$ pod trunk push JCCNavigationController.podspec --allow-warnings返回以下信息则为成功：-------------------------------------------------------------------------------- 🎉  Congrats 🚀  JCCNavigationController (1.0) successfully published 📅  July 16th, 00:58 🌎  https://cocoapods.org/pods/JCCNavigationController 👍  Tell your friends!--------------------------------------------------------------------------------附录JCCNavigationControllerJCCNavigationController，一种导航栏一体化转场动画效果。DDCornerRadiusDDCornerRadius，优化圆角实现方案，避免离屏渲染。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> cocoapods </tag>
        
          <tag> 开源 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Tensorflow -- 基准]]></title>
      <url>/blog/tensorflow-performance-benchmarks/</url>
      <content type="text"><![CDATA[TensorFlow 社区创建了一系列用于多平台测试的图像分类模型参考点。在 方法 章节中会详细说明如何执行测试，并给出使用的脚本链接。图像分类模型的结果InceptionV3 (arXiv:1512.00567), ResNet-50(arXiv:1512.03385), ResNet-152(arXiv:1512.03385), VGG16(arXiv:1409.1556), 和AlexNet 使用 ImageNet 数据集测试。这些测试运行在 Google 计算云引擎，亚马逊计算云 (Amazon EC2) 和 NVIDIA® DGX-1™ 。大部分测试使用合成和真实的数据。对合成数据的测试是通过使用一个 tf.Variable 设置相同的 shape，除了每个 ImageNet 模型。我们认为，当评估一个平台的基准时包含真实数据是很重要的。底层硬件和框架的加载测试是为了训练实际数据。我们开始合成数据用来移除磁盘 I/O 作为一个变量，并设置一个基准。然后使用真实的数据来验证 TensorFlow 的输入和底层磁盘 I/O 的计算单元。使用 NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 训练  细节和附加结果在 NVIDIA® DGX-1™ (NVIDIA®Tesla® P100) 的细节 章节中。使用 NVIDIA® Tesla® K80 训练  细节和附加结果在 Google 计算引擎(NVIDIA® Tesla® K80) 的细节 和Amazon EC2 (NVIDIA® Tesla®K80) 的细节 章节中。使用 NVIDIA® Tesla® K80 分布式训练  细节和附加结果在 分布式 Amazon EC2(NVIDIA® Tesla® K80) 的细节章节中。比较合成和真实训练数据NVIDIA® Tesla® P100    NVIDIA® Tesla® K80    NVIDIA® DGX-1™ (NVIDIA® Tesla® P100) 的细节环境配置  Instance type: NVIDIA® DGX-1™  GPU: 8x NVIDIA® Tesla® P100  OS: Ubuntu 16.04 LTS with tests run via Docker  CUDA / cuDNN: 8.0 / 5.1  TensorFlow GitHub hash: b1e174e  Benchmark GitHub hash: 9165a70  Build Command: bazel build -c opt --copt=-march="haswell" --config=cuda//tensorflow/tools/pip_package:build_pip_package  Disk: Local SSD  DataSet: ImageNet  Test Date: May 2017每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3、ResNet-50、ResNet-152 和 VGG16 也用批处理大小为 32 进行测试。这些结果在 其他结果 章节。            Options      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  Batch size per GPU      64      64      64      512      64              Optimizer      sgd      sgd      sgd      sgd      sgd      用于每个模型的配置。            Model      variable_update      local_parameter_device                  InceptionV3      parameter_server      cpu              ResNet50      parameter_server      cpu              ResNet152      parameter_server      cpu              AlexNet      replicated (with NCCL)      n/a              VGG16      replicated (with NCCL)      n/a      结果      训练合成数据            GPUs      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  1      142      219      91.8      2987      154              2      284      422      181      5658      295              4      569      852      356      10509      584              8      1131      1734      716      17822      1081      训练真实数据            GPUs      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  1      142      218      91.4      2890      154              2      278      425      179      4448      284              4      551      853      359      7105      534              8      1079      1630      708      N/A      898      从上图表可以看出，由于最大输入的限制，AlexNet 模型没有使用 8 个 GPU 来训练数据。其他结果以下是批处理大小为 32 的结果。训练合成数据            GPUs      InceptionV3      ResNet-50      ResNet-152      VGG16                  1      128      195      82.7      144              2      259      368      160      281              4      520      768      317      549              8      995      1485      632      820      训练真实数据            GPUs      InceptionV3      ResNet-50      ResNet-152      VGG16                  1      130      193      82.4      144              2      257      369      159      253              4      507      760      317      457              8      966      1410      609      690      Google Compute Engine (NVIDIA® Tesla® K80) 的细节环境配置  Instance type: n1-standard-32-k80x8  GPU: 8x NVIDIA® Tesla® K80  OS: Ubuntu 16.04 LTS  CUDA / cuDNN: 8.0 / 5.1  TensorFlow GitHub hash: b1e174e  Benchmark GitHub hash: 9165a70  Build Command: bazel build -c opt --copt=-march="haswell" --config=cuda//tensorflow/tools/pip_package:build_pip_package  Disk: 1.7 TB Shared SSD persistent disk (800 MB/s)  DataSet: ImageNet  Test Date: May 2017每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 其他结果 章节。            Options      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  Batch size per GPU      64      64      32      512      32              Optimizer      sgd      sgd      sgd      sgd      sgd      每个模型所用的配置中， variable_update 和 parameter_server 配置相同，local_parameter_device 和 cpu 配置相同。结果    训练合成数据            GPUs      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  1      30.5      51.9      20.0      656      35.4              2      57.8      99.0      38.2      1209      64.8              4      116      195      75.8      2328      120              8      227      387      148      4640      234      训练真实数据            GPUs      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  1      30.6      51.2      20.0      639      34.2              2      58.4      98.8      38.3      1136      62.9              4      115      194      75.4      2067      118              8      225      381      148      4056      230      其他结果训练合成数据            GPUs      InceptionV3 (batch size 32)      ResNet-50 (batch size 32)                  1      29.3      49.5              2      55.0      95.4              4      109      183              8      216      362      训练真实数据            GPUs      InceptionV3 (batch size 32)      ResNet-50 (batch size 32)                  1      29.5      49.3              2      55.4      95.3              4      110      186              8      216      359      Amazon EC2 (NVIDIA® Tesla® K80) 的细节环境配置  Instance type: p2.8xlarge  GPU: 8x NVIDIA® Tesla® K80  OS: Ubuntu 16.04 LTS  CUDA / cuDNN: 8.0 / 5.1  TensorFlow GitHub hash: b1e174e  Benchmark GitHub hash: 9165a70  Build Command: bazel build -c opt --copt=-march="haswell" --config=cuda//tensorflow/tools/pip_package:build_pip_package  Disk: 1TB Amazon EFS (burst 100 MiB/sec for 12 hours, continuous 50MiB/sec)  DataSet: ImageNet  Test Date: May 2017每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 其他结果 章节。            Options      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  Batch size per GPU      64      64      32      512      32              Optimizer      sgd      sgd      sgd      sgd      sgd      用于每个模型的配置。            Model      variable_update      local_parameter_device                  InceptionV3      parameter_server      cpu              ResNet-50      replicated (without NCCL)      gpu              ResNet-152      replicated (without NCCL)      gpu              AlexNet      parameter_server      gpu              VGG16      parameter_server      gpu      结果    训练合成数据            GPUs      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  1      30.8      51.5      19.7      684      36.3              2      58.7      98.0      37.6      1244      69.4              4      117      195      74.9      2479      141              8      230      384      149      4853      260      训练真实数据            GPUs      InceptionV3      ResNet-50      ResNet-152      AlexNet      VGG16                  1      30.5      51.3      19.7      674      36.3              2      59.0      94.9      38.2      1227      67.5              4      118      188      75.2      2201      136              8      228      373      149      N/A      242      由于我们的 EFS 没有提供足够的吞吐量，上面的图表中我们排出了使用 8 个 GPU 来训练 AlexNet 模型的统计。其他结果训练合成数据            GPUs      InceptionV3 (batch size 32)      ResNet-50 (batch size 32)                  1      29.9      49.0              2      57.5      94.1              4      114      184              8      216      355      训练真实数据            GPUs      InceptionV3 (batch size 32)      ResNet-50 (batch size 32)                  1      30.0      49.1              2      57.5      95.1              4      113      185              8      212      353      Amazon EC2 Distributed (NVIDIA® Tesla® K80) 的细节环境配置  Instance type: p2.8xlarge  GPU: 8x NVIDIA® Tesla® K80  OS: Ubuntu 16.04 LTS  CUDA / cuDNN: 8.0 / 5.1  TensorFlow GitHub hash: b1e174e  Benchmark GitHub hash: 9165a70  Build Command: bazel build -c opt --copt=-march="haswell" --config=cuda//tensorflow/tools/pip_package:build_pip_package  Disk: 1.0 TB EFS (burst 100 MB/sec for 12 hours, continuous 50 MB/sec)  DataSet: ImageNet  Test Date: May 2017每个模型的批处理大小和优化器如下表所示。除了下表所示的批处理大小，InceptionV3 和 ResNet-50 也用批处理大小为 32 进行测试。这些结果在 其他结果 章节。            Options      InceptionV3      ResNet-50      ResNet-152                  Batch size per GPU      64      64      32              Optimizer      sgd      sgd      sgd      用于每个模型的配置。            Model      variable_update      local_parameter_device      cross_replica_sync                  InceptionV3      distributed_replicated      n/a      True              ResNet-50      distributed_replicated      n/a      True              ResNet-152      distributed_replicated      n/a      True      为了简化服务器设置，EC2 实例（p2.8xlarge）运行了 worker 服务器和 parameter 服务器。相同数量的 worker 服务器和 parameter 服务器使用了下述的配置：  InceptionV3: 8 instances / 6 parameter servers  ResNet-50: (batch size 32) 8 instances / 4 parameter servers  ResNet-152: 8 instances / 4 parameter servers结果    训练合成数据            GPUs      InceptionV3      ResNet-50      ResNet-152                  1      29.7      52.4      19.4              8      229      378      146              16      459      751      291              32      902      1388      565              64      1783      2744      981      其他结果  训练合成数据            GPUs      InceptionV3 (batch size 32)      ResNet-50 (batch size 32)                  1      29.2      48.4              8      219      333              16      427      667              32      820      1180              64      1608      2315      方法上述结果是使用该 脚本 运行在各种平台上而生成。《High-Performance Models》 文章详细描述了脚本中的技术，以及如何执行脚本的示例。为了创建尽可能重复的结果，每个测试运行 5 次，然后取平均值。在给定的平台上，GPU 是在默认状态下运行的。对于 NVIDIA® Tesla® K80 来说这意味着不使用 GPUBoost。对于每个测试，需要完成 10 次预热，然后再平均完成 100 次测试。      原文地址：https://www.tensorflow.org/performance/benchmarks    译文出自：掘金翻译计划    译者：charsdavy    校对者：joyking7    掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。]]></content>
      <categories>
        
          <category> ml </category>
        
      </categories>
      <tags>
        
          <tag> 掘金翻译计划 </tag>
        
          <tag> tensorflow </tag>
        
          <tag> 性能 </tag>
        
          <tag> 机器学习 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[数据链路层之 LLDP]]></title>
      <url>/blog/data-link-layer-lldp/</url>
      <content type="text"><![CDATA[随着网络技术的发展，接入网络的设备的种类越来越多，配置越来越复杂，来自不同设备厂商的设备也往往会增加自己特有的功能，这就导致在一个网络中往往会有很多具有不同特性的、来自不同厂商的设备，为了方便对这样的网络进行管理，就需要使得不同厂商的设备能够在网络中相互发现并交互各自的系统及配置信息。 LLDP（Link Layer Discovery Protocol，链路层发现协议）就是用于这个目的的协议。LLDP 定义在 802.1ab 中，它是一个二层协议，它提供了一种标准的链路层发现方式。LLDP 协议使得接入网络的一台设备可以将其主要的能力，管理地址，设备标识，接口标识等信息发送给接入同一个局域网络的其它设备。当一个设备从网络中接收到其它设备的这些信息时，它就将这些信息以MIB的形式存储起来。这些 MIB 信息可用于发现设备的物理拓扑结构以及管理配置信息。需要注意的是 LLDP 仅仅被设计用于进行信息通告，它被用于通告一个设备的信息并可以获得其它设备的信息，进而得到相关的 MIB 信息。它不是一个配置、控制协议，无法通过该协议对远端设备进行配置，它只是提供了关于网络拓扑以及管理配置的信息，这些信息可以被用于管理、配置的目的，如何用取决于信息的使用者。结构LLDP 的框架结构如图所示此图也表明 LLDP 就是一个信息发现与通告协议，LLDP 的实体主要维护了两个 MIB 库，一个 local system MIB，一个 remote system MIB。从其名字也可以看出，一个用于维护本地相关的设备 MIB 信息，一个用于维护远端设备 MIB 信息。LLDP 通过与上图中右侧的几个 MIB 库交互来初始化并维护 local system MIB，并将本地的相关信息通告出去；同时当接收到来自其它设备的信息时就将其更新到remote system MIB 中。通过这种工作方式，一个设备就可以将自己的信息通告出去并获得网络中其它设备的相关信息，最终获得反应网络拓扑以及其它配置信息的两个 MIB 库。这两个库可以被其用户用来完成各种功能。需要说明的是LLDP 信息的通告以及接收处理不受端口的STP状态的影响。基本概念帧格式封装有 LLDPDU 的报文称为 LLDP 帧，其封装格式有两种：Ethernet II 和 SNAP（Subnetwork Access Protocol，子网访问协议）。Ethernet II 格式封装的 LLDP 帧上图是以 Ethernet II 格式封装的 LLDP 帧，其中各字段的含义如下：   DA：目的 MAC 地址，为固定的组播 MAC 地址 0x0180-C200-000E。   SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。 指与设备相邻连接设备的桥 MAC。  LLDP Ethertype：帧类型，为 0x88CC。   LLDPDU：LLDP Data Unit，LLDP 数据单元，它是 LLDP 信息交换的主体。  FCS：帧检验序列。SNAP 格式封装的 LLDP 帧上图是以 SNAP 格式封装的 LLDP 帧，其中各字段的含义如下：  DA：目的 MAC 地址，为固定的组播 MAC 地址 01-80-C2-00-00-0E。   SA：源 MAC 地址，为端口 MAC 地址或设备 MAC 地址（如有端口地址则用端口 MAC 地址，否则用设备 MAC 地址）。   Type：帧类型，为 0xAAAA-0300-0000-88CC。   Data：数据，为 LLDPDU。   FCS：帧检验序列。目的地址目的地址实际上包括三个，分别为 01-80-C2-00-00-0E，01-80-C2-00-00-03，01-80-C2-00-00-00。这三个地址分别用于不同的目的，它们可以跨越不同的网络。  01-80-C2-00-00-0E，也被称为 Nearest Bridge 组地址：无论是 Two-Port MAC Relay (TPMR)组件、S-VLAN 组件、C-VLAN 组件，还是 802.1D 网桥都不能转发目的为该地址的帧。简单的说任何类型的网桥都不能转发目的为该地址的帧，目的为该地址的帧被限制在连接两个网桥接口的连接上传输。  01-80-C2-00-00-03，也被称为 Nearest non-TPMR Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件将成为一个中继器，即不接收它。而 S-VLAN（Service Provider VLAN）组件，C-VLAN（Customer VLAN）组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR。  01-80-C2-00-00-00，也被称为 Nearest Customer Bridge 组地址：对于目的地址为该地址的帧，Two-Port MAC Relay (TPMR)组件以及 S-VLAN 组件将成为中继器，即不接收它。而 C-VLAN 组件，以及 802.1D 网桥都不能转发它，而是需要进行接收并处理。因此目的地址为该地址的帧将跨越 TPMR 以及 S-VLAN。TPMR 介绍TPMR 以及 S-VLAN，C-VLAN 都是 802.1Q 中的概念，包括这三者的网络以及各个地址的作用范围如下图所示  C-VLAN：Customer VLAN，是用户网络内部使用的 VLAN；  S-VLAN：Service VLAN，服务提供商网络中使用的 VLAN，该 VLAN 标识 VPN 用户或者是用户的业务；  Customer Bridge: Customer 网络中的 Bridge，只能识别 C-VLAN；  Provider Bridge：服务提供商网络中的 Bridge，根据处理内容的不同又分为S-VLAN Bridge 和 Provider Edge Bridge。其中 S-VLAN Bridge 只能识别 S-VLAN； Provider Edge Bridge 可以同时识别 C-VLAN 和 S-VLAN；  C-VLAN Component：在 Bridge 内可识别、插入、删除 C-VLAN 的实体，每个端口一个，对 C-VLAN 的操作互相独立（两个端口上接收到相同的 C-VLAN，但由于属于不同的客户最后的处理结果会不同）；  S-VLAN Component：在 Bridge 内可识别、插入、删除 S-VLAN 的实体，由于在一个 Bridge 内不存在相同的 S-VLAN 属于不同服务提供商的情况，因此在一个桥内只有一个 S-VLAN 的实体。QinQ 介绍QinQ 的理论基础，是 IEEE 定义的 802.1ad。在这个规范里面，IEEE 提出了一个概念，它认为汇聚和接入层那里有这么两种设备：S-VLAN Bridge 和 Provider Edge Bridge，再往下就是 Customer System 了（注意，这里说 System 而不是 Bridge，是因为 Customer 接进来的未必是二层设备，可能也是三层设备）。VLAN 空间也被分成两个 VLAN 空间，即 S-VLAN 和 C-VLAN，S 即 Service Provider，C 即 Customer。在 S-VLAN Bridge 上，只有 S-VLAN 空间，而在 Provider Edge Bridge 上，则既有 S-VLAN 空间，又有 C-VLAN 空间。相应的，这个 Bridge 就被从逻辑上划分为两部分，支持 S-VLAN 功能的部分称之为 S-VLAN Component，支持 C-VLAN 功能的部分称之为 C-VLAN Component。S-VLAN Bridge 只包含 S-VLAN Component。除了两种 Bridge 的概念，802.1ad 还提出了三种 Service 类型和四种 Port 类型，其中一种 Port 是内部 Port，对用户不可见，其它三种 Port 分别对应了三种不同的 Service，即运营商可以通过在交换机上配置三种不同的 Port 类型，来相应的为用户提供三种不同类型的 Service。三种 Service 分别是 Port Based Service，C-Tag Based Service 和 S-Tag Based Service。四种Port 分别是 Customer Network Port （CN）， Customer Edge Port（CE），Provider Network Port（PN），Provider Edge Port（内部 Port）。所谓 Port Based Service，就是说某个 Service 是基于 Port 的，从该 Port 进来的所有报文，都被认为是属于某一个特定的 Customer 的，不管它是否带 C-Tag，带了什么样的 C-Tag，这些信息统统被忽视。所有从这个 Port 进来的报文被赋予一个 S-VLAN，该 S-VLAN 被用来标识该 Customer，或说该 Service。提供这种 Service 的 Port 就是CN Port。CN Port 的实质就是运营商为一个 Customer 提供一个专门的 Port，不跟别的 Customer 共享。注意，从这个 Port 上进来的报文不能带 S-Tag，否则会被丢弃。也就是说，对于 S-Tag 而言，这个 Port 是 Access Port，而不是 Trunk Port。这是跟后面的 S-Tag Based service 本质的不同。所谓的 S-Tag Based Service，就是说从一个 Port 上进来的报文，根据 S-VLAN 来把它们划分到不同的 Customer，换句话说，是用 S-VLAN 来标记 Customer。提供这种 Service 的 Port 也是 CN Port，只不过这个时候的 CN Port，必须配置成 Trunk Port，只识别 S-VLAN，根据 S-VLAN 来标识 Customer，转发报文。所谓的 C-Tag Based Service，就是指报文携带 C-Tag 进入 Port，在该 Port 上基于 C-VLAN 来标识 Customer，一个 Port 上可以支持多个 Customer。用来支持 C-Tag Based Service 的 Port 就是 CE Port，CE Port 是 C-VLAN Component 的一部分，对于 C-VLAN 而言，CE Port 是 Trunk Port。它不识别 S-Tag。PN Port 是 S-VLAN Component 的一部分，它跟 CN Port 唯一的不同是 CN Port 面向 Customer Network，而它面向 Provider Network，在实际的交换机中通常被配置成 Uplink Port，而且通常都是 VLAN Trunk Mode（相对于 Access Mode）。对于一个拥有 S-VLAN Component 和 C-VLAN Component 的 Provider Edge Bridge 而言，在做 Mac Forwarding/Learning 的时候，有两种模式，一种是用 S-VLAN+MAC，另外一种则是 S-VLAN+C-VLAN+MAC，前者即所谓的 C-VLAN Unaware Mode，而后者则是 C-VLAN Aware Mode。C-VLAN Aware Mode 带来的好处是显而易见的，因为它将 VLAN 空间从 4K 扩展到了 16M，但是它的问题在于，当前绝大多数芯片都不支持，就算支持了，也不太可能支持到理论上的 16M。一种独创的 QinQ 模式现实世界中用户的需求是千奇百怪，有一种需求，是市场上现存的交换机所解决不了的。在讨论这种需求之前，先看一下当前交换机的做法。无论各个厂家的实现差别有多大，但是有一点大家都是一样的，就是在接入交换机上，通过 Port 或者 C-VLAN 来识别用户，然后为每个用户分配一个 S-VLAN，然后用 S-VLAN 来做后续处理，如 ACL/QoS/Mac Learning/Mac Forwarding 等。但是运营商，特别是欧美的一些运营商可能有这样的需求，为了描述的方便，我们假设有个运营商 A，它在为它的客户提供服务的时候，有的时候需要租用别的运营商，假设是运营商 B 的网络，在租用网络的时候，A 这些 B 的客户，运营商 B 需要给 A 分配 S-VLAN，而且往往是一个 S-VLAN 多少钱，因为 VLAN 是稀缺资源，特别是网络比较大的时候。这个时候，如果运营商 A 为它自己的客户每个都分配一个 S-VLAN，那么相应的它就需要向 B 也申请很多个 S-VLAN，不划算，这个时候它就想在自己的接入设备上，不用 S-VLAN 来标识 Customer，给所有的 Customer 分配同一个 S-VLAN，用该 S-VLAN 来穿越 B 的网络，这个时候，S-VLAN 的意义不是代表 Customer，而是代表一个 Tunnel。问题关键在于，如果不用 S-VLAN 来代表 Customer，在 A 的接入设备上，如何来对不同的 Customer 来做区分处理呢？用 C-VLAN 肯定是不行的，因为不同 Port 上的 C-VLAN 代表的 Customer 可能是不同的。Centec 的交换机，在芯片内部用一个不同于 C-VLAN 和 S-VLAN 的 CustomerID 来标识 Customer，用这个值来做后续的一系列 Customer 的处理，非常强大。QinQ 的不足尽管 QinQ 貌似很好很强大，并且受到热烈追捧，但是这不能掩盖它的先天不足。QinQ 的最大不足就是它无法对运营商网络完全隐藏 Customer 信息，因为它可以让运营商 Core Network 的设备看不到 Customer VLAN，但是无法让它们看不到 Customer MAC。而这一点有两个不利的影响，一个是 Scalability 非常差，如果中间的设备都是二层设备，会导致 MAC 表非常大；第二个不利的影响则是，一旦 Customer 网络出现了环路，会导致 Provider Network 里面的设备不断进行 MAC Learning，万一有 ARP 之类报文，还可能冲击 CPU。如果 Customer VLAN 对运营商网络不可见，那么就起不到扩展 VLAN 空间的作用，运营商的 VLAN 空间就仍然只有 4K。而 PBB，即所谓的 MAC-in-MAC 则能很好的解决 QinQ 的这个不足，因为 PBB 不仅在原来的报文上新增一个 VLAN，还新增 MACSa/MACDa 以及 24 个 bit 的 Isid（用来标识 Service），它可以完全对运营商的 Core Network 设备隐藏 Customer 信息，且能利用 Isid 来支持 16M Customer/Service。当然PBB也有PBB的问题，目前看不到它有成为主流技术的趋势。LLDPDULLDPDU 是 LLDP 的有效负载，用于承载要发送的消息。LLDPDU 的格式如下图所示LLDPDU 采用了 TLV 的格式，即 type+length+value 的格式，type 表示 TLV 的类型，length 是以字节为单位的 TLV 的长度，value 是该 TLV 的值。其中 Chassis ID TLV，Port ID TLV Time To Live TLV 以及 End Of LLDPDU TLV 是强制的，必须包含的部分，除此之外在 TLV Time To Live TLV 和 End Of LLDPDU TLV 之间可以包含 0 个到多个可选的其它 TLV。TLVTLV 是组成 LLDPDU 的单元，每个 TLV 都代表一个信息。LLDPDU 的 TLV 可以分为两大类  被认为是网络管理的基础的 TLV 集合，所有的 LLDP 实现都需要支持。  组织定义的 TLV 扩展集合，包括 802.1 组织定义 TLV、802.3 组织定义 TLV 以及其他组织定义的 TLV。这些 TLV 用于增强对网络设备的管理，可根据实际需要选择是否在 LLDPDU 中发送。 TLV 的基本格式如图所示TLV的类型域的定义及分配如下图所示其中 type0-8 属于基本的 TLV 集合。对于其中的 Mandatory 的 TLV，它是必须包含在 LLDP 中的。 组织定义 TLV 集合的格式如下图所示其中  OUI：组织机构的 ID。  organizationally defined subtype：组织自定义的类型。  organizationally defined information string：传输的信息。基础 TLV 集合几个强制的必须包含的 TLV 的定义如下。非强制的可以参考 IEEE802.1AB。End Of LLDPDU TLV该 TLV 用于标识 LLDPDU 的结束。其格式如下由于 length=0，因此它不包含 value 域。Chassis ID TLV该 TLV 用于通告该 LLDPDU 发送者的 Chassis ID。由于有很多方式可用来标识一个 Chassis，因此在该类 TLV 中包含一个子类型域用于告诉接收者，发送者的 Chassis ID 采用的是哪一种标识方式。其格式如图所示每个 LLDPDU 必须包含且仅包含一个该类型的 TLV。由于 Chassis ID 实际上是用于标识设备的，因此在连接可用时它应该保持不变。 Chassis 子类型所可能的取值如图所示Port ID TLV它用于标识发送该 LLDPDU 的设备的端口。类似于 Chassis ID，有很多方式可以标识一个 Port，因此该 TLV 也包含一个子类型域。其格式如下图所示每个 LLDPDU 必须包含一个且只能包含一个该类型的 TLV。同时，当端口可用时，从该端口发送出去的 LLDPDU 的该 TLV 应该保持不变。 其子类型的可能取值如下图所示Time To Live TLV该 TLV 用于告诉接收端，它接收到的这些信息的有效期有多长。其格式如图所示TTL 的时间单位是秒，由于只有 2 个字节长，因而最大有效时间是 65536 秒。如果在这个时间到期了还没有新的 LLDPDU 被收到，则该 TLV 所属的那个 LLDPDU 携带的信息会被从 MIB 中删除。如果收到了新的 LLDPDU，则  如果 TTL 不为 0，则会用新收到的 LLDPDU 的信息替换 MIB 库中的相应的信息（即与该 LLDPDU 的发送者相关的 MIB 信息，LLDP 使用 Chassis ID+Port ID 来判断是否来自于同一个源，这也是要求这两者保持不变的原因）。  如果 TTL 为 0，则删除相应的 MIB 库中的信息（即与该 LLDPDU 的发送者相关的 MIB 信息）。因此 TTL 为 0 的 LLDPDU 又被称为SHUTDOWN LLDPDU。每一个 LLDPDU 必须包含且只能包含一个该类型的 TLV。工作机制LLDP 是一个用于信息通告和获取的协议，但是需要注意的一点是，LLDP 发送的信息通告不需要确认，不能发送一个请求来请求获取某些信息，也就是说 LLDP 是一个单向的协议，只有主动通告一种工作方式，无需确认，不能查询、请求（比如像 ARP 协议那样请求某个 IP 的 MAC 地址）。LLDP 主要完成如下工作：  初始化并维护本地 MIB 库中的信息。  从本地 MIB 库中提取信息，并将信息封装到 LLDP 帧中。LLDP 帧的发送有两种触发方式，一是定时器到期触发，一是设备状态发生了变化触发。  识别并处理接收到的 LLDPDU 帧。  维护远端设备 LLDP MIB 信息库。  当本地或远端设备 MIB 信息库中有信息发生变化时，发出通告事件。LLDPDU 发送发送机制LLDPDU 的发送可以被如下事件触发：  与本地 MIB 信息库相关联的定时器 txTTR 到期时，这将确保远端接收系统中的相关信息不会因为 TTL 到期而过期。  本地 MIB 信息库中的信息发生了改变时，会立即发送 LLDPDU，这将保证改变能及时被更新。  如果一个“新邻居”被识别，将会启用快速发送机制，在很短的时间内连续发送指定数量（txFastInit，默认值为 4）的 LLDPDU，以确保“新邻居”能被快速更新。如果远端系统 MIB 信息库因为过载（tooManyNeighbors）而不能容纳新的邻居信息，则会为了避免过多的LLDPDU 传输而抑制快速发送行为。LLDP 的常规发送时间是建立在系统的 Tick 之上的，间隔为 1 秒一个，为了防止在共享介质的 LAN（shared media LAN）中同时出现大量的 LLDPDU（因为接入同一个LAN的多个系统的时间是同步的，因而多个系统上的基于 Tick 的1秒定时器可能同时到期），发送定时器引入了一个随机的抖动，这就使得常规的 LLDP 帧的发送间隔时间的平均值仍是 1 秒，但是具体到某一次到期时间可能并不是准确的 1 秒。同时为了防止在有多个端口需要发送 LLDPDU 的系统中，所有的端口的定时器都在同一时间到期，因而标准建议将采用某种机制将多个发送实例的定时器到期时间给错开，以避免一个系统在同一时刻发送大量的 LLDPDU。发送状态机LLDPDU 的发送状态机如图所示对于该状态机：  为了防止过于频繁的重新初始化发送状态机，在 LLDP 的发送状态机中引入了一个延时，该延时限制了在关闭发送状态机后，必须至少等待多长时间才能重新初始化发送状态机。  是否发送 SHUTDOWN LLDPDU 由本地的 LLDP 工作状态决定。  是否发送正常的 LLDPDU 由 txNow 和 txCredit 决定。这两个变量都由发送定时器状态机更新。txNow 决定是否发送，而 txCredit 则是一个信用量，决定了可以发送的量，如果是 0 则不允许发送，只有大于 0 的值才允许发送，每发送一个该值就减 1。更重要的是在本地信息快速改变时，txCredit 既允许连续发送多个 LLDPDU，但是又对可以连续发送的 LLDPDU 帧数做了限制，这使得本地状态的快速改变可以及时被通告出去，但是又不能无限发送导致网络出现大量 LLDPDU 帧。发送定时器状态机LLDP 发送定时器状态机如图所示localChange 表示本地信息是否发生改变；txTTR 表示下一次定时器到期的时间；newNeighbor 表示是否发现了新的邻居，并由接收状态设置，由该状态机清除；txTick 表示基于系统时间的1秒定时器是否到期。对于该状态机：  SIGNAL_TX 用于触发发送，它会将 txNow 设置为允许发送，并设置本地信息发生改变为 FALSE，如果当前不是在快速发送状态（txFast = 0）就设置发送定时器下次到期时间为 msgTxInterval（msgTxInterval默认为30秒，取值范围1-3600秒），否则设置发送定时器下次到期时间为 msgFastTx（msgFastTx默认值为1秒，取值范围1-3600秒）。  如果本地信息发生了改变，就立即进入 SIGNAL_TX。  如果定时器到期，则如果 txFast 大于 0，则将其减 1 并进入 SIGNAL_TX，否则直接进入 SIGNAL_TX。  如果发现了新邻居，则首先将发现新邻居的标识更新为没有发现新邻居，然后如果当前已经处于快速发送状态就直接进入发送定时器到期状态（以触发一次立即发送），否则设置 txFast 的值为 txFastInit 的值（txFastInit 默认值为 4，取值范围 1-8）。  如果基于系统时间的 1 秒定时器到期，则给 txCredit 增加信用量，其最大值为 txCreditMax，txCreditMax 是一个取值在 1 到 10 之间的值，默认值为 5。这里有取值范围的几个变量都是可配置的变量。从上述两个状态机的工作状态可以看出，发送定时器状态机用于维护信用量以及是否允许发送 LLDPDU 帧，而发送状态机根据这两个信息来决定是否发送。另外需要注意的是 LLDP 所使用的所有定时器操作都是“基于系统时间的 1 秒定时器的”，每当这个定时器到期时它除了会将 txTick 设置为 TRUE 外，还会处理其它的定时功能。LLDPDU 接收接收机制LLDP 帧的接收由 3 个阶段组成：帧的识别、帧的校验、LLDP 远端 MIB 信息库更新。帧的识别由在 LLDP/LSAP（链路服务访问点）进行，检查的内容是帧的目的地是否是 LLDP 的组播 MAC 地址，帧的类型是否是 LLDP。帧的验证该过程会首先根据 TLV 的格式定义依次校验 Chassis ID TLV，Port ID TLV， Time To Live TLV，如果这三个 TLV 都存在且有效，才会进一步的解码可选的 TLV 直到遇到 End Of LLDPDU TLV，然后根据获得的信息更新远端 MIB 信息库。远端 MIB 信息库更新在前两步都通过之后，LLDPDU 的接收者就需要根据解析出来的信息更新远端 MIB 信息库。在 MIB 信息库中，LLDP 使用 Chassis ID+Port ID 来标识、存储来自不同源的信息。  如果远端MIB库中已经有对应于该 Chassis ID+Port ID 的信息，则使用收到的帧中的新的 TTL 来更新 TTL。并用对于收到的新的 LLDPPDU 中的每一种 type，如果有变化就进行更新，如果某种 type 原来不存在，则需要将其添加到 MIB 库中。  如果实现不支持某种类型的 type，则          如果 type 不是 127，则按照基本 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value。      如果 type 是 127，则按照组织定义 TLV 的格式将其存储到远端 MIB 库，存储格式为 type，length，value，OUI，组织自定义子类型，以及信息域。      更新时，如果需要添加新的 Chassis ID+Port ID 的表项，或者为某个 Chassis ID+Port ID 添加新的 TLV，则可能遇到没有内存的问题，标准没有规定必须如何处理，只是给出了一些建议：  忽略新的 LLDPDU 的信息  删除最旧的信息以释放空间给新的信息  随机删除一些旧的信息以释放空间给新的信息LLDPDU 携带的 TTL（Time To Live）值会影响接收端的处理方式，如果它不为 0，则更新相应信息的老化时间，如果接收到的 LLDPDU 中的 TTL 等于 0，则将立刻老化掉相应的信息（即与该 LLDPDU 的发送者相关的MIB信息）。如果一个 Chassis ID+Port ID 标识的信息的 TTL 超时，则相应的 MIB 信息会被删除。接收状态机LLDPDU 的接收状态机如图所示LLDP 工作模式LLDP 可以工作在多种模式下：  TxRx：既发送也接收 LLDP 帧。  Tx：只发送不接收 LLDP 帧。  Rx：只接收不发送 LLDP 帧。  Disable：既不发送也不接收 LLDP 帧（准确的说，这并不是一个 LLDP 的状态，这可能是 LLDP 功能被关闭了，也可能是设备就不支持）。由于 LLDP 可以单独工作在发送或接收模式下，因此 LLDP 协议的实现需要支持单独初始化发送或者接收功能。当工作模式发生变化时，需要根据老的/新的工作模式来关闭/打开发送或者接收的功能。至此，LLDP 相关知识点已经介绍完，希望对大家有所帮助。]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> LLDP </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[TensorFlow 广度和深度学习的教程]]></title>
      <url>/blog/tensorflow-wide-and-deep/</url>
      <content type="text"><![CDATA[在前文 《TensorFlow Liner Model Tutorial》 中，我们使用 人口收入普查数据集 训练了一个 logistic 线性回归模型去预测个人年收入超过 5 万美元的概率。TensorFlow 在训练深度神经网络方面效果也很好，那么你可能会考虑该如何取舍它的功能了 – 可是，为什么不选择两者兼得呢？那么，是否可以将两者的优势结合在一个模型中呢？在这篇文章中，我们将会介绍如何使用 TF.Learn API 同时训练一个广度线性模型和一个深度前馈神经网络。这种方法结合了记忆和泛化的优势。它在一般的大规模回归和具有稀疏输入特性的分类问题（例如，分类特征存在一个很大的可能值域）上很有效。如果你有兴趣学习更多关于广度和深度学习如何工作的问题，请参考 研究论文现在，我们来看一个简单的例子。上图展示了广度模型（具有稀疏特征和转换性质的 logistic 回归模型），深度模型（具有一个嵌入层和多个隐藏层的前馈神经网络），广度和深度模型（两者的联合训练）的区别比较。在高层级里，只需要通过以下三个步骤就能使用 TF.Learn API 配置广度，深度或广度和深度模型。1.选择广度部分的特征：选择要使用的稀疏基本列和交叉列。2.选择深度部分的特征：选择连续列，每个分类列的嵌入维度和隐藏层大小。3.将它们一起放入广度和深度模型（DNNLinearCombinedClassifier）。安装如果想要尝试本教程中的代码：1.安装 TensorFlow ，请前往此处。2.下载 教程代码。3.安装 pandas 数据分析库。因为本教程中需要使用 pandas 数据。虽然 tf.learn 不要求 pandas，但是它支持 pandas。安装 pandas：a. 获取 pip：# Ubuntu/Linux 64-bit$ sudo apt-get install python-pip python-dev# Mac OS X$ sudo easy_install pip$ sudo easy_install --upgrade sixb. 使用 pip 安装 pandas$ sudo pip install pandas如果你在安装过程中遇到问题，请前往 pandas 网站上的 说明 。4.执行以下命令来训练教程中描述的线性模型：$ python wide_n_deep_tutorial.py --model_type=wide_n_deep请继续阅读，了解此代码如何构建其线性模型。定义基本特征列首先，定义我们使用的基本分类和连续特征的列。这些列将被作为模型的广度部分和深度部分的构件块。import tensorflow as tfgender = tf.feature_column.categorical_column_with_vocabulary_list(    "gender", ["Female", "Male"])education = tf.feature_column.categorical_column_with_vocabulary_list(    "education", [        "Bachelors", "HS-grad", "11th", "Masters", "9th",        "Some-college", "Assoc-acdm", "Assoc-voc", "7th-8th",        "Doctorate", "Prof-school", "5th-6th", "10th", "1st-4th",        "Preschool", "12th"    ])marital_status = tf.feature_column.categorical_column_with_vocabulary_list(    "marital_status", [        "Married-civ-spouse", "Divorced", "Married-spouse-absent",        "Never-married", "Separated", "Married-AF-spouse", "Widowed"    ])relationship = tf.feature_column.categorical_column_with_vocabulary_list(    "relationship", [        "Husband", "Not-in-family", "Wife", "Own-child", "Unmarried",        "Other-relative"    ])workclass = tf.feature_column.categorical_column_with_vocabulary_list(    "workclass", [        "Self-emp-not-inc", "Private", "State-gov", "Federal-gov",        "Local-gov", "?", "Self-emp-inc", "Without-pay", "Never-worked"    ])# 展示一个哈希的例子：occupation = tf.feature_column.categorical_column_with_hash_bucket(    "occupation", hash_bucket_size=1000)native_country = tf.feature_column.categorical_column_with_hash_bucket(    "native_country", hash_bucket_size=1000)# 连续基列age = tf.feature_column.numeric_column("age")education_num = tf.feature_column.numeric_column("education_num")capital_gain = tf.feature_column.numeric_column("capital_gain")capital_loss = tf.feature_column.numeric_column("capital_loss")hours_per_week = tf.feature_column.numeric_column("hours_per_week")# 转换age_buckets = tf.feature_column.bucketized_column(    age, boundaries=[18, 25, 30, 35, 40, 45, 50, 55, 60, 65])广度模型：具有交叉特征列的线性模型广度模型是一个具有稀疏和交叉特征列的线性模型：base_columns = [    gender, native_country, education, occupation, workclass, relationship,    age_buckets,]crossed_columns = [    tf.feature_column.crossed_column(        ["education", "occupation"], hash_bucket_size=1000),    tf.feature_column.crossed_column(        [age_buckets, "education", "occupation"], hash_bucket_size=1000),    tf.feature_column.crossed_column(        ["native_country", "occupation"], hash_bucket_size=1000)]具有交叉特征列的广度模型可以有效地记忆特征之间的稀疏交互。也就是说，交叉特征列不能概括没有在训练数据中出现的特征组合。让我们采用嵌入方式来添加一个深度模型来修复这个问题。深度模型：嵌入式神经网络深度模型是一个前馈神经网络，如前图所示。每一个稀疏，高维度分类特征首先都会被转换成一个低维度密集的实值矢量，通常被称为嵌入式矢量。这些低维度密集的嵌入式矢量与连续特征相连，然后在正向传递中馈入神经网络的隐藏层。嵌入值随机初始化，并与其他模型参数一起训练，以最大化减少训练损失。如果你有兴趣了解更多关于嵌入的知识，请在查阅教程 Vector Representations of Words 或在 Wikipedia 上查阅 Word Embedding。我们将使用 embedding_column 配置分类嵌入列，并将它们与连续列连接：deep_columns = [    tf.feature_column.indicator_column(workclass),    tf.feature_column.indicator_column(education),    tf.feature_column.indicator_column(gender),    tf.feature_column.indicator_column(relationship),    # 展示一个嵌入例子    tf.feature_column.embedding_column(native_country, dimension=8),    tf.feature_column.embedding_column(occupation, dimension=8),    age,    education_num,    capital_gain,    capital_loss,    hours_per_week,]嵌入的 dimension 越高，自由度就越高，模型将不得不学习这些特性的表示。为了简单起见，我们设置所有特征列的维度为 8。从经验上看，关于维度的设定最好是从 \log_{2}(n) 或 k\sqrt[4]{n} 值开始，这里的 n 代表特征列中唯一特征的数量，k 是一个很小的常量（通常小于10）。通过密集嵌入，深度模型可以更好的概括，并更好对之前没有在训练数据中遇见的特征进行预测。然而，当两个特征列之间的底层交互矩阵是稀疏和高等级时，很难学习特征列的有效低维度表示。在这种情况下，大多数特征对之间的交互应该为零，除了少数几个，但密集的嵌入将导致所有特征对的非零预测，从而可能过度泛化。另一方面，具有交叉特征的线性模型可以用更少的模型参数有效地记住这些“异常规则”。现在，我们来看看如何联合训练广度和深度模型，让它们优势和劣势互补。将广度和深度模型结合为一体通过将其最终输出的对数几率作为预测结合起来，然后将预测提供给 logistic 损失函数，将广度模型和深度模型相结合。所有的图形定义和变量分配都已经被处理，所以你只需要创建一个 DNNLinearCombinedClassifier：import tempfilemodel_dir = tempfile.mkdtemp()m = tf.contrib.learn.DNNLinearCombinedClassifier(    model_dir=model_dir,    linear_feature_columns=wide_columns,    dnn_feature_columns=deep_columns,    dnn_hidden_units=[100, 50])训练和评估模型在训练模型之前，请先阅读人口普查数据集，就像在 《TensorFlow Liner Model Tutorial》 中所做的一样。 输入数据处理的代码再次为你提供方便：import pandas as pdimport urllib# 为数据集定义列名CSV_COLUMNS = [    "age", "workclass", "fnlwgt", "education", "education_num",    "marital_status", "occupation", "relationship", "race", "gender",    "capital_gain", "capital_loss", "hours_per_week", "native_country",    "income_bracket"]def maybe_download(train_data, test_data):  """Maybe downloads training data and returns train and test file names."""  if train_data:    train_file_name = train_data  else:    train_file = tempfile.NamedTemporaryFile(delete=False)    urllib.request.urlretrieve(        "https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.data",        train_file.name)  # pylint: disable=line-too-long    train_file_name = train_file.name    train_file.close()    print("Training data is downloaded to %s" % train_file_name)  if test_data:    test_file_name = test_data  else:    test_file = tempfile.NamedTemporaryFile(delete=False)    urllib.request.urlretrieve(        "https://archive.ics.uci.edu/ml/machine-learning-databases/adult/adult.test",        test_file.name)  # pylint: disable=line-too-long    test_file_name = test_file.name    test_file.close()    print("Test data is downloaded to %s"% test_file_name)  return train_file_name, test_file_namedef input_fn(data_file, num_epochs, shuffle):  """Input builder function."""  df_data = pd.read_csv(      tf.gfile.Open(data_file),      names=CSV_COLUMNS,      skipinitialspace=True,      engine="python",      skiprows=1)  # 移除 NaN 元素  df_data = df_data.dropna(how="any", axis=0)  labels = df_data["income_bracket"].apply(lambda x: "&gt;50K" in x).astype(int)  return tf.estimator.inputs.pandas_input_fn(      x=df_data,      y=labels,      batch_size=100,      num_epochs=num_epochs,      shuffle=shuffle,      num_threads=5)阅读数据之后，你可以训练并评估模型：# 将 num_epochs 设置为 None，以获得无限的数据流m.train(    input_fn=input_fn(train_file_name, num_epochs=None, shuffle=True),    steps=train_steps)# 在所有数据被消耗之前，为了运行评估，设置 steps 为 Noneresults = m.evaluate(    input_fn=input_fn(test_file_name, num_epochs=1, shuffle=False),    steps=None)print("model directory = %s" % model_dir)for key in sorted(results):  print("%s: %s" % (key, results[key]))输出的第一行应该类似 accuracy: 0.84429705。我们可以看到使用广度和深度模型将广度线性模型精度约 83.6% 提高到了约 84.4%。如果你想看端对端的工作示例，你可以下载我们的 示例代码。请注意，本教程只是一个小型数据基的简单示例，为了让你快速熟悉 API。如果你有大量具有稀疏特征列和大量可能特征值的数据集，广度和深度学习将会更加强大。此外，请随时关注我们的 研究论文，以了解更多关于在实际中广度和深度学习在大型机器学习方面如何应用的思考。      原文地址：https://www.tensorflow.org/tutorials/wide_and_deep    译文出自：掘金翻译计划    译者：charsdavy    校对者：MRNIU    掘金翻译计划 是一个翻译优质互联网技术文章的社区，文章来源为 掘金 上的英文分享文章。内容覆盖 Android、iOS、前端、后端、区块链、产品、设计、人工智能等领域，想要查看更多优质译文请持续关注 掘金翻译计划、官方微博、知乎专栏。]]></content>
      <categories>
        
          <category> ml </category>
        
      </categories>
      <tags>
        
          <tag> 掘金翻译计划 </tag>
        
          <tag> tensorflow </tag>
        
          <tag> python </tag>
        
          <tag> 机器学习 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[聊聊 iOS 数据保护]]></title>
      <url>/blog/ios-data-protection/</url>
      <content type="text"><![CDATA[文件系统中的文件、keychain中的项，都是加密存储的。当用户解锁设备后，系统通过UDID密钥和用户设定的密码生成一个用于解密的密码密钥，存放在内存中，直到设备再次被锁，开发者可以通过Data Protection API 来设定文件系统中的文件、keychain中的项应该何时被解密。这个就是数据保护的内容。钥匙串（keychain）keychain服务提供了一种安全的保存私密信息（密码，序列号，私钥，证书等）的方式，每个iOS程序都有一个独立的keychain存储。相对于NSUserDefaults、文件保存等一般方式，keychain保存更为安全，而且keychain里保存的信息不会因APP被删除而丢失。基于钥匙串的特点，我们在使用时对于新增的数据项目，要注意数据删除的时机。还有一点需要注意的就是，保护属性的指定。如果没有指定保护属性，这将被视为严重的安全漏洞。作用备份当我们备份设备数据时，系统会将用户数据保存在相应的钥匙串中，并依照相应的安全策略保存。主要分成两类：加密和不加密。两者的主要区别在于恢复数据时的范围不同。加密备份的数据可以恢复到任何设备上（ThisDeviceOnly指定的项目除外），而不加密的备份则只能恢复至同一台设备。共享keychain支持在多个应用之间共享数据。但现实开发中UIPasteboardNameFind的使用代替了keychain。不过好在Apple在iOS11中已经废弃它。看来Apple想规范开发者对于用户敏感数据的共享使用，同时提醒大家使用更加安全的方式存储用户敏感数据。使用范例SecItemAddNSMutableDictionary *dict = [NSMutableDictionary dictionary];NSData *passwordData = [@"myPassword" dataUsingEncoding:NSUTF8StringEncoding];[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];[dict setObject:@"Conglomco" forKey:(__bridge id)kSecAttrLabel];[dict setObject:@"This is your password for the Conglomco service." forKey:(__bridge id)kSecAttrDescription];[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];[dict setObject:passwordData forKey:(__bridge id)kSecValueData];[dict setObject:(__bridge id)kSecAttrAccessibleWhenUnlocked forKey:(__bridge id)kSecAttrAccessible];OSStatus error = SecItemAdd((__bridge CFDictionaryRef)dict, NULL);if (error == errSecSuccess) {    NSLog(@"Yay");}SecItemDeleteNSMutableDictionary *dict = [NSMutableDictionary dictionary];[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];OSStatus error = SecItemDelete((__bridge CFDictionaryRef)dict);if (error == errSecSuccess) {	NSLog(@"Yay");}SecItemUpdateNSMutableDictionary *dict = [NSMutableDictionary dictionary];NSData *newPasswordData = [@"newMyPassword" dataUsingEncoding:NSUTF8StringEncoding];[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];NSDictionary *updatedAttribute = [NSDictionary dictionaryWithObject:newPasswordData forKey:(__bridge id)kSecValueData];OSStatus error = SecItemUpdate((__bridge CFDictionaryRef)dict, (__bridge CFDictionaryRef)updatedAttribute);if (error == errSecSuccess) {	NSLog(@"Yay");}SecItemCopyMatchingNSMutableDictionary *dict = [NSMutableDictionary dictionary];[dict setObject:(__bridge id)kSecClassGenericPassword forKey:(__bridge id)kSecClass];[dict setObject:@"chars" forKey:(__bridge id)kSecAttrAccount];[dict setObject:@"cn.zaker.keychain.sample" forKey:(__bridge id)kSecAttrService];[dict setObject:(id)kCFBooleanTrue forKey:(__bridge id)kSecReturnAttributes];NSDictionary *result = nil;OSStatus error = SecItemCopyMatching((__bridge CFDictionaryRef)dict, (void *)&amp;result);if (error == errSecSuccess) {	NSLog(@"Yay %@", result);}常用方法            方法      描述                  SecItemAdd      添加数据              SecItemDelete      删除数据              SecItemUpdate      修改数据              SecItemCopyMatching      查找数据      保护属性            钥匙串保护属性      含义                  kSecAttrAccessibleAfterFirstUnlock      开机之后密钥不可用，直到用户首次输入密码              kSecAttrAccessibleAlways      密钥在设备开机后依旧可用。在iOS9中已经废弃              kSecAttrAccessibleAlwaysThisDeviceOnly      密钥始终可用，但无法迁移到其他设备              kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly      作用同上              kSecAttrAccessibleWhenUnlocked      只要解锁过设备，则密钥保持可用状态              kSecAttrAccessibleWhenUnlockedThisDeviceOnly      作用同上              kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly      作用同上，只有用户设置密码密钥才可用      kSecAttrAccessibleAlways 将会引入一个很明显的安全问题，因为此种保护属性，只要有人窃取了你的设备，他们就能读取钥匙串的内容。kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly 这个属性可以完美的解决上述的安全问题。因为越狱时通常需要重启设备。kSecAttrAccessibleWhenUnlocked 这个属性要求攻击者必须知道用户密码才能提取隐私数据。它很适合做默认属性值。kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly 是iOS8新增的保护属性。这个属性要求在使用时用户设定了密码，否则使用就失败。基本用法            项目类      描述                  kSecClassGenericPassword      普通密码              kSecClassInternetPassword      专门用于互联网服务的密码              kSecClassCertificate      加密证书              kSecClassKey      加密密钥              kSecClassIdentity      一个密钥对（包括公共证书和私钥）      iCloud同步这是iOS7引入的一种新机制，可以把钥匙串项目同步到iCloud，允许用户在多个设备之间共享钥匙串项目。默认情况下，应用程序创建的钥匙串项目会禁用这个机制，但可以把kSecAttrSynchronizable设置为true来启用。另外请注意，使用此选项时无法指定不兼容的kSecAttrAccessible属性。例如，指定kSecAttrAccessibleWhenUnlockedThisDeviceOnly不起作用，因为ThisDeviceOnly指定的项目不会备份，也不能同步到iCloud、笔记本电脑、台式机或其他同步位置。数据保护Apple 推出了数据保护API作为额外的保护层，它允许开发者指定文件解密密钥的生命周期。可以使用这个API控制文件的访问权限，与钥匙串项目中的kSecAttrAccessible 属性类似。数据保护API使用用户密码和层级密钥来加密保护文件的密钥，而当这些文件不能被访问时，会从内存中删除这个层级密钥。文件保护过程1.文件生成一个文件密钥来加密文件的内容。2.生成一个额外的密钥对，用于生成文件公钥和文件私钥。3.用文件私钥和Protected Unless Open等级公钥计算出一个共享密码。4.用共享密码 SHA-1散列值加密文件密钥。5.加密过的文件密钥会存储在文件的元数据中，元数据中还有文件的公钥。6.系统丢弃文件私钥。7.关闭文件时从内存中删除未加密的文件密钥。8.需要再次打开文件时，用Protected Unless Open等级私钥和文件公钥计算共享密码。9.计算共享密码的SHA-1散列值，把它当作解密文件的密钥。DataProtectionClass 权限如果你的应用在设备进入后台或锁定时不需要写入或读取文件，那你就可以在工程中配置一个NSFileProtectionComplete值来添加权限。这将确保所有受保护的文件数据只能在设备解锁时访问，相当于为所有的应用文件都设置kSecAttrAccessibleWhenUnlocked选项。从Xcode5开始，新工程会默认启用数据保护权限，但是一些旧工程并不会自动开启。开启方式如下图：使用范例NSDataWritingFileProtectionCompleteNSData *data = [self generateData];NSError *error = nil;NSString *path = [NSString stringWithFormat:@"%@_demo.pdf", NSTemporaryDirectory()];[data writeToFile:path options:NSDataWritingFileProtectionComplete error:&amp;error];if (error) {	NSLog(@"%@", error);}NSFileProtectionCompleteNSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"demo.txt"];NSError *error = nil;NSDictionary *attr = [NSDictionary dictionaryWithObject:NSFileProtectionComplete forKey:NSFileProtectionKey];[[NSFileManager defaultManager] setAttributes:attr ofItemAtPath:path error:&amp;error];if (error) {	NSLog(@"%@", error);}SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPENNSString *path = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:@"demo.sqlite"];sqlite3 *handle = NULL;sqlite3_open_v2([path UTF8String],                &amp;handle,                SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE | SQLITE_OPEN_FILEPROTECTION_COMPLETEUNLESSOPEN,                NULL);保护等级CompleteUntilFirstUserAuthentication这个保护等级是iOS5开始使用的默认值。主要用来防御一些需要重启的攻击。Complete官方称这是目前最安全的文件保护等级。在这种情况下，锁屏之后系统就会删除内存中的层级密钥，并把文件改为不可读。具体使用的范例前文可见。使用Complete保护之前，考虑是否合适。如果你的应用进程需要持续写/读一个文件，那这种保护模式就不合适了。CompleteUnlessOpen如果一个文件当前被一个应用打开，那会暂时禁用该文件的保护。它会确保打开的文件在设备被锁定时依然能够写入，并且允许新建文件到磁盘。不过这个等级保护的文件在锁屏时无法打开，除非锁屏时就已经提前打开。CommonCrypto加密CommonCrypto是Apple官方提供的一套加密框架。在使用这套方案时，主要注意以下几个问题即可。避免弱算法众所周知，DES就是一种很典型的弱算法。如果你使用弱算法，那应用就很容易遭受密码攻击和暴力破解。我们在实际使用时，可以考虑使用AES算法、MD5算法或MD5加盐算法等。破碎的熵我们通常会使用rand方法来产生随机数，但是系统的这个随机函数并不是真正的随机。它产生的随机数符合正态分布，我们可以使用官方提供的方法SecRandomCopyBytes获得。也可以自己使用算法产生随机数。这里分享一个笔者以前自己实现的随机数案例。《均匀分布随机函数的实现》弱密钥开发者经常将用户的密码当作加密密钥，尤其在移动设备上，这将导致一个非常脆弱、低熵加密的密钥。那么正确的姿势是使用CCKeyDerivationPBKDF方法来生成。Touch ID使用范例#import &lt;LocalAuthentication/LocalAuthentication.h&gt;LAContext *context = [[LAContext alloc] init];NSError *error = nil;NSString *reason = @"We use this to verify your identify";if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&amp;error]) {	[context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError * _Nullable error) {		if (success) {			NSLog(@"Hello, that's your finger!");		} else {			NSLog(@"Couldn't read your fingerprint. Falling back to PIN or somthing.");		}	}];} else {	NSLog(@"Error : %@ %@", error, [error userInfo]);}Touch ID 与普通密码相比的安全性一个人的指纹是世界上最好的密码之一。它独一无二，高度特异，并且无需记忆。它会伴随人终生，所以你可以一直使用同一个指纹密码。比起简单的4位数字锁屏密码一万分之一的破解可能性，能找到同样单个指纹的人的概率为五万分之一，这是非常安全的，比起前者我可以不断尝试，Touch ID 指纹的硬性破解几率几乎没有，因为不可能有五万多个人排队来一一解锁你的设备，况且 Touch ID 会拒绝第五次以后的尝试而要求输入密码。所以我们可以添加更加复杂的密码而不是简单的数字密码来进一步提高安全性。Touch ID 指纹识别的原理在如此快速的识别过程中，Home 按钮上的一圈金属环起到了感应手指的功能，通知 Touch ID 来读取指纹。Touch ID 置于该按钮中，传感器的厚度只有 170 微米，拥有 500 ppi 高分辨率，可读取极小的指纹细节。传感器可从皮肤皮下层指纹的一些小部分拍摄高分辨率图像，然后会分析该信息，根据三种基本指纹类型（弧形纹、箕形纹或斗形纹）将指纹分类，它会绘制比人眼不可见的纹路细节，确保指纹读取准确无误。Touch ID 可从 360 度方向读取指纹，随后创建指纹的某种数学表达式，并将其与已注册的数据进行比较，以确定是否匹配。如果匹配，便可替代密码来解锁设备或通过某个令牌。此外，根据苹果官方的描述，Touch ID 会向以注册的指纹数据里持续的添加新的特征数据，随着时间的推移，这能不断提高匹配准确度，也能进一步的提高安全性。除了上述的内容，苹果还加入可以一些有效的手段来进一步确保安全，例如设备再重新启动或者保持锁定 48 小时后，就只能通过密码而不是指纹来解锁设备。Secure EnclaveApple声明指纹的图案不会被保存，存储于设备中的是指纹特征的数学表达式，而且从这些表达式不可能直接反推出指纹图像。指纹的验证运算独立于主要处理器芯片（例如 A7、A8），芯片内有称为 “Secure Enclave” 的高级安全架构，专用于密码指纹数据，并使用 Secure Enclave 的专用密钥加密，以及每次启动以随机的 UID 进行管理。指纹数据仅能被 Secure Enclave 处理和使用，正因为此架构独立于其它设备部件，仅有 Touch ID 使用它，且不能将它用于匹配其他指纹数据库，所以存储的指纹数据不会由 iOS 或其他应用访问，也不会被存储到 Apple 服务器或备份到 iCloud 等地方。从硬件上来看指纹特征数据尚不能被 “Secure Enclave” 和 Touch ID 以外的部件访问到，并且两者芯片互相隔离开来，所有软件都没有权利获得指纹数据，仅能得到指纹是否错误的回馈。因为架构的核心秘密仅仅只有苹果公司知道，所以目前几乎没有第三方软件可以访问到这部分敏感信息。到此，关于 iOS 数据保护的问题暂时告一段落。欢迎大家评论指正。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> 安全 </tag>
        
          <tag> 存储 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MacOS 搭建 Tensorflow PyCharm 环境]]></title>
      <url>/blog/tensorflow-pycharm-mac/</url>
      <content type="text"><![CDATA[TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。目前来说，Github上star最多的项目就是它了。在这之前，笔者写过一篇简单的入门文章《初探 TensorFlow》。当时没能成功搭建环境，加上后期的工作原因，至此搁置了一段时间。今天，终于各种折腾，在自己的Mac上经过多种尝试之后，完美搭建成功。这里就把它分享出来，希望对大家有所帮助。基于 Anaconda 的安装Anaconda 是一个集成许多第三方科学计算库的 Python 科学计算环境,Anaconda 使用 conda 作为自己的包管理工具,同时具有自己的计算环境,类似 Virtualenv.和 Virtualenv 一样,不同 Python 工程需要的依赖包,conda 将他们存储在不同的地方。 TensorFlow 上安装的 Anaconda 不会对之前安装的 Python 包进行覆盖.  安装 Anaconda  建立一个 conda 计算环境  激活环境,使用 conda 安装 TensorFlow  安装成功后,每次使用 TensorFlow 的时候需要激活 conda 环境安装 Anaconda :参考 Anaconda 的下载页面的指导建立环境建立一个 conda 计算环境名字叫tensorflow:# Python 2.7$ conda create -n tensorflow python=2.7# Python 3.4$ conda create -n tensorflow python=3.4激活激活tensorflow环境,然后使用其中的 pip 安装 TensorFlow. 当使用easy_install使用--ignore-installed标记防止错误的产生。URL of the TensorFlow Python package$ source activate tensorflow(tensorflow)$  # Your prompt should change# Ubuntu/Linux 64-bit, CPU only, Python 2.7:(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl# Ubuntu/Linux 64-bit, GPU enabled, Python 2.7. Requires CUDA toolkit 7.5 and CuDNN v4.# For other versions, see "Install from sources" below.(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp27-none-linux_x86_64.whl# Mac OS X, CPU only:(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.11.0rc0-py2-none-any.whl对于 Python 3.x :$ source activate tensorflow(tensorflow)$  # Your prompt should change# Ubuntu/Linux 64-bit, CPU only, Python 3.4:(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl# Ubuntu/Linux 64-bit, GPU enabled, Python 3.4. Requires CUDA toolkit 7.5 and CuDNN v4.# For other versions, see "Install from sources" below.(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.8.0rc0-cp34-cp34m-linux_x86_64.whl# Mac OS X, CPU only:(tensorflow)$ pip install --ignore-installed --upgrade https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py3-none-any.whlconda 环境激活后,你可以测试:$ python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; print(tf.__version__)# 0.11.0rc0开启或关闭环境当你不用 TensorFlow 的时候,关闭环境:(tensorflow)$ source deactivate$  # Your prompt should change back再次使用的时候再激活 :$ source activate tensorflow(tensorflow)$  # Your prompt should change.# Run Python programs that use TensorFlow....# When you are done using TensorFlow, deactivate the environment.(tensorflow)$ source deactivatePyCharm 配置重点：正确配置Project的Interpreter即可方法  Preferences  Project Interpreter  Click More附图  打开Preferences  打开Project Interpreters  Demo运行结果]]></content>
      <categories>
        
          <category> ml </category>
        
      </categories>
      <tags>
        
          <tag> tensorflow </tag>
        
          <tag> python </tag>
        
          <tag> 机器学习 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS App 启动性能优化]]></title>
      <url>/blog/ios-app-launch-time-optimize/</url>
      <content type="text"><![CDATA[应用启动时间，直接影响用户对一款应用的判断和使用体验。ZAKER新闻本身就包含非常多并且复杂度高的业务模块（如新闻、视频等），也接入了很多第三方的插件，这势必会拖慢应用的启动时间，本着精益求精的态度和对用户体验的追求，我们希望在业务扩张的同时最大程度的优化启动时间。启动时间总时间 = T1 + T2T1加载系统dylib和可执行文件的时间。T2从main到applicationWillFinishLaunching结束的时间。App启动过程1）解析Info.plist  加载相关信息，例如如闪屏  沙箱建立、权限检查2）Mach-O加载  如果是胖二进制文件，寻找合适当前CPU类别的部分  加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）  定位内部、外部指针引用，例如字符串、函数等  执行声明为__attribute__((constructor))的C函数  加载类扩展（Category）中的方法  C++静态对象加载、调用ObjC的 +load 函数3）程序执行  调用main()  调用UIApplicationMain()  调用applicationWillFinishLaunchingMach-OMach-O 是针对不同运行时可执行文件的文件类型。文件类型：Executable： 应用的主要二进制Dylib： 动态链接库（又称 DSO 或 DLL）Bundle： 不能被链接的 Dylib，只能在运行时使用 dlopen() 加载，可当做 macOS 的插件。Image： executable，dylib 或 bundleFramework： 包含 Dylib 以及资源文件和头文件的文件夹Mach-O 镜像文件Mach-O 被划分成一些 segement，每个 segement 又被划分成一些 section。segment 的名字都是大写的，且空间大小为页的整数。页的大小跟硬件有关，在 arm64 架构一页是 16KB，其余为 4KB。section 虽然没有整数倍页大小的限制，但是 section 之间不会有重叠。几乎所有 Mach-O 都包含这三个段（segment）： __TEXT,__DATA 和 __LINKEDIT：      __TEXT 包含 Mach header，被执行的代码和只读常量（如C 字符串）。只读可执行（r-x）。        __DATA 包含全局变量，静态变量等。可读写（rw-）。        __LINKEDIT 包含了加载程序的『元数据』，比如函数的名称和地址。只读（r–）。  Mach-O Universal 文件FAT 二进制文件，将多种架构的 Mach-O 文件合并而成。它通过 Fat Header 来记录不同架构在文件中的偏移量，Fat Header 占一页的空间。按分页来存储这些 segement 和 header 会浪费空间，但这有利于虚拟内存的实现。什么是image1.executable可执行文件 比如.o文件。2.dylib 动态链接库 framework就是动态链接库和相应资源包含在一起的一个文件夹结构。3.bundle 资源文件 只能用dlopen加载，不推荐使用这种方式加载。除了我们App本身的可行性文件，系统中所有的framework比如UIKit、Foundation等都是以动态链接库的方式集成进App中的。什么是ImageLoaderimage 表示一个二进制文件(可执行文件或 so 文件)，里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。两步走：在程序运行时它先将动态链接的 image 递归加载 (也就是上面测试栈中一串的递归调用的时刻)。 再从可执行文件 image 递归加载所有符号。冷启动和热启动冷启动应用首次启动。即后台线程中未有当前打开的应用，所有的资源都需要加载并初始化。热启动应用非首次启动。即后台线程中保留有当前应用，应用的资源在内存中有保存。启动时间分析1）开启时间分析功能在Xcode的菜单中选择Project→Scheme→Edit Scheme...，然后找到 Run → Environment Variables →+，添加name为DYLD_PRINT_STATISTICSvalue为1的环境变量。load dylibs image在每个动态库的加载过程中， dyld需要：1.分析所依赖的动态库2.找到动态库的mach-o文件3.打开文件4.验证文件5.在系统核心注册文件签名6.对动态库的每一个segment调用mmap()通常的，一个App需要加载100到400个dylibs， 但是其中的系统库被优化，可以很快的加载。 针对这一步骤的优化有：1.减少非系统库的依赖2.合并非系统库3.使用静态资源，比如把代码加入主程序rebase/bind由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：1.减少Objc类数量， 减少selector数量2.减少C++虚函数数量3.转而使用swift stuct（其实本质上就是为了减少符号的数量）解读  main()函数之前总共使用了506.48ms  在506.48ms中，加载动态库用了46.35ms，指针重定位使用了137.72ms，ObjC类初始化使用了95.39ms，各种初始化使用了226.92ms。  在初始化耗费的226.92ms中，用时最多的几个初始化是libSystem.B.dylib、libBacktraceRecording.dylib、libglInterpose.dylib以及libMTLInterpose.dylib。2）使用instruments工作分析具体时间消耗点耗时的影响因素1） main()函数之前耗时的影响因素  动态库加载越多，启动越慢。  ObjC类越多，启动越慢  C的constructor函数越多，启动越慢  C++静态对象越多，启动越慢  ObjC的+load越多，启动越慢实验证明，在ObjC类的数目一样多的情况下，需要加载的动态库越多，App启动就越慢。同样的，在动态库一样多的情况下，ObjC的类越多，App的启动也越慢。需要加载的动态库从1个上升到10个的时候，用户几乎感知不到任何分别，但从10个上升到100个的时候就会变得十分明显。同理，100个类和1000个类，可能也很难查察觉得出，但1000个类和10000个类的分别就开始明显起来。同样的，尽量不要写__attribute__((constructor))的C函数，也尽量不要用到C++的静态对象；至于ObjC的+load方法，似乎大家已经习惯不用它了。任何情况下，能用dispatch_once()来完成的，就尽量不要用到以上的方法。2） main()函数之后耗时的影响因素从main()函数开始至applicationWillFinishLaunching结束，我们统一称为main()函数之后的部分。  执行main()函数的耗时  执行applicationWillFinishLaunching的耗时  rootViewController及其childViewController的加载、view及其subviews的加载实践移除不需要用到的类为了解决这个历史问题，我使用了一个叫做fui（Find Unused Imports）的开源项目，它能很好的分析出不再使用的类，准确率非常高，唯一的问题是它处理不了动态库和静态库里提供的类，也处理不了C++的类模板。使用方法是在Terminal中cd到项目所在的目录，然后执行fui find，然后等上那么几分钟（是的你没有看错，真的需要好几分钟甚至需要更长的时间），就可以得到一个列表了。由于这个工具还不是100%靠谱，可根据这个列表，在Xcode中手动检查并删除不再用到的类。移除不再使用的图片资源通过 LSUnusedResources 工具，扫描出项目中不再使用的图片资源。合并功能类似的类和扩展（Category）优化application:didFinishLaunchingWithOptions:方法优化rootViewController加载瘦身 APP静态库瘦身(瘦身效果佳)example: lipo -info libWeChatSDK.a # 瘦身静态库支持 arm64 指令集lipo libWeChatSDK.a -thin arm64 -output libWeChatSDK-arm64.alipo libWeChatSDK.a -thin armv7s -output libWeChatSDK-armv7s.a# 合并lipo create libWeChatSDK-armv7s.a libWeChatSDK-arm64.a -output libWeChatSDK-device.a设定 Xcode 配置      Build Settings-&gt;Optimization Leve Release 版应该选择Fastest, Smalllest        开启 BitCode        Build Settings-&gt;Valid Architectures中删除 armv7(iphone 4s,3gs),armv7s(iphone 5)        Build Settings-&gt;Strip Linked Product / Deployment Postprocessing / Symbols Hidden by Default 在 Release 版本设为 YES        Build Settings（Levels选项内）-&gt;Genetate Debug Symbols在 Release 版本设为 NO  ARMv6：ARM11内核用于iPhone2G和iPhone3G中的架构ARMv7：modern ARM内核用于iPhone3GS和iPhone4/S中的架构ARMv7s：A6内核用于iPhone5中的架构ARM64：A7内核用于iPhone5S/C中的架构问题1）NSUserDefaults是否是瓶颈2）还有其他哪些点可以做优化参考文档：《优化 App 的启动时间》]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> 性能 </tag>
        
          <tag> 优化 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[那些设计iOS API需要知道的事]]></title>
      <url>/blog/ios-design-api-guide/</url>
      <content type="text"><![CDATA[为了能够将我们项目中的代码能够在后续开发者使用（重用代码），通常使用的方法是将代码按照功能模块编写成API。那么我们就很有必要了解Objective-C语言中常见的编程范式（paradigm），同时还需了解各种可能碰到的陷阱。命名命名冲突的问题Objective-C没有其他语言的那种内置命名空间（namespace）机制。因此，我们只能自己想办法来解决命名冲突问题。最常用的解决方式就是，仿照其他语言（C++）建立自己的namespace，例如，使用前缀。所选前缀可以是与公司、应用程序或二者皆有关联之名。例如，ZAKER User Interface可以使用ZUI作为前缀。使用Cocoa创建应用程序时一定要注意，Apple宣称其保留使用所有“两字母前缀”(two-letter prefix)的权利，所以开发者选用的前缀应该是三个字母的。如果开发者使用了两个字母作前缀，那么很有可能开发者自定义的API和Apple的API冲突。不仅仅是类名，应用程序中的所有名称都应该加前缀。如果要为既有类新增“分类”(category)，那么一定要给“分类”及“分类”中的方法加上前缀。另外，类的实现文件中所用的纯C函数及全局变量也应该注意添加前缀。如果使用了第三方库编写自己的代码，并准备将其发布为程序库供他人开发应用程序所用，则尤其要注意重复符号问题。这种情况下为了避免使用者使用了与你相同的第三方库，应该为第三方库都加上你自己的前缀。命名方式类、方法和变量的命名是Objective-C编程的重要环节。如果命名方式好，可以提高代码可读性，减少不必要的注释。初学者通常会觉得Objective-C是门很繁琐的语言，因为其语法结构使得代码读起来和句子一样。命名中一般都带有“in”、“for”、“with”等介词，特别是在命名时还要讲究英文语法。例如：NSString *text = @"This is a good idea.";NSString *newText = [text stringByReplacingOccurrencesOfString:@"idea" withString:@"think"];上面的代码虽然用了比较啰嗦的方式描述一个看上去很简单的表达式。对于执行替换的那个方法，代码读起来就像日常语言里的那个句子：“Take text and give me a new string by replacing the occurrences of the string ‘idea’ with the string ‘think’”。这个句子准确描述了开发者想做的事。在命名不像Objective-C这般繁琐的语言中，类似的程序可能会写成：string text = "This is a good idea.";string new Text = text.replace("idea", "think");上面代码这样写，看起来方法名简洁很多，但是带来的代码不可读性却是非常大的。首先，我们不知道 text.replace 方法的两个参数到底按照什么顺序解读（除非查看方法声明）；再者，这两个参数谁替换谁？另外，和大多数语言一样，Objective-C也是采用“驼峰式大小写命名法”（camel casing）——以小写字母开头，其后每个单词首字母大写。方法命名清晰的方法名从左至右读起来好似一段文章。并不是说非得按照那些命名规则来给方法起名，不过这样做可以令代码变得更好维护，使他人更容易读懂。虽然类似C++或Java中那种函数命名简单，但是，若想知道每个参数的用途，就得查看函数原型，这会令代码难于读懂。NSString这个类展示了一套良好的命名习惯。下面列举几个方法及命名缘由：1）+ (instancetype)string;工厂方法（factory method），用于创建新的空字符串。方法名清晰地描述了返回值的类型。2）+ (instancetype)stringWithString:(NSString *)string;工厂方法，根据某字符串创建出与之内容相同的新字符串。与创建空字符串所用的那个工厂方法一样，方法名的第一个单词也指明了返回类型。3）+ (instancetype)localizedStringWithFormat:(NSString *)format, ...;工厂方法，根据特定格式创建出新的“本地化字符串”（localized string）。返回值类型是方法名的第二个单词（string），因为其前面还有个修饰语（localized）用来描述其逻辑含义。此方法的返回值依然是“字符串”（string），只不过是一种经过本地化处理的特殊字符串。4）- (NSUInteger)lengthOfBytesUsingEncoding:(NSStringEncoding)enc;若字符串是以给定的编码格式（ASCII、UTF8、UTF16）来编码的，则返回其字节数组长度。此方法与length相似，但该方法还需一个参数，该参数紧跟着方法名中描述其类型的那个名词（encoding）。因此，我们可以总结成几条方法命名规则：1）如果方法的返回值是新创建的，那么方法名的首个词应该是返回值的类型，除非前面还有修饰语，例如localizedString。属性的存取方法不遵循这种命名方式，因为一般认为这些方法不会创建新对象。即便有时返回内部对象的一份拷贝，我们也认为那相当于原有对象。这些存取方法应该按照其所对应的属性来命名。2）应该把表示参数类型的名词放在参数前面。3）如果方法要在当前对象上执行操作，那么就应该包含动词；若执行操作时还需要参数，则应该在动词后面加上一个或多个名词。4）不要使用str这种简称，应该使用string这样的全称。5）boolean属性应加is前缀。如果某方法返回非属性的boolean值，那么应该根据其功能，选用has或is当前缀。6）将get这个前缀留给那些借由“输出参数”来保存返回值的方法，比如说，把返回值填充到“C语言式数组”（C-style array）里的那种方法就可以使用这个词做前缀。类与协议命名不仅仅是方法，类和协议也应该加上前缀，避免命名空间冲突。例如：  UIView  UIViewController  UITableViewDelegate错误模型目前有很多编程语言都有“异常”(exception)机制，Objective-C也不例外。“自动引用计数”(ARC, Automatic Reference Counting)在默认情况下不是“异常安全的”。这意味着：如果抛出异常，那么本应该在作用域末尾释放的对象现在却不会自动释放了。如果想生成“异常安全”的代码，可以通过设置编译器的标志来实现，不过这将引入额外代码，在不抛出异常时，也照样要执行这部分代码。需要打开的编译器标志叫做-fobjc-arc-exception。Objective-C现在所采用的办法是：只在极其罕见的情况下抛出异常，异常抛出之后，无须考虑恢复问题，而且应用程序此时也应该退出。这就是说，不用再编写复杂的“异常安全”代码了。异常只应该用于极其严重的错误，比如，你编写了某个抽象基类，它的正确用法是先从中继承一个子类，然后使用这个子类。在这种情况下，如果有人直接使用了这个抽象基类，那么可以考虑抛出异常。与其他语言不同，Objective-C中没办法将某个类标识为“抽象类”。要想达成类似效果，最好的办法是在那些子类必须覆写的超类方法里抛出异常。异常只用于处理严重错误(fatal error)，对于其他错误，Objective-C语言所用的编程范式为：令方法返回nil/0，或使用NSError，以表明有错误发生。NSError对象里封装了三条信息：  Error domain (错误范围，其类型为字符串)错误发生的范围，也就是产生错误的根源，通常用一个特有的全局变量来定义。例如，URL-handling-subsystem，在从URL中解析或获取数据时如果出错了，那么就使用NSURLErrorDomain来表示错误范围。  Error code (错误码，其类型为整数)独有的错误码，用以指明在某个范围内具体发生了何种错误。某个特定范围内可能会发生一系列相关错误，这些错误情况通常采用enum来定义。  User info (用户信息，其类型为字典)有关此错误的额外信息，其中或许包含一段“本地化描述”，或许还包含有导致该错误发生的另外一个错误，经由此种信息，可将相关错误串成一条“错误链”。使用不可变对象设计类的时候，应充分使用属性来封装数据。而在使用属性时，则可将其声明为readonly。默认情况下，属性是readwrite。因为如果把可变对象(mutable object)放入collection之后又修改其内容，那么很容易就会破坏set的内部数据结构，使其失去固有的语义。故此，我们应该尽量减少对象中的可变内容。具体到编程实践中，则应该尽量把对外公布出来的属性设为readonly，而且只在有必要时才将属性对外公布。定义类的公共API时，需要注意，对象里表示各种collection的那些属性究竟应该设成可变的，还是不可变的。如果某个属性可以为外界所增删，那么这个属性就需要用可变的set来实现。在这种情况下，通常应该提供一个readonly属性供外界使用，该属性将返回不可变的set，而此set则是内部那个可变set的一份拷贝。//  ZKRPointOfInterest.h#import &lt;UIKit/UIKit.h&gt;@interface ZKRPointOfInterest : NSObject@property (nonatomic, copy, readonly) NSString *identifier;@property (nonatomic, copy, readonly) NSString *title;@property (nonatomic, assign, readonly) CGFloat latitude;@property (nonatomic, assign, readonly) CGFloat longitude;@property (nonatomic, strong, readonly) NSSet *locations;- (instancetype)initWithIdentifier:(NSString *)identifier                             title:(NSString *)title                          latitude:(CGFloat)latitude                         longitude:(CGFloat)longitude;- (void)addLocation:(ZKRPointOfInterest *)location;- (void)removeLocation:(ZKRPointOfInterest *)location;@end//  ZKRPointOfInterest.m#import "ZKRPointOfInterest.h"@implementation ZKRPointOfInterest{    NSMutableSet *_internalLocations;}- (instancetype)initWithIdentifier:(NSString *)identifier                             title:(NSString *)title                          latitude:(CGFloat)latitude                         longitude:(CGFloat)longitude{    self = [super init];    if (self) {            }    return self;}- (NSSet *)locations{    return [_internalLocations copy];}- (void)addLocation:(ZKRPointOfInterest *)location{    if (location) {        [_internalLocations addObject:location];    }}- (void)removeLocation:(ZKRPointOfInterest *)location{    [_internalLocations removeObject:location];}@end注意：不要在返回的对象上查询类型以确定其是否可变。(即使不用isKindOfClass:方法来判断返回值类型是否可变)description方法在调试程序时，经常需要打印并查看对象信息。一种办法是编写代码把对象的全部属性都log到日志中。NSLog(@"object=%@", object);在构建需要打印到日志的字符串时，object对象会收到description消息，该方法所返回的描述信息将取代“格式字符串”(format string)里的“%@”。NSArray *obj = @[@"A string", @(123)];NSLog(@"object=%@", obj);输出：object=(	"A string",	123)如果在自定义类上这么做，那么则输出的信息却是如下：object=&lt;ZKRSqure: 0x7656d8a90060&gt;如果想要像上面NSArray那样打印出有用的信息，那么我们就应该在自己的类中覆写description方法，否则打印信息时就会调用NSObject类所实现的默认方法。此方法定义在NSObject协议里，不过NSObject类也实现了它。- (NSString *)description{    return [NSString stringWithFormat:@"&lt;%@: %p, \"%f %f\"&gt;", [self class], self, _width, _height];}使用结果：ZKRRectangle *rectangle = [[ZKRRectangle alloc] initWithWidth:5.0 height:7.0];NSLog(@"%@", rectangle);//Output&lt;ZKRRectangle: 0x60000002fc20, "5.000000 7.000000"&gt;NSObject协议中还有个需要注意的方法，就是debugDescription，此方法用意与description相似。二者区别在于，debugDescription方法是开发者在调试器(debugger)中以控制台命令打印对象时才调用的。在NSObject类的默认实现中，它只是直接调用description。初始化方法所有对象均要初始化，在初始化时，有些对象可能无须开发者向其提供额外信息，不过一般来说还是需要提供的。通常情况下，对象若不知道必要的信息，则无法完成其工作。例如，UITAbleViewCell类初始化该类对象时，需要指明其样式及标识符，标识符能够区分不同类型的单元格。由于这种对象的创建成本较高，所以绘制表格时可依照标识符来复用，以提升程序效率。这种可为对象提供必要信息以便其能完成工作的初始化方法叫做“全能初始化方法”(designated initializer)。如果创建类实例的方式不止一种，那么这个类就会有多个初始化方法。但是，我们仍然需要选定一个作为全能初始化方法，令其他初始化方法都来调用它。例如，NSDate类- (instancetype)init NS_DESIGNATED_INITIALIZER;- (instancetype)initWithTimeIntervalSinceReferenceDate:(NSTimeInterval)ti NS_DESIGNATED_INITIALIZER;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder NS_DESIGNATED_INITIALIZER;- (instancetype)initWithTimeIntervalSinceNow:(NSTimeInterval)secs;- (instancetype)initWithTimeIntervalSince1970:(NSTimeInterval)secs;- (instancetype)initWithTimeInterval:(NSTimeInterval)secsToBeAdded sinceDate:(NSDate *)date;在上面几个初始化方法中，initWithTimeIntervalSinceReferenceDate:是全能初始化方法。只有在全能初始化方法中，才会存储内部数据。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。示例代码：//  ZKRRectangle.h#import &lt;UIKit/UIKit.h&gt;@interface ZKRRectangle : NSObject&lt;NSCopying&gt;@property (nonatomic, assign, readonly) CGFloat width;@property (nonatomic, assign, readonly) CGFloat height;- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;@end//  ZKRRectangle.m#import "ZKRRectangle.h"@implementation ZKRRectangle- (instancetype)initWithCoder:(NSCoder *)aDecoder{    self = [super init];    if (self) {        _width = [[aDecoder decodeObjectForKey:@"width"] floatValue];        _height = [[aDecoder decodeObjectForKey:@"height"] floatValue];    }    return self;}- (instancetype)init{    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@"Must use initWithWidth:height: instad." userInfo:nil];        return [self initWithWidth:0 height:0];}- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height{    self = [super init];    if (self) {        _width = width;        _height = height;    }    return self;}@end//  ZKRSquare.h#import "ZKRRectangle.h"@interface ZKRSquare : ZKRRectangle- (instancetype)initWithDimension:(CGFloat)dimension;@end//  ZKRSquare.m#import "ZKRSquare.h"@implementation ZKRSquare- (instancetype)init{    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@"Must use initWithDimension: instad." userInfo:nil];        return [self initWithDimension:0];}- (instancetype)initWithDimension:(CGFloat)dimension{    return [super initWithWidth:dimension height:dimension];}- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height{    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:@"Must use initWithDimension: instad." userInfo:nil];    CGFloat dimension = MIN(width, height);    return [self initWithDimension:dimension];}@end小结  在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均调用此方法。  若全能方法于超类不同，则需要覆写超类中的对应方法。  如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。NSCopying协议使用对象时经常需要拷贝它。在Objective-C中，此操作通过copy方法完成。如果想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法:- (id)copyWithZone:(nullable NSZone *)zone;为什么会出现NSZone呢？因为以前开发程序时，会据此把内容分成不同的“区”(zone)，而对象会创建在某个区里面。现在不用了，每个程序只有一个区：“默认区”(default zone)。所以说，尽管必须实现这个方法，但是你不必担心其中的zone参数。copy方法由NSObject实现，该方法只是以“默认区”为参数来调用copyWithZone:。我们总是想覆写copy方法，其实真正需要实现的是copyWithZone:方法。若想使某个类支持拷贝功能，只需声明该类遵从NSCopying协议，并实现其中的那个方法即可。- (id)copyWithZone:(NSZone *)zone{    ZKRRectangle *copy = [[[self class] allocWithZone:zone] initWithWidth:_width height:_height];    return copy;}说到copy方法，除了NSString这样的不可变类型的copy，与之类似的还有NSMutableString类的mutableCopy方法。与copyWithZone:方法相对应的可变内容的copy方法mutableCopyWithZone:方法来自于NSMutableCopying协议。如果你的类分为可变版本(mutable)与不可变版本(immutable)，那么就应该实现NSMutableCopying协议。若采用此模式，则在可变类中覆写copyWithZone:方法时，不要返回可变的拷贝，而应该返回一份不可变的版本。无论当前实例是否可变，需要获取其可变版本的拷贝，均应调用mutableCopy方法；获取不可变版本的拷贝，则总应该通过copy方法。深拷贝就是在拷贝对象自身时，将其底层数据也一并复制过去。浅拷贝就是在拷贝对象时，只拷贝容器对象本身，而不复制其中数据。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
          <tag> 框架 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[从iOS的图片圆角想到渲染]]></title>
      <url>/blog/ios-corner-radius/</url>
      <content type="text"><![CDATA[圆角是一种很常见的视图效果，相比于直角，它更加柔和优美，易于接受。设置圆角会带来一定的性能损耗，如何提高性能是一个需要重点讨论的话题。大家常见的圆角代码x.layer.cornerRadius = xx; x.clipsToBounds = YES;这两行确实实现了圆角视觉效果。其实使用x.layer.cornerRadius = xx;已经实现了圆角，只不过在某些控件是不生效的，因为某些图层在被切割圆角图层之上而被显示出来了。而x.clipsToBounds = YES;带来的后果就是产生离屏渲染。可以使用instruments中的CoreAnimation工具，打开Color Offscren-Rednered Yellow选项，可见黄色区域部分即是离屏渲染部分。那么离屏渲染会带来什么？当然后资源损耗，可能产生卡顿。因为在iPhone设备的硬件资源有差异，当离屏渲染不多时，并不是很明显感觉到它的缺点。什么是像素像素，为视频显示的基本单位，译自英文“pixel”，pix是英语单词picture的常用简写，加上英语单词“元素”element，就得到pixel，故“像素”表示“画像元素”之意，有时亦被称为pel（picture element）。每个这样的消息元素不是一个点或者一个方块，而是一个抽象的取样。像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。显示机制一个像素是如何绘制到屏幕上去的？有很多种方式将一些东西映射到显示屏上，他们需要调用不同的框架、许多功能和方法的结合体。这里我们大概看一下屏幕之后发生的事情。图像想显示到屏幕上使人肉眼可见都需借助像素的力量。它们密集的排布在手机屏幕上，将任何图形通过不同的色值表现出来。计算机显示的流程大致可以描述为将图像转化为一系列像素点的排列然后打印在屏幕上，由图像转化为像素点的过程又可以称之为光栅化，就是从矢量的点线面的描述，变成像素的描述。回溯历史，可以从过去的 CRT 显示器原理说起。CRT 的电子枪按照上面方式，从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization），简称 HSync；而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization），简称 VSync。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变。关于卡顿的简单原理解释在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。渲染机制当像素映射到屏幕上的时候，后台发生了很多事情。但一旦它们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhoneSE 的显示器上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在一些Retina屏幕上，这一数字将达到百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这就是一个很大的工作量。简单来说，iOS的显示机制大致如此：Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它的并发本性让它能高效的将不同纹理合成起来。所以，开发中我们应该尽量让CPU负责主线程的UI调动，把图形显示相关的工作交给GPU来处理。GPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使它们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。OpenGL 之上扩展出很多东西。在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，然而在 OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。需要强调的是，GPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，最终像素显示到屏幕上。正如上图显示，GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。另外一个问题就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这些看起来貌似微不足道，但是一些大型的纹理却会非常耗时。最终，CPU 开始运行程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中这就相当于一个 CALayer。每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。这就是合成。如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用公式来计算每一个像素：R = S + D * ( 1 – Sa )结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了它们的透明度。接着我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1。如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：R = S结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:                       0.5   0               0.5R = S + D * (1 - Sa) = 0   + 0 * (1 - 0.5) = 0                       0     1               0.5我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。为何图片缩放会增加GPU工作量当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。第一个便是滚动，当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。另一个原因便是当纹理的起点不在一个像素的边界上。在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。Core Animation 工具和模拟器有一个Color Misaligned Images 选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。关于iOS设备的一些尺寸限制可以看这里：iOSRes离屏渲染On-Screen Rendering意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。Off-Screen Rendering意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。当图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制时，屏幕外渲染就被唤起了。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。屏幕外的渲染会合并/渲染图层树的一部分到一个新的缓冲区，然后该缓冲区被渲染到屏幕上。特殊的“离屏渲染”：CPU渲染如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。离屏渲染的体现相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面：  1 创建新缓冲区要想进行离屏渲染，首先要创建一个新的缓冲区。  2 上下文切换离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上，又需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。触发离屏渲染1、drawRect2、layer.shouldRasterize = true;3、有mask或者是阴影(layer.masksToBounds, layer.shadow*)； 3.1) shouldRasterize（光栅化） 3.2) masks（遮罩） 3.3) shadows（阴影） 3.4) edge antialiasing（抗锯齿） 3.5) group opacity（不透明）4、Text（UILabel, CATextLayer, Core Text, etc）…注：layer.cornerRadius，layer.borderWidth，layer.borderColor并不会Offscreen Render，因为这些不需要加入Mask。圆角优化前面说了那么多，这里就给上实际可行方案。圆角的优化目前考虑两方面：一是，从图片入手，将图片切割成指定圆角样式。二是，使用贝塞尔曲线，利用CALayer层绘制指定圆角样式的mask遮盖View。UIImage切割：UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);CGContextRef context = UIGraphicsGetCurrentContext();CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);CGContextScaleCTM(context, 1, -1);CGContextTranslateCTM(context, 0, -rect.size.height);CGFloat minSize = MIN(self.size.width, self.size.height);if (borderWidth &lt; minSize / 2.0) {    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectInset(rect, borderWidth, borderWidth) byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];    CGContextSaveGState(context);    [path addClip];    CGContextDrawImage(context, rect, self.CGImage);    CGContextRestoreGState(context);}UIImage *image = UIGraphicsGetImageFromCurrentImageContext();image = [image dd_imageByCornerRadius:radius borderedColor:borderColor borderWidth:borderWidth corners:corners];UIGraphicsEndImageContext();图片绘制：UIGraphicsBeginImageContextWithOptions(self.size, NO, 0);[self drawAtPoint:CGPointZero];CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);CGFloat strokeInset = borderWidth / 2.0;CGRect strokeRect = CGRectInset(rect, strokeInset, strokeInset);UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:strokeRect byRoundingCorners:corners cornerRadii:CGSizeMake(radius, borderWidth)];path.lineWidth = borderWidth;[borderColor setStroke];[path stroke];UIImage *result = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();具体源码可以转至github进行star DDCornerRadius 欢迎issue。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> ui </tag>
        
          <tag> objc </tag>
        
          <tag> 优化 </tag>
        
          <tag> 渲染 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[二叉树的那些使用]]></title>
      <url>/blog/binary-tree-guide/</url>
      <content type="text"><![CDATA[在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。二叉树的第i层至多拥有 2^(i-1) 个节点数；深度为k的二叉树至多总共有 2^(k+1) - 1 个节点数，而总计拥有节点数匹配的，称为“满二叉树”；深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。对任何一棵非空的二叉树T，如果其叶片(终端节点)数为n0，分支度为2的节点数为n2，则n0 = n2 + 1。与普通树不同，普通树的节点个数至少为1，而二叉树的节点个数可以为0；普通树节点的最大分支度没有限制，而二叉树节点的最大分支度为2；普通树的节点无左、右次序之分，而二叉树的节点有左、右次序之分。二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉查找树和二元堆积，并应用于高效率的搜索和排序。相对于普通二叉树，还有一些特殊二叉树，它们诞生于特殊的场景需求。例如，二叉搜索树就是因搜索需求而诞生的一种特殊的树。具体可以参见《聊聊「二叉搜索树」的那些事儿》本文初衷是因为Homebrew 的作者@Max Howell的一条twitter  Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.类型(1)完全二叉树若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的节点数都达到最大个数，第h层有叶子节点，并且叶子节点都是从左到右依次排布，这就是完全二叉树。(2)满二叉树除了叶节点外每一个节点都有左右子叶且叶子节点都处在最底层的二叉树。(3)平衡二叉树平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。相关术语树的节点：包含一个数据元素及若干指向子树的分支。孩子节点：节点的子树的根称为该节点的孩子。双亲节点：B 节点是A 节点的孩子，则A节点是B 节点的双亲。兄弟节点：同一双亲的孩子节点；堂兄节点：同一层上节点。祖先节点: 从根到该节点的所经分支上的所有节点。子孙节点：以某节点为根的子树中任一节点都称为该节点的子孙。节点层：根节点的层定义为1；根的孩子为第二层节点，依此类推。树的深度：树中最大的节点层。节点的度：节点子树的个数。树的度： 树中最大的节点度。叶子节点：也叫终端节点，是度为 0 的节点。分支节点：度不为0的节点。有序树：子树有序的树，如：家族树。无序树：不考虑子树的顺序。树的结构#import &lt;Foundation/Foundation.h&gt;/** 二叉树节点 */@interface DDBinaryTreeNode : NSObject/** 值 */@property (nonatomic, assign) NSInteger value;/** 左节点 */@property (nonatomic, strong) DDBinaryTreeNode *leftNode;/** 右节点 */@property (nonatomic, strong) DDBinaryTreeNode *rightNode;@end树的遍历遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有节点，使每一个节点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个节点转换成为一个线性序列来表示。设L、D、R分别表示遍历左子树、访问根节点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先序遍历），LDR（称为中序遍历），LRD （称为后序遍历）。先序遍历+ (void)preOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {    if (!rootNode) {        return;    }        if (handler) {        handler(rootNode);    }    [self preOrderTraverseTree:rootNode.leftNode handler:handler];    [self preOrderTraverseTree:rootNode.rightNode handler:handler];}中序遍历+ (void)inOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void (^)(DDBinaryTreeNode *treeNode))handler{    if (!rootNode) {        return;    }    [self inOrderTraverseTree:rootNode.leftNode handler:handler];    if (handler) {        handler(rootNode);    }    [self inOrderTraverseTree:rootNode.rightNode handler:handler];}后序遍历+ (void)postOrderTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {    if (!rootNode) {        return;    }    [self postOrderTraverseTree:rootNode.leftNode handler:handler];    [self postOrderTraverseTree:rootNode.rightNode handler:handler];    if (handler) {        handler(rootNode);    }}广度优先遍历(Breadth First Search)从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。按照从上到下、从左到右的次序进行遍历。先遍历完一层，再遍历下一层。+ (void)levelTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler {    if (!rootNode) {        return;    }    NSMutableArray *queueArray = [NSMutableArray array]; //数组当成队列    [queueArray addObject:rootNode]; //压入根节点    while (queueArray.count &gt; 0) {        DDBinaryTreeNode *node = [queueArray firstObject];        if (handler) {            handler(node);        }        [queueArray removeObjectAtIndex:0]; //弹出最前面的节点，仿照队列先进先出原则        if (node.leftNode) {            [queueArray addObject:node.leftNode]; //压入左节点        }        if (node.rightNode) {            [queueArray addObject:node.rightNode]; //压入右节点        }    }}深度优先遍历(Depth First Search)DFS是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。+ (void)depthTraverseTree:(DDBinaryTreeNode *)rootNode handler:(void(^)(DDBinaryTreeNode *treeNode))handler{    if (!rootNode) {        return;    }        if (handler) {        handler(rootNode);    }        [self depthTraverseTree:rootNode.leftNode handler:handler];    [self depthTraverseTree:rootNode.rightNode handler:handler];}树的翻转翻转二叉树，又叫求二叉树的镜像，就是把二叉树的左右子树对调。+ (DDBinaryTreeNode *)invertBinaryTree:(DDBinaryTreeNode *)rootNode {    if (!rootNode) {        return nil;    }    if (!rootNode.leftNode &amp;&amp; !rootNode.rightNode) {        return rootNode;    }    [self invertBinaryTree:rootNode.leftNode];    [self invertBinaryTree:rootNode.rightNode];    DDBinaryTreeNode *tempNode = rootNode.leftNode;    rootNode.leftNode = rootNode.rightNode;    rootNode.rightNode = tempNode;    return rootNode;}树的查找+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode{    if (!rootNode) {        return nil;    }        if (rootNode.value == value) {        return rootNode;    }        if (value &lt; rootNode.value) {        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];    } else {        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];    }}相关链接：《百度的校园招聘面试经历》《你会翻转二叉树吗》写在最后欢迎大家加入算法交流Q群交流讨论，Q群号：855454453]]></content>
      <categories>
        
          <category> algorithm </category>
        
      </categories>
      <tags>
        
          <tag> tree </tag>
        
          <tag> 二叉树 </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[聊聊「二叉搜索树」的那些事儿]]></title>
      <url>/blog/binary-search-tree/</url>
      <content type="text"><![CDATA[二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉排序树。“中序遍历”可以让节点有序。原理二叉排序树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉排序树的存储结构。中序遍历二叉排序树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉排序树变成一个有序序列，构造树的过程即为对无序序列进行排序的过程。每次插入的新的节点都是二叉排序树上新的叶子节点，在进行插入操作时，不必移动其它节点，只需改动某个节点的指针，由空变为非空即可。搜索，插入，删除的复杂度等于树高，O(log(n))。实现树节点#import &lt;Foundation/Foundation.h&gt;/** 二叉树节点 */@interface DDBinaryTreeNode : NSObject/** 值 */@property (nonatomic, assign) NSInteger value;/** 左节点 */@property (nonatomic, strong) DDBinaryTreeNode *leftNode;/** 右节点 */@property (nonatomic, strong) DDBinaryTreeNode *rightNode;@end创建二叉排序树的创建无非就是不断查找和插入的过程，当我们查找某个值没有找到时，我们就会将该值插入到二叉排序树中。因为在查找的过程中可以确定该结点要插入的合适位置，所以插入就显得比较简单了。#import &lt;Foundation/Foundation.h&gt;@class DDBinaryTreeNode;@interface DDBinarySearchTreeHandler : NSObject/** *  创建二叉排序树 *  二叉排序树：左节点值全部小于根节点值，右节点值全部大于根节点值 * *  @param values 数组 * *  @return 二叉树根节点 */+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values;/** *  向二叉排序树节点添加一个节点 * *  @param treeNode 根节点 *  @param value	值 * *  @return 根节点 */+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value;/** *  二叉搜索树中某个值的节点 * *  @param value	值 *  @param rootNode 树根节点 * *  @return 节点 */+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode;@end+ (DDBinaryTreeNode *)createTreeWithValues:(NSArray *)values{    DDBinaryTreeNode *root = nil;    for (NSInteger i = 0; i &lt; values.count; i++) {        NSInteger value = [(NSNumber *)[values objectAtIndex:i] integerValue];        root = [DDBinarySearchTreeHandler addTreeNode:root value:value];    }    return root;}添加节点根据查找树的性质我们可以很简单的写出添加的代码，一个一个的比较，注意每插入的一个总是叶子节点。再进行调整。最终形成的效果图如下：+ (DDBinaryTreeNode *)addTreeNode:(DDBinaryTreeNode *)treeNode value:(NSInteger)value{    if (!treeNode) {        treeNode = [[DDBinaryTreeNode alloc] init];        treeNode.value = value;        NSLog(@"node:%td", value);    } else if (value &lt;= treeNode.value) {        NSLog(@"to left");        //值小于根节点，则插入到左子树        treeNode.leftNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.leftNode value:value];    } else {        NSLog(@"to right");        //值大于根节点，则插入到右子树        treeNode.rightNode = [DDBinarySearchTreeHandler addTreeNode:treeNode.rightNode value:value];    }    return treeNode;}查找节点+ (DDBinaryTreeNode *)searchTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode{    if (!rootNode) {        return nil;    }        if (rootNode.value == value) {        return rootNode;    }        if (value &lt; rootNode.value) {        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.leftNode];    } else {        return [DDBinarySearchTreeHandler searchTreeNodeWithValue:value inTree:rootNode.rightNode];    }}删除节点对于树来说，删除是最复杂的，主要需要考虑4种情况：叶子节点，只有左子树，只有右子树和左右子树都有。叶子节点删除的节点没有左子树也没有右子树，也就是删除的节点为叶子节点。这种情况下我们有可以细分为两类，一种是该叶子节点就是二叉排序树的根节点，也就是二叉排序树中只有一个节点的情况。只需要将root指针置为空即可。再一种情况是删除的叶子节点有父节点，直接将父节点连接该删除节点的指针置空即可。只有一个子节点如果删除的节点有左子树那就把左子树顶上去，如果有右子树就把右子树顶上去即可。左右子树都有首先可以这么想象，如果我们要删除一个数组的元素，那么我们在删除后会将其后面的一个元素顶到被删除的位置。那么二叉树操作同样也是一样，我们根据”中序遍历“找到要删除节点的后一个节点，然后顶上去就行了，原理跟”数组”一样一样的。+ (void)deleteTreeNodeWithValue:(NSInteger)value inTree:(DDBinaryTreeNode *)rootNode{    DDBinaryTreeNode *parent = rootNode;    DDBinaryTreeNode *current = rootNode;    // 记录被找到的节点是父节点的左子节点还是右子节点    BOOL isLeftChild = false;    // 循环直到找到目标节点的位置,否则返回    while (current.value != value) {        parent = current;        if (current.value &gt; value) {            isLeftChild = true;            current = current.leftNode;        } else {            isLeftChild = false;            current = current.rightNode;        }        if (current == nil) {            return;        }    }    // 如果待删除的节点没有任何子节点    // 直接将该节点的原本指向该节点的指针设置为nil    if (current.leftNode == nil &amp;&amp; current.rightNode == nil) {        if (current == rootNode) {            rootNode = nil;        }        if (isLeftChild == true) {            parent.leftNode = nil;        } else {            parent.rightNode = nil;        }    }    // 如果待删除的节点有一个子节点,且其为左子节点    else if (current.rightNode == nil) {        // 判断当前节点是否为根节点        if (current == rootNode) {            rootNode = current.leftNode;        } else if (isLeftChild) {            // 挂载到父节点的左子树            parent.leftNode = current.leftNode;        } else {            // 挂载到父节点的右子树            parent.rightNode = current.leftNode;        }    } else if (current.leftNode == nil) {        if (current == rootNode) {            rootNode = current.rightNode;        } else if (isLeftChild) {            parent.leftNode = current.rightNode;        } else {            parent.rightNode = current.rightNode;        }    }    // 如果待删除的节点有两个子节点    else if (current.leftNode != nil &amp;&amp; current.rightNode != nil) {        // 寻找右子树中的最小值        DDBinaryTreeNode *successor = [DDBinarySearchTreeHandler successor:current];        if (current == rootNode) {            rootNode = successor;        } else if (isLeftChild) {            parent.leftNode = successor;        } else {            parent.rightNode = successor;        }        successor.leftNode = current.leftNode;    }}/** 在树中查找最合适的节点 */+ (DDBinaryTreeNode *)successor:(DDBinaryTreeNode *)node {    DDBinaryTreeNode *successsor = nil;    DDBinaryTreeNode *successsorParent = nil;    DDBinaryTreeNode *current = node.rightNode;    while (current != nil) {        successsorParent = successsor;        successsor = current;        current = current.leftNode;    }    if (successsor != node.rightNode) {        successsorParent.leftNode = successsor.rightNode;        successsor.rightNode = node.rightNode;    }    return successsor;}写在最后欢迎大家加入算法交流Q群交流讨论，Q群号：855454453]]></content>
      <categories>
        
          <category> algorithm </category>
        
      </categories>
      <tags>
        
          <tag> tree </tag>
        
          <tag> 二叉搜索树 </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[初探 TensorFlow]]></title>
      <url>/blog/tensorflow-primer-guide/</url>
      <content type="text"><![CDATA[TensorFlow 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。什么是数据流图（Data Flow Graph）数据流图用“结点”(nodes)和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入(feed in)的起点/输出(push out)的终点，或者是读取/写入持久变量(persistent variable)的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”(tensor)。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。TensorFlow的特征  高度的灵活性  真正的可移植性（Portability）  将科研和产品联系在一起  自动求微分  多语言支持  性能最优化下载与安装源码安装# --recurse-submodules 参数是必须的, 用于获取 TesorFlow 依赖的 protobuf 库$ git clone --recurse-submodules https://github.com/tensorflow/tensorflowLinux 安装安装 Bazel首先依照 教程 安装 Bazel 的依赖. 然后使用下列命令下载和编译 Bazel 的源码:$ git clone https://github.com/bazelbuild/bazel.git$ cd bazel$ git checkout tags/0.1.0$ ./compile.sh上面命令中拉取的代码标签为 0.1.0, 兼容 Tensorflow 目前版本. bazel 的HEAD 版本 (即最新版本) 在这里可能不稳定.将执行路径 output/bazel 添加到 $PATH 环境变量中.安装其他依赖$ sudo apt-get install python-numpy swig python-devMac OS X 安装Mac 和 Linux 需要的软件依赖完全一样, 但是安装过程区别很大. 以下链接用于帮助你 在 Mac OS X 上安装这些依赖:Bazel参见网页的 Mac OS X 安装指南.SWIGMac OS X 安装教程注意: 你需要安装PCRE, 而不是 PCRE2.Numpy参见安装教程.创建 pip 包并安装$ bazel build -c opt //tensorflow/tools/pip_package:build_pip_package$ bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg# .whl 文件的实际名字与你所使用的平台有关$ pip install /tmp/tensorflow_pkg/tensorflow-0.5.0-cp27-none-linux_x86_64.whl二进制安装TensorFlow Python API 依赖 Python 2.7 版本.在 Linux 和 Mac 下最简单的安装方式, 是使用 pip 安装.为了简化安装步骤, 建议使用 virtualenv, 具体安装方法在后文具体说明.Ubuntu/Linux# 仅使用 CPU 的版本$ pip install https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whl# 开启 GPU 支持的版本 (安装该版本的前提是已经安装了 CUDA sdk)$ pip install https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow-0.5.0-cp27-none-linux_x86_64.whlMac OS X在 OS X 系统上, 推荐先安装 homebrew, 然后执行 brew install python, 以便能够使用 homebrew 中的 Python 安装 TensorFlow. 另外一种推荐的方式是在 virtualenv 中安装 TensorFlow.# 当前版本只支持 CPU$ pip install https://storage.googleapis.com/tensorflow/mac/tensorflow-0.5.0-py2-none-any.whl基于 VirtualEnv 的安装推荐使用 virtualenv 创建一个隔离的容器, 来安装 TensorFlow. 这是可选的, 但是这样做能使排查安装问题变得更容易.首先, 安装所有必备工具:# 在 Linux 上:$ sudo apt-get install python-pip python-dev python-virtualenv# 在 Mac 上:$ sudo easy_install pip  # 如果还没有安装 pip$ sudo pip install --upgrade virtualenv接下来, 建立一个全新的 virtualenv 环境. 为了将环境建在 ~/tensorflow 目录下, 执行:$ virtualenv --system-site-packages ~/tensorflow$ cd ~/tensorflow然后, 激活 virtualenv:$ source bin/activate  # 如果使用 bash$ source bin/activate.csh  # 如果使用 csh(tensorflow)$  # 终端提示符应该发生变化在 virtualenv 内, 安装 TensorFlow:(tensorflow)$ pip install --upgrade &lt;$url_to_binary.whl&gt;接下来, 使用类似命令运行 TensorFlow 程序:(tensorflow)$ cd tensorflow/models/image/mnist(tensorflow)$ python convolutional.py# 当使用完 TensorFlow(tensorflow)$ deactivate  # 停用 virtualenv$  # 你的命令提示符会恢复原样运行 TensorFlow打开一个 python 终端:$ python&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow!')&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print sess.run(hello)Hello, TensorFlow!&gt;&gt;&gt; a = tf.constant(10)&gt;&gt;&gt; b = tf.constant(32)&gt;&gt;&gt; print sess.run(a+b)42&gt;&gt;&gt;]]></content>
      <categories>
        
          <category> ml </category>
        
      </categories>
      <tags>
        
          <tag> tensorflow </tag>
        
          <tag> python </tag>
        
          <tag> 机器学习 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[拆解 MySQL 的高阶使用与概念]]></title>
      <url>/blog/mysql-advanced-study/</url>
      <content type="text"><![CDATA[前面我们主要分享了MySQL中的常见知识与使用。这里我们主要分享一下MySQL中的高阶使用，主要包括：函数、存储过程和存储引擎。对于MySQL中的基础知识，可以参见《与 MySQL 的零距离接触》1 函数函数可以返回任意类型的值，也可以接收这些类型的参数。字符函数            函数名称      描述                  CONCAT()      字符连接              CONCAT_WS()      使用指定的分隔符进行字符连接              FORMAT()      数字格式化              LOWER()      转换成小写字母              UPPER()      转换成大写字母              LEFT()      获取左侧字符              RIGHT()      获取右侧字符              LENGTH()      获取字符串长度              LTRIM()      删除前导空格              RTRIM()      删除后续空格              TRIM()      删除前导和后续空格              SUBSTRING()      字符串截取              [NOT] LIKE      模式匹配              REPLACE()      字符串替换      函数可以嵌套使用。%（百分号）：代表任意个字符。_（下划线）：代表任意一个字符。# 删除前导'?'符号SELECT TRIM(LEADING '?' FROM '??MySQL???');# 删除后续'?'符号SELECT TRIM(TRAILING '?' FROM '??MySQL???');# 删除前后'?'符号SELECT TRIM(BOTH '?' FROM '??My??SQL???');# 将'?'符号替换成'!'符号SELECT REPLACE('??My??SQL???', '?', '!');# 从中'MySQL'第1个开始，截取2个字符SELECT SUBSTRING('MySQL', 1, 2);# 从中'MySQL'截取最后1个字符SELECT SUBSTRING('MySQL', -1);# 从中'MySQL'第2个开始，截取至结尾SELECT SUBSTRING('MySQL', 2);数值运算符函数            函数名称      描述                  CEIL()      进一取整              DIV      整数除法              FLOOR()      舍一取整              MOD      取余数（取模）              POWER()      幂运算              ROUND()      四舍五入              TRUNCATE()      数字截取      比较运算符函数            函数名称      描述                  [NOT]BETWEEN…AND..      [不]在范围之内              [NOT]IN()      [不]在列出值范围内              IS[NOT]NULL      [不]为空      日期时间函数            函数名称      描述                  NOW()      当前日期和时间              CURDATE()      当前日期              CURTIME()      当前时间              DATE_ADD()      日期变化              DATEDIFF()      日期差值              DATE_FORMAT()      日期格式化      # 时间增加1年SELECT DATE_ADD('2016-05-28', INTERVAL 365 DAY);# 时间减少1年SELECT DATE_ADD('2016-05-28', INTERVAL -365 DAY);# 时间增加3周SELECT DATE_ADD('2016-05-28', INTERVAL 3 WEEK);# 日期格式化SELECT DATE_FORMAT('2016-05-28', '%m/%d/%Y');# 更多时间格式可以前往MySQL官网查看手册信息函数            函数名称      描述                  CONNECTION_ID()      连接ID              DATEBASE()      当前数据库              LAST_INSERT_ID()      最后插入记录的ID号              USER()      当前用户              VERSION()      版本信息      聚合函数            函数名称      描述                  AVG()      平均值              COUNT()      计数              MAX()      最大值              MIN()      最小值              SUM()      求和      加密函数            函数名称      描述                  MD5()      信息摘要算法              PASSWORD()      密码算法      自定义函数用户自定义函数（user-defined function，UDF）是一种对MySQL扩展的途径，其用法与内置函数相同。UDF是对MySQL扩展的一种途径。必要条件  参数：可以有零个或多个  返回值：只能有一个参数和返回值没有必然的联系。创建自定义函数CREATE FUNCTION function_name RETURNS {STRING|INTEGER|REAL|DECIMAL} routine_body函数体（routine_body）  函数体由合法的SQL语句构成；  函数体可以是简单的SELECT或INSERT语句；  函数体如果为复合结构则使用BEGIN…END语句；  复合结构可以包含声明，循环，控制结构。示例# 不带参数CREATE FUNCTION f1() RETURNS VARCHAR(30) RETURN DATE_FORMAT(NOW(), '%Y-%m-%d %H:%i:%s');# 带参数CREATE FUNCTION f2(num1 SMALLINT UNSIGNED, num2 SMALLINT UNSIGNED) RETURNS FLOAT(10, 2) UNSIGNED RETURN (num1 + num2) / 2;# 具有复合结构函数体# 可能需要使用DELIMITER命令修改分隔符CREATE FUNCTION f3(username VARCHAR(20)) RETURNS INT UNSIGNED BEGIN INSERT test(username) VALUES(username);RETURN LAST_INSERT_ID();END2 存储过程存储过程是SQL语句和控制语句的预编译集合，以一个名称存储作为一个单元处理。可以由用户调用执行，允许用户声明变量以及进行流程控制。存储过程可以接收输入类型的参数，也可以接收输出类型的参数，并可以存在多个返回值。执行效率比单一的SQL语句高。优点  增强SQL语句的功能和灵活性在存储过程中可以写控制语句具有很强的灵活性，可以完成复杂的判断及较复杂的运算。  实现较快的执行速度如果某一操作包含了大量的SQL语句，那么这些SQL语句都将被MySQL引擎执行语法分析、编译、执行，所以效率相对过低。而存储过程是预编译的，当客户端第一次调用存储过程时，MySQL的引擎将对它进行语法分析、编译等操作，然后把这个编译的结果存储到内存中，所以说第一次使用的时候效率和以前是相同的。但是以后客户端再次调用这个存储过程时，直接从内存中执行，所以说效率比较高，速度比较快。  减少网络流量如果通过客户端每一个单独发送SQL语句让服务器来执行，那么通过http协议来提交的数据量相对来说较大。创建CREATE [DEFINER = {user|CURRENT_USER}] PROCEDURE sp_name ([proc_parameter[, ...]]) [characteristic ...] routine_bodyproc_parameter :[IN | OUT | INOUT] param_name type参数：IN，表示该参数的值必须在调用存储过程时指定。OUT，表示该参数值可以被存储过程改变，并且可以返回。INOUT，表示该参数的调用时指定，并且可以被改变和返回。特性：COMMENT注释CONTAINS SQL包含SQL语句，但不包含读或写数据的语句。NO SQL不包含SQL语句。READS SQL DATA包含读写数据的语句。MODIFIES SQL DATA包含写数据的语句。SQL SECURITY {DEFINER | INVOKER}指明谁有权限来执行。过程体  过程体由合法的SQL语句构成；  过程体可以是任意SQL语句；不能通过存储过程来创建数据表、数据库。可以通过存储过程对数据进行增、删、改、查和多表连接操作。  过程体如果为复合结构则使用BEGIN…END语句；  复合结构中可以包含声明、循环、控制结构。调用CALL sp_name ([parameter[, ...]])CALL sp_name[()]删除DROP PROCEDURE [IF EXISTS] sp_name修改ALTER PROCEDURE sp_name [characteristic ...] COMMENT 'string'| {CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}| SQL SECURITY {DEFINER | INVOKER}存储过程与自定义函数的区别  存储过程实现的功能要复杂一些，而函数的针对性更强。  存储过程可以返回多个值，函数只能有一个返回值。  存储过程一般独立执行，函数可以作为其他SQL语句的组成部分来实现。示例：# 创建不带参数的存储过程CREATE PROCEDURE sp1() SELECT VERSION();# 创建带有IN类型参数的存储过程(users为数据表名)# 参数的名字不能和数据表中的记录名字一样CREATE PROCEDURE removeUserById(IN p_id INT UNSIGNED)BEGINDELETE FROM users WHERE id = p_id;END# 创建带有IN和OUT类型参数的存储过程(users为数据表名)CREATE PROCEDURE removeUserAndReturnUserNumsById(IN p_id INT UNSIGNED, OUT userNums INT UNSIGNED)BEGINDELETE FROM users WHERE id = p_id;SELECT COUNT(id) FROM users INTO userNums;END# 创建带有多个OUT类型参数的存储过程(users为数据表名)CREATE PROCEDURE removeUserAndReturnInfosByAge(IN p_age SMALLINT UNSIGNED, OUT delUser SMALLINT UNSIGNED,  OUT userNums SMALLINT UNSIGNED)BEGINDELETE FROM users WHERE age = p_age;SELECT ROW_COUNT INTO delUser;SELECT COUNT(id) FROM users INTO userNums;END3 存储引擎MySQL可以将数据以不同的技术存储在文件（内存）中，这种技术就称为存储引擎。每一种存储引擎使用不同的存储机制、索引技巧、锁定水平，最终提供广泛且不同的功能。      锁共享锁（读锁）：在同一时间段内，多个用户可以读取同一个资源，读取过程中数据不会发生任何变化。排他锁（写锁）：在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。        锁颗粒表锁：是一种开销最小的锁策略。行锁：是一种开销最大的锁策略。        并发控制当多个连接记录进行修改时保证数据的一致性和完整性。        事务事务用于保证数据库的完整性。  举例：用户银行转账用户A 转账200元 用户B实现步骤：1）从当前账户减掉200元（账户余额大于等于200元）。2）在对方账户增加200元。事务特性：1）原子性（atomicity）2）一致性（consistency）3）隔离性（isolation）4）持久性（durability）      外键是保证数据一致性的策略。        索引是对数据表中一列或多列的值进行排序的一种结构。  类型MySQL主要支持以下几种引擎类型：  MyISAM  InnoDB  Memory  CSV  Archive各类存储引擎特点            特点      MyISAM      InnoDB      Memory      Archive                  存储限制      256TB      64TB      有      无              事务安全      -      支持      -      -              支持索引      支持      支持      支持                     锁颗粒      表锁      行锁      表锁      行锁              数据压缩      支持      -      -      支持              支持外键      -      支持      -      -      CSV:实际上是由逗号分隔的数据引擎，在数据库子目录为每一个表创建一个.csv的文件，这是一种普通的文本文件，每一个数据行占用一个文本行。不支持索引。BlackHole：黑洞引擎，写入的数据都会消失，一般用于做数据复制的中继。MyISAM：适用于事务的处理不多的情况。InnoDB：适用于事务处理比较多，需要有外键支持的情况。索引分类：普通索引、唯一索引、全文索引、btree索引、hash索引…修改存储引擎  通过修改MySQL配置文件default-storage-engine=engine_name  通过创建数据表命令实现CREATE TABLE table_name(...)ENGINE=engine_name  通过修改数据表命令实现ALTER TABLE table_name ENGINE[=]engine_name4 管理工具      phpMyAdmin需要有PHP环境    Navicat  MySQL Workbench  Sequel Pro]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> mysql </tag>
        
          <tag> database </tag>
        
          <tag> 读书笔记 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 中的SQL]]></title>
      <url>/blog/mysql-sql-study/</url>
      <content type="text"><![CDATA[结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言，IBM公司最早使用在其开发的数据库系统中。不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。文章以MySQL数据库为演示环境，主要分享MySQL中的SQL使用。数据库操作创建数据库CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [DEFAULT] CHARACTER SET [=] character_name{}表示为必选项，即必填参数。|表示选项，即其中选取一项即可。[]表示为可选项。character_name 参数为指定数据库的编码方式，不填则使用MySQL配置的字符集编码。查看当前服务器下的数据表列表SHOW {DATABASES | SCHEMAS} [LIKE 'pattern' | WHERE expr]删除数据库DROP {DATABASE | SCHEMA} [IF NOT EXISTS] db_nameAUTO_INCREMENT自动编号，且必须与主键组合使用。数值型数据。默认情况下，起始值为1，每次的增量为1。约束1.保证数据的完整性和一致性。2.分为表级约束（针对两个或两个以上的字段进行约束）和列级约束（针对某一个字段进行约束）。3.类型包括：  NOT NULL 非空约束  PRIMARY KEY 主键约束  UNIQUE KEY 唯一约束  DEFAULT 默认约束  FOREIGN KEY 外键约束CREATE TABLE t6(id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY, username VARCHAR(20) NOT NULL UNIQUE KEY, sex ENUM('1', '2', '3') DEFAULT '3');INSERT t6 (username) VALUES ('Chars');空值与非空值NULL，字段值可以为空。NOT NULL，字段值禁止为空。不存在表级约束。PRIMARY KEY主键约束。每张数据表只能存在一个主键。主键保证记录的唯一性。主键自动为NOT NULL。注意：AUTO_INCREMENT必须与PRIMARY KEY一起使用。但是，PRIMARY KEY不一定与AUTO_INCREMENT一起使用。UNIQUE KEY唯一约束。唯一约束可以保证记录的唯一性。唯一约束的字段可以为空值（NULL）。每张数据表可以存在多个唯一约束。注意：UNIQUE KEY与PRIMARY KEY区别PRIMARY KEY每张数据表只能有一个，且不能为空。UNIQUE KEY每张数据表可以有多个，且可以为空。DEFAULT默认值。当插入记录时，如果没有明确为字段赋值，则自动赋予默认值。不存在表级约束。FOREIGN KEY保持数据一致性，完整性。实现一对一或一对多关系。关系型数据库名称的来源。外键约束的要求1.父表和子表必须使用相同的存储引擎，而且禁止使用临时表。2.数据表的存储引擎只能为InnoDB。3.外键列和参照列必须具有相似的数据类型。其中数字的长度或是否有符号位必须相同；而字符的长度则可以不同。4.外键列和参照列必须创建索引。如果外键列不存在索引的话，MySQL将自动创建索引。外键约束的参照操作1.CASCADE：从父表删除或更新且自动删除或更新子表中匹配的行。2.SET NULL：从父表删除或更新行，并设置子表中的外键列为NULL。如果使用该选项，必须保证子表列没有指定NOT NULL。3.RESTRICT：拒绝对父表的删除或更新操作。4.NO ACTION：标准SQL的关键字，在MySQL中与RESTRICT相同。注意：物理外键即使用FOREIGN KEY关键字定义表。逻辑外键即定义表的时候按照某种联系，但是不使用FOREIGN KEY关键字修饰。编辑数据表的默认存储引擎MySQL配置文件default-storage-engine=INNODB示例：create table provinces(id smallint unsigned primary key auto_increment, pname varchar(20) not null);create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid bigint, foreign key(pid) references provinces(id));# 报错# ERROR 1215 (HY000): Cannot add foreign key constraint# 因为类型不匹配# 正确命令应该是：create table users(id smallint unsigned primary key auto_increment, username varchar(10) not null, pid smallint unsigned, foreign key(pid) references provinces(id));表级约束和列级约束对一个数据列建立的约束，称为列级约束。对多个数据列建立的约束，称为表级约束。列级约束既可以在列定义时声明，也可以在列定义后声明。表级约束只能在列定义后声明。数据表操作数据表（或称表）是数据库最重要的组成部分之一，是其它对象的基础。数据表即二维表，行称为记录，列称为字段。USE打开数据库USE 数据库名称;创建数据表CREATE TABLE [IF NOT EXISTS] table_name (column_name data_type, ...)查看数据表列表SHOW TABLES [FROM db_name] [LIKE 'pattern' | WHERE expr]查看数据表结构SHOW COLUMNS FROM tbl_name插入表记录INSERT [INTO] tbl_name [(col_name,...)] VALUES(val,...)如果省略col_name就需要写全数据表所有的值。记录查找SELECT expr,... FROM tbl_name添加单列（数据表字段）ALTER TABLE tbl_name ADD [COLUMN] col_name column_definition [FIRST|AFTER col_name]            省略[FIRST      AFTER col_name]参数将位于所有列的最后面。      添加多列（数据表字段）ALTER TABLE tbl_name ADD [COLUMN] (col_name column_definition, ...)删除列（数据表字段）ALTER TABLE tbl_name DROP [COLUMN] col_name添加主键约束ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] PRIMARY KEY [index_type] (index_col_name, ...)添加唯一约束ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] UNIQUE [INDEX|KEY] [index_name] [index_type] (index_col_name, ...)添加外键约束ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] FOREIGN KEY [index_name] (index_col_name, ...) reference_definition添加／删除默认约束ALTER TABLE tbl_name ALTER [COLUMN] col_name {SET DEFAULT literal | DROP DEFAULT}删除主键约束ALTER TABLE tbl_name DROP PRIMARY KEY删除唯一约束ALTER TABLE tbl_name DROP {INDEX | KEY} index_name删除外键约束ALTER TABLE tbl_name DROP FOREIGN KEY fk_symbol修改列定义ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST | AFTER col_name]修改列名称ALTER TABLE tbl_name CHANGE [COLUMN] old_col_name new_col_name column_definition [FIRST | AFTER col_name]数据表更名# 方法1ALTER TABLE tbl_name RENAME [TO|AS] new_tbl_name# 方法2RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_tbl_name2] ...数据表数据操作INSERT# 插入记录（可以插入多条记录）INSERT [INTO] tbl_name [(col_name, ...)] {VALUES|VALUE} ({expr|DEFAULT}, ...), (...), ...# 插入记录（不可以插入多条记录）INSERT [INTO] tbl_name SET col_name = {expr|DEFAULT}, ...# 说明：与前一种方式的区别在于，此方法可以使用子查询（SubQuery）。由比较运算引发子查询（SubQuery）。# 插入记录INSERT [INTO] tbl_name [(col_name, ...)] SELECT ...# 说明：此方法可以将查询结果插入到指定数据表。示例：1.创建“商品分类”表CREATE TABLE IF NOT EXISTS tdb_goods_cates(cate_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,cate_name VARCHAR(40));2.查询tdb_goods表的所有记录，并且按"类别"分组SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;3.将分组结果写入到tdb_goods_cates数据表INSERT tdb_goods_cates (cate_name) SELECT goods_cate FROM tdb_goods GROUP BY goods_cate;UPDATE# 更新记录（单表更新）UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1 = {expr|DEFAULT} [, col_name2 = {expr|DEFAULT}] ... [WHERE where_condition]DELETE# 删除记录（单表删除）DELETE FROM tbl_name [WHERE where_condition]SELECT# 查找记录SELECT select_expr [, select_expr ...] [	FROM table_references	[WHERE where_condition]	[GROUP BY {col_name|position} [ASC|DESC], ... ]	[HAVING where_condition]	[ORDER BY {col_name|expr|position} [ASC|DESC], ...]	[LIMIT {[offset,] row_count | row_count OFFSET offset}]]select_expr 查询表达式每一个表达式表示想要的一列，必须至少有一个。多个列之间以英文逗号分隔。星号（*）表示多有列。tbl_name.*可以表示命名表的所有列。查询表达式可以使用[AS] alias_name为其赋予别名。别名可用于GROUP BY，ORDER BY或HAVING子句。WHERE 条件表达式对记录进行过滤，如果没有指定WHERE子句，则显示所有记录。在WHERE表达式中，可以使用MySQL支持的函数或运算符。GROUP BY 查询结果分组[GROUP BY {col_name|position} [ASC|DESC], ... ]ASC：生序，默认值。DESC：降序。HAVING 分组条件[HAVING where_condition]where_condition中要么使用聚合函数，要么出现的字段一定要在SELECT中出现。聚合函数：count() …ORDER BY 对查询结果进行排序[ORDER BY {col_name|expr|position} [ASC|DESC], ...]LIMIT 限制查询返回的数量[LIMIT {[offset,] row_count | row_count OFFSET offset}]offset是从0开始的。CREATE … SELECT创建数据表同时将查询结果写入到数据表CREATE TABLE [IF NOT EXISTS] tbl_name [(create_definition, ...)] select_statement示例：  通过CREATE…SELECT来创建数据表并且同时写入记录CREATE TABLE tdb_goods_brands (brand_id SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,brand_name VARCHAR(40) NOT NULL) SELECT brand_name FROM tdb_goods GROUP BY brand_name;子查询子查询（Subquery）是指出现在其他SQL语句内的SELECT子句。例如：SELECT * FROM t1 WHERE col1=(SELECT col2 FROM t2);其中SELECT * FROM t1称为Outer Query/Outer Statement。SELECT col2 FROM t2称为SubQuery。子查询指嵌套在查询内部，且必须始终出现在圆括号内。子查询可以包含多个关键字或条件，如DISTINCT、GROUP BY、ORDER BY、LIMIT函数等。子查询外层的查询可以是：SELECT、INSERT、UPDATE、SET或DO。子查询可以返回标量、一行、一列或子查询。数据准备1.创建表create table tdb_goods (	goods_id smallint unsigned primary key auto_increment,	goods_name varchar(150) not null, 	goods_cate varchar(40) not null, 	brand_name varchar(40) not null,	goods_price decimal(15,3) unsigned default 0 not null, 	is_show boolean default 1 not null, 	is_saleoff boolean default 0 not null);2.添加数据INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('Mac Pro MD878CH/A 专业级台式电脑','服务器/工作站','苹果','28888',DEFAULT,DEFAULT); INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES(' HMZ-T3W 头戴显示设备','笔记本配件','索尼','6999',DEFAULT,DEFAULT);INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('商务双肩背包','笔记本配件','索尼','99',DEFAULT,DEFAULT);INSERT tdb_goods (goods_name,goods_cate,brand_name,goods_price,is_show,is_saleoff) VALUES('X3250 M4机架式服务器 2583i14','服务器/工作站','IBM','6888',DEFAULT,DEFAULT);分类使用比较运算符的子查询=、&gt;、&lt;、&gt;=、&lt;=、&lt;&gt;、!=、&lt;=&gt; ...语法结构operand comparison_operator subquery示例：      求所有电脑产品的平均价格,并且保留两位小数，AVG,MAX,MIN、COUNT、SUM为聚合函数SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods;        查询所有价格大于平均价格的商品，并且按价格降序排序SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; 5845.10 ORDER BY goods_price DESC;        使用子查询来实现SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price &gt; (SELECT ROUND(AVG(goods_price),2) AS avg_price FROM tdb_goods) ORDER BY goods_price DESC;  用ANY、SOME或ALL修饰的比较运算符operand comparison_operator ANY(subquery)operand comparison_operator SOME(subquery)operand comparison_operator ALL(subquery)ANY、SOME、ALL关键字示例：  查询价格大于或等于”超级本”价格的商品，并且按价格降序排列SELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price = ANY(SELECT goods_price FROM tdb_goods WHERE goods_cate = '超级本') ORDER BY goods_price DESC;使用[NOT]IN的子查询语法结构operand comparison_operator [NOT]IN(subquery)=ANY运算符与IN等效。!=ALL或&lt;&gt;ALL运算符与NOT IN等效。示例：  = ANY 或 = SOME 等价于 INSELECT goods_id,goods_name,goods_price FROM tdb_goods WHERE goods_price IN (SELECT goods_price FROM tdb_goods WHERE goods_cate = '超级本') ORDER BY goods_price DESC;使用[NOT]EXISTS的子查询如果子查询返回任何行，EXISTS将返回TRUE；否则为FALSE。连接MySQL在SELECT语句、多表更新、多表删除语句中支持JOIN操作。多表更新UPDATE table_references SET col_name1 = {expr1|DEFAULT} [, col_name2 = {expr2|DEFAULT}] ... [WHERE where_condition]table_references 的语法结构：{[INNER|CROSS] JOIN | {LEFT|RIGHT} [OUTER] JOIN} table_reference ON conditional_expr数据表参照table_referencestbl_name [[AS] alias]|table_subquery [AS] alias数据表可以使用tbl_name AS alias_name或tbl_name alias_name赋予别名。table_subquery可以作为子查询使用在FROM子句中，这样的子查询必须为其赋予别名。连接类型INNER JOIN，内连接。在MySQL中，JOIN，CROSS JOIN和INNER JOIN是等价的。LEFT [OUTER] JOIN，左外连接。RIGHT [OUTER] JOIN，右外连接。示例：  通过tdb_goods_cates数据表来更新tdb_goods表UPDATE tdb_goods INNER JOIN tdb_goods_cates ON goods_cate = cate_name SET goods_cate = cate_id ;多表删除DELETE tbl_name [.*] [, tbl_name [.*]] ... FROM table_references [WHERE where_condition]内连接显示左表及右表符合连接条件的记录。即仅显示符合连接条件的内容。外连接A LEFT JOIN B join_condition.数据表B的结果集依赖数据表A。数据表A的结果集根据左连接条件依赖所有数据表（B表除外）。左外连接条件决定如何检索数据表B（在没有指定WHERE条件的情况下）。如果数据表A的某条记录符合WHERE条件，但是在数据表B不存在符合连接条件的记录，将生成一个所有列为空的额外的B行。如果使用内连接查找的记录在连接数据表中不存在，并且在WHERE子句中尝试以下操作：col_name IS NULL时，如果col_name被定义为NOT NULL，MySQL将在找到符合连接条件的记录后停止搜索更多的行。  左外连接显示左表的全部记录及右表符合连接条件的记录。  右外连接显示右表的全部记录及左表符合连接条件的记录。连接条件使用ON关键字来设定连接条件，也可以使用WHERE来代替。通常使用ON关键字来设定连接条件，使用WHERE关键字进行结果集记录的过滤。无限级分类表设计      无限分类的数据表设计CREATE TABLE tdb_goods_types(   type_id   SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,   type_name VARCHAR(20) NOT NULL,   parent_id SMALLINT UNSIGNED NOT NULL DEFAULT 0);        插入数据    INSERT tdb_goods_types(type_name,parent_id) VALUES('家用电器',DEFAULT);INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑、办公',DEFAULT);INSERT tdb_goods_types(type_name,parent_id) VALUES('大家电',1);INSERT tdb_goods_types(type_name,parent_id) VALUES('生活电器',1);INSERT tdb_goods_types(type_name,parent_id) VALUES('平板电视',3);INSERT tdb_goods_types(type_name,parent_id) VALUES('空调',3);INSERT tdb_goods_types(type_name,parent_id) VALUES('电风扇',4);INSERT tdb_goods_types(type_name,parent_id) VALUES('饮水机',4);INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑整机',2);INSERT tdb_goods_types(type_name,parent_id) VALUES('电脑配件',2);INSERT tdb_goods_types(type_name,parent_id) VALUES('笔记本',9);INSERT tdb_goods_types(type_name,parent_id) VALUES('超级本',9);INSERT tdb_goods_types(type_name,parent_id) VALUES('游戏本',9);INSERT tdb_goods_types(type_name,parent_id) VALUES('CPU',10);INSERT tdb_goods_types(type_name,parent_id) VALUES('主机',10);      自身连接同一个数据表对其自身进行连接。]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> mysql </tag>
        
          <tag> database </tag>
        
          <tag> 读书笔记 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[与 MySQL 的零距离接触]]></title>
      <url>/blog/mysql-study/</url>
      <content type="text"><![CDATA[MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。MySQL是一个开源的关系型数据库管理系统，分为社区版和企业版。1 安装直接前往官网 https://www.mysql.com/ ，进入download页面下载所需对应安装版本。默认配置安装即可。2 配置安装成功之后，需要修改密码。详看《MySQL 安装配置》修改编码方式：[mysql]default-character-set=utf8[mysql]character-set-server=utf83 目录结构bin目录，存储可执行文件。data目录，存储数据文件。docs，文档。include目录，存储包含的头文件。lib目录，存储库文件。share，错误消息和字符集文件。4 命令参数说明            参数      描述                  -D,–database=name      打开指定数据库              –delimiter=name      指定分隔符              -h,–host=name      服务器名称              -p,–password[=name]      密码              -P,–port=#      端口号              –prompt=name      设置提示符              -u,–user=name      用户名              -V,–version      输出版本信息并退出      MySQL提示符            参数      描述                  \D      完整的日期              \d      当前数据库              \h      服务器名称              \u      当前用户      命令使用修改MySQL提示符1.连接客户端时通过参数指定mysql -uroot -proot --prompt 提示符2.连接上客户端后，通过prompt命令修改mysql&gt;prompt 提示符MySQL常用命令1.显示当前服务器版本SELECT VERSION();2.显示当前日期时间SELECT NOW();3.显示当前用户SELECT USER();MySQL语句规范1.关键字与函数名称全部大写。2.数据库名称、表名称、字段名称全部小写。3.SQL语句必须以”;”符号结尾。5 SQL结构化查询语言（英语：Structured Query Language，缩写：SQL），是一种特殊目的之编程语言，用于数据库中的标准数据查询语言。不过各种通行的数据库系统在其实践过程中都对SQL规范作了某些编改和扩充。所以，实际上不同数据库系统之间的SQL不能完全相互通用。具体参看文章《MySQL 中的SQL》6 数据类型数据类型是指列、存储过程参数、表达式和局部变量的数据特征，它决定了数据的存储格式，代表了不同信息的类型。整型浮点型            数据类型      存储范围                  FLOAT[(M,D)]      -3.402823466E+38到-1.175494351E-38、0和1.175494351E-38到3.402823466E+38。M是数字总位数，D是小数点后面的位数。如果M和D被省略，根据硬件允许的限制来保存值。单精度浮点数精确到大约7位小数点。              DOUBLE[(M,D)]      -1.7976931348623157E+308到-2.2250738585072014E-308、0和2.2250738585072014E-308到1.7976931348623157E+308。      日期和时间型            列类型      存储需求                  YEAR      1              TIME      3              DATE      3              DATETIME      8              TIMESTAMP      4      字符型            列类型      存储需求                  CHAR(M)      M个字节，0&lt;=M&lt;=255              VARCHAR(M)      L+1个字节，其中L&lt;=M且0&lt;=M&lt;=65535              TINYTEXT      L+1个字节，其中L&lt;2^8              TEXT      L+2个字节，其中L&lt;2^16              MEDIUMTEXT      L+3个字节，其中L&lt;2^24              LONGTEXT      L+4个字节，其中L&lt;2^32              ENUM(‘VALUE1’,’VALUE2’,…)      1或2个字节，取决于枚举值的个数（最多65,535个值）              SET(‘VALUE1’,’VALUE2’,…)      1、2、3、4或者8个字节，取决于set成员的数目（最多64个成员）      更多其他MySQL使用与知识可以参见《拆解 MySQL 的高阶使用与概念》]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> mysql </tag>
        
          <tag> database </tag>
        
          <tag> 读书笔记 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[聊聊Objective-C的Runtime]]></title>
      <url>/blog/objc-runtime/</url>
      <content type="text"><![CDATA[Objective-C 语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。对于 Objective-C 来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。Runtime 基本上是用 C 和汇编写的，这个库使得C语言有了面向对象的能力。在 Runtime 中，对象可以用 C 语言中的结构体表示，而方法可以用 C 函数来实现，另外再加上了一些额外的特性。这些结构体和函数被 runtime 函数封装后，让 Objective-C 的面向对象编程变为可能。找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime 会根据消息接收者是否能响应该消息而做出不同的反应。1 消息机制与古老的 C 语言不同，Objective-C 虽然源自 C 语言，但是它却是面向对象的，在这之中，消息机制发挥着重大作用。C语言和Objective-C编译时的区别：C 语言在编译的时候，已经知道调用哪一个函数。Objective-C 不一样，只有在运行时才知道需要调用的方法和函数。OBJC_EXPORT void objc_msgSend(void /* id self, SEL op, ... */ )    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);使用这个方法要#import &lt;objc/message.h&gt;，另外，Apple 在 Xcode5 开始，不建议使用底层方法，而恰巧以上方法就是底层方法。此时，Xcode 就会报错，那么，如何解决呢？解决方案如下：  1）打开 Project 的Build Settings，搜索“msg”。  2）将Enable Strict Checking of objc_msgSend Calls的值设置为 NO。发送无参消息@interface Sample : NSObject+ (void)run;- (void)run;- (void)eatWithFood:(NSString *)food;@end@implementation Sample+ (void)run{    NSLog(@"类方法 run");}- (void)run{    NSLog(@"实例方法 run");}- (void)eatWithFood:(NSString *)food{    NSLog(@"实例方法 eat：%@", food);}@end- (void)test {	Sample *t = [[Sample alloc] init];	objc_msgSend(t, @selector(run));	objc_msgSend([Sample class], @selector(run));}发送带参消息- (void)test {	Sample *t = [[Sample alloc] init];	objc_msgSend(t, @selector(eatWithFood:), @"apple");}附加：将Objective-C转换出Runtime代码方法clang -rewrite-objc xxxx.m交换方法的实现class_getInstanceMethod(__unsafe_unretained Class cls, SEL name)获取对象方法。class_getClassMethod(__unsafe_unretained Class cls, SEL name)获取类方法。method_exchangeImplementations(Method m1, Method m2)交换方法的实现方式。常见示例代码：NSURL *url = [NSURL URLWithString:@"https://charsdavy.github.io"];[NSURLRequest requestWithURL:url];但url可能返回nil，而此段代码未能对返回值url进行合法判断。但每次使用以上类似代码都需要进行合法性判断，那么有什么更好的方法使URLWithString:能够做合法性判断呢？这个时候就需要使用Runtime的特有方法了。@interface NSURL (DD)+ (instancetype)dd_URLWithString:(NSString *)URLString;@end@implementation NSURL (DD)// 加载此分类时调用+ (void)load{    //获取方法名称    Method urlMethod = class_getClassMethod([NSURL class], @selector(URLWithString:));    Method ddUrlMethod = class_getClassMethod([NSURL class], @selector(dd_URLWithString:));    //交换方法的实现    method_exchangeImplementations(urlMethod, ddUrlMethod);}//此方法与URLWithString:交换了实现方式+ (instancetype)dd_URLWithString:(NSString *)URLString{//    NSURL *url = [NSURL URLWithString:URLString]; 此处不能再调用此方法，否则会死循环    NSURL *url = [NSURL dd_URLWithString:URLString];    if (!url) {        NSLog(@"url is nil");    }    return url;}@end归档和解档先来理解几个 Objective-C 中的概念：序列化：将自定义的 Objective-C 的对象转化成二进制文件数据。反序列化：将二进制文件数据转化成自定义的 Objective-C 的对象。归档：将自定义的 Objective-C 的对象存储到本地磁盘。解档：将存储在本地磁盘的数据转换成自定义的 Objective-C 的对象。Ivar 类型：成员属性。Method 类型：成员方法。通常我们使用归档和解档的方式如下：@interface Sample : NSObject&lt;NSCoding&gt;@property (nonatomic) NSString *name;@property (nonatomic) NSString *age;@end@implementation Sample- (void)encodeWithCoder:(NSCoder *)aCoder{    [aCoder encodeObject:self.name forKey:@"name"];    [aCoder encodeObject:self.age forKey:@"age"];}- (instancetype)initWithCoder:(NSCoder *)aDecoder{    self = [super init];    if (self) {        self.name = [aDecoder decodeObjectForKey:@"name"];        self.age = [aDecoder decodeObjectForKey:@"age"];    }    return self;}@end- (void)saveObject{    Sample *p = [[Sample alloc] init];    p.name = @"Chars";    p.age = @"18";        NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@"chars.dat"];        BOOL flag = [NSKeyedArchiver archiveRootObject:p toFile:path];    if (flag) {        NSLog(@"success");    } else {        NSLog(@"falied");    }    NSLog(@"%@", path);}- (void)readObject{    NSString *path = [NSTemporaryDirectory() stringByAppendingPathComponent:@"chars.dat"];        Sample *p = [NSKeyedUnarchiver unarchiveObjectWithFile:path];    if (p) {        NSLog(@"name:%@,age:%@", p.name, p.age);    } else {        NSLog(@"falied");    }    NSLog(@"%@", path);}Objective-C 中归档底层实现方式：将对象拆分为字典（键值对），然后变成二进制存入磁盘。但是，当 model 中成员属性数量很多的时候，就沦为了体力劳动。那么，此时我们又能使用 Runtime 来简化工作。class_copyIvarList(__unsafe_unretained Class cls, unsigned int *outCount)获取 Class 中成员变量的个数。以下就是使用 Runtime 消息机制编写的归档与解档方法：- (void)encodeWithCoder:(NSCoder *)aCoder{       unsigned int count = 0;    Ivar *ivars = class_copyIvarList([Sample class], &amp;count);    for (int i = 0; i &lt; count; i++) {        Ivar ivar = ivars[i];        const char *name = ivar_getName(ivar);        NSString *key = [NSString stringWithUTF8String:name];        [aCoder encodeObject:[self valueForKey:key] forKey:key];    }    free(ivars);}- (instancetype)initWithCoder:(NSCoder *)aDecoder{    self = [super init];    if (self) {        unsigned int count = 0;        Ivar *ivars = class_copyIvarList([Sample class], &amp;count);        for (int i = 0; i &lt; count; i++) {            Ivar ivar = ivars[i];            const char *name = ivar_getName(ivar);            NSString *key = [NSString stringWithUTF8String:name];            id value = [aDecoder decodeObjectForKey:key];            [self setValue:value forKey:key];        }        free(ivars);    }    return self;}2 KVO利用 Runtime，在运行时动态创建一个对象。实现原理：  创建NSKVONotifying_XXX:XXX类(XXX为被监听者)。  重写属性 set 方法，调用willChangeValueForKey:和didChangeValueForKey:方法，进而触发调用观察者的observeValueForKeyPath:ofObject:change:context:示例代码：@interface Viewer : NSObject@property (nonatomic) NSString *name;@property (nonatomic) NSString *age;@end@interface Observer : NSObject@property (nonatomic) NSString *name;@property (nonatomic) NSString *age;@end@implementation Observer- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context{    NSLog(@"object:%@, keyPath:%@, change:%@", object, keyPath, change);}@endObserver *observer = [[Observer alloc] init];Viewr *viewer = [[Viewer alloc] init];//注册监听,viewer为被监听者，observer为观察者[viewr addObserver:observer forKeyPath:@"age" options:NSKeyValueObservingOptionNew context:nil];//触发KVOviewer.age = @"99";3 动态添加方法当方法被调用时，才被加载。+ (BOOL)resolveClassMethod:(SEL)sel;当一个类被调用了一个没有实现的方法时，则会调用此方法。+ (BOOL)resolveInstanceMethod:(SEL)sel当一个类被调用了一个没有实现的实例方法时，则会调用此方法。class_addMethod(__unsafe_unretained Class cls, SEL name, IMP imp, const char *types)动态添加方法。参数cls ：类类型。参数name ：方法编号。参数imp ：方法实现，就是一个函数的指针。参数* types ：方法类型@implementation Sample//一个类被调用了一个没有实现的实例方法时，则会调用此方法。+ (BOOL)resolveInstanceMethod:(SEL)sel{    if (sel == @selector(eat)) {        //添加一个实例方法        class_addMethod([Sample class], sel, (IMP)eat, "v@:");    }    return [super resolveInstanceMethod:sel];}//隐式参数,self和_cmd是系统传过来的参数void eat(id self, SEL _cmd) {    NSLog(@"调用了%@的%@方法", self, NSStringFromSelector(_cmd));}@end[[[Sample alloc] init] performSelector:@selector(eat)];]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
          <tag> runtime </tag>
        
          <tag> 读书笔记 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[日语-敬体和简体]]></title>
      <url>/blog/japanese-honorific-tongue/</url>
      <content type="text"><![CDATA[在口语里，日语的谓语形式根据说话人之间的上下级关系、亲疏关系的不同而不同。“～ます”、“～です”是对长辈或关系不太亲密的人使用的形式。这种形式我们称为“敬体形”。与此相反，如对方是自己的同辈或晚辈，或者关系比较密切时则使用“简体形”。“简体形”是不使用“ます”、“です”的形式。动词本身即具有“敬体形”和“简体形”，“～ます”、“～ません”、“～ました”、“～ませんでした”等四种礼貌的表达形式即是“敬体形”，而动词的“基本形”、“ない形”、“た形”都属于简体形。但一类形容词、二类形容词和名词本身没有“敬体形”和“简体形”之分，只有在做谓语时，其谓语形式才具有“敬体形”和“简体形”。1 动词            时态      敬体      简体      示例                  现在时      〜ます      原形      あります-&gt;ある              过去时      〜ました      〜た      ありました-&gt;あった              否定式      〜ません      〜ない      ありません-&gt;あらないない              过去否定式      〜ませんでした      〜なかった      ありませんでした-&gt;なかった      2 形容词具体变形规则可以参看《日语-形容词》2.1 一类形容词            时态      敬体      简体      示例                  现在时      〜です      〜です      おいしいです-&gt;おいしい              过去时      〜かったです      〜かったです      おいしい~~かったです-&gt;おいしい~~かった              否定式      〜くないです      〜くないです      おいしい~~くないです-&gt;おいしい~~くない              过去否定式      〜くなかったです      〜くなかったです      おいしい~~くなかったです-&gt;おいしい~~くなかった      おいしい（美味しい）2.2 二类形容词            时态      敬体      简体      示例                  现在时      〜です      〜だ      元気です-&gt;元気だ              过去时      〜でした      〜だった      元気でした-&gt;元気だった              否定式      〜ではありません      〜ではない/〜じゃない      元気ではありません-&gt;元気ではない/元気じゃない              过去否定式      〜ではありませんでした      〜ではなかった/〜じゃなかった      元気ではありませんでした-&gt;元気ではなかった/元気じゃなかった      昨日、暑かった？ううん、全然暑くなかった。この着物、派手（はで）？ううん、全然派手じゃないわ（此处男性使用时不加わ）。3 名词形式规则与二类形容词一致。4 敬语的基本型尊他语（尊敬語）            基本型      尊敬语                  　お〜になら　      　お待ちになる　　お読みになる　　お書きになる　　お聴きになる　              　ご〜になら　      　ご入学になる　　ご視察になる　　ご說明になる　              　〜れる　　〜られる　      　行かれる　　聞かれる　　話される 　来られる　      自谦语（謙譲語）            基本型      自谦语                  　お〜する　      　お待ちする　　お書きする　　お聴きする　              　ご〜する　      　ご案內する　　ご返事する　　ご說明する　              　〜いただく(相手の動作)　      　お越しいただく　　ご覽いただく　              　〜させていただく(自分の動作)　      　聞かせていただく　　読ませていただく　　出席させていただく　              　〜いたす　      　出席いただく　　連絡させていただく　      礼貌语（丁寧語）            基本型      礼貌语                  　〜です　      　〜です　　〜ます　　〜ございます　              　〜ます　      　　              　〜ございます　      　　      混合表            基本型      尊他语      自谦语                  　いる　      　いらっしゃいます　　おいでになります　      　おります　              　する　      　なさいます　      　いたします　              　行く　      　いらっしゃいます　      　参ります　              　来る　      　いらっしゃいます　　お見えになります  お越しになります　      　参ります　              言う      おっしゃいます　      申します　 申し上げます　              会う　      お会いになる　      お目にかかる　              聞く　      お聞きになります　      うかがいます　 承ります　              見る　      ご覧になります　      拝見いたします　              見せる　      お見せになります　      お目にかける　 お見せする　              与える      くださいます      差し上げます　 上げます　              知っている　      ご存知です　      存じ上げております　 存じております              持って行く　      お持ちになら　      持参います　              食べる・飲む　      召し上がります　      いただきます　              もらう　             いただきます　　頂戴いたします　              着る　      召す　 お召しになら　      着る　              ほめる　      お褒めになる　      お褒めにあずかる　              借りる　      お借りになる　      拝借する　              思う　      おぼしめす　      存じます　      礼貌语的使用方法            丁寧語の程度による使い分け      同僚との会話      普通の丁寧語                  どうする　      どうします　      いかがなさいますか　              いいか　      いいですか　      いかがでございましょう　              そうだ　      そうです　      さようでございます　              これを見て　      これを見てください　      これをご覧くださyい　              わかったか　      わかりますか　      お分かりいただけましたでしょうか　              聞いた　      ききました　      うかがいました　              ある　      あります　      ございます　              いってみろ　      話してください　      おっしゃってください　      そのほか/其他            普通語      丁寧語                  あっち　      あちら　              こっち　      こちら　              きょう（今日）      ほんじつ（本日）              きのう（昨日）      さくじつ（昨日）              あした（明日）      みょうにち（明日）              おととい（一昨日）      いっさくじつ（一昨日）              あさって（明後日）      みょうごにち（明後日）              少し　      少少              どう　      いかが　              いくら　      いかほど　              すみません　      相すみません　              けさ（今朝）      こんちょう（今朝）              ゆうべ（昨夜）      さくや（昨夜）              ことし（今年）      ほんねん（本年）              きょねん（去年）      さくねん（昨年）              おととし（一昨年）      いっさくねん（一昨年）              今      只今              今度      この度              この間      せんじつ（先日）              どんな　      どの樣な　      ]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 日语 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Python 学习 基础篇]]></title>
      <url>/blog/python-basic-knowledge/</url>
      <content type="text"><![CDATA[全世界大概有几百种编程语言，而其中著名的只有十几种。Python就是著名编程语言之一。它起源于“龟叔”（Guido van Rossum，荷兰人）在1989年圣诞节间的无聊，而为了打发时间所创造。可见业余时间比工作时间创造出来的东西更容易出名哈，当然，这是开玩笑的。“龟叔”赋予Python“优雅、明确、简单”的特点。那么，Python适合做什么呢？它主要适用领域：Web网站和各种网络服务（YouTube、Instagram、douban、openstack）；系统工具和脚本；作为“胶水”语言把其它语言开发的模块包装起来方便使用。优点是显著的，但是也少不了缺点。Python不适用的领域：贴近硬件的代码（首选C）；移动开发（iOS／Android都有各自的开发语言）；因为不能做到告诉渲染，所以不适合游戏开发（首选C／C++）。Python和其它语言对比            语言      类型      运行速度      代码量                  C      编译为机器码      非常快      非常多              Java      编译为字节码      快      多              Python      解释执行      慢      少      CPU越来越快，程序的运行速度瓶颈往往不在Python的执行，更多受到网络速度和硬盘速度的制约。另外，Python发布程序即发布源代码。安装Python前往官网下载对应平台对应工具。另外Python2.7版本和3.3版本并不兼容，所以开发时请注意使用Python的版本。作为Mac OS X使用者，其实更推荐PyCharm IDE。安装之后直接使用即可。数据类型计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：整数Python可以处理任意大小的整数，当然包括负整数，在Python程序中，整数的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9 和 12.3x10^8 是相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9 就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。字符串字符串是以’‘或”“括起来的任意文本，比如’abc’，”xyz”等等。请注意，’‘或”“本身只是一种表示方式，不是字符串的一部分，因此，字符串’abc’只有a，b，c这3个字符。布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。布尔值可以用and、or和not运算。and运算是与运算，只有所有都为 True，and运算结果才是 True。or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型。print 语句print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下：&gt;&gt;&gt; print 'hello, world'注意：1.当我们在Python交互式环境下编写代码时，»&gt;是Python解释器的提示符，不是代码的一部分。2.当我们在文本编辑器中编写代码时，千万不要自己添加 »&gt;。print语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：&gt;&gt;&gt; print 'The quick brown fox', 'jumps over', 'the lazy dog'The quick brown fox jumps over the lazy dogprint会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：print也可以打印整数，或者计算结果：&gt;&gt;&gt; print 300300    #运行结果&gt;&gt;&gt; print 100 + 200300    #运行结果因此，我们可以把计算100 + 200的结果打印得更漂亮一点：&gt;&gt;&gt; print '100 + 200 =', 100 + 200100 + 200 = 300     #运行结果注意: 对于100 + 200，Python解释器自动计算出结果300，但是，’100 + 200 =’是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。Python的注释任何时候，我们都可以给程序加上注释。注释是用来说明代码的，给自己或别人看，而程序运行的时候，Python解释器会直接忽略掉注释，所以，有没有注释不影响程序的执行结果，但是影响到别人能不能看懂你的代码。Python的注释以 # 开头，后面的文字直到行尾都算注释# 这一行全部都是注释...print 'hello' # 这也是注释注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉：# 暂时不想运行下面一行代码:# print 'hello, python.'变量在Python中，变量的概念基本上和初中代数的方程变量是一致的。例如，对于方程式 y=x*x ，x就是变量。当x=2时，计算结果是4，当x=5时，计算结果是25。只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。在Python程序中，变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头，比如：a = 1变量a是一个整数。t_007 = 'T007'变量t_007是一个字符串。在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：a = 123    # a是整数print aa = 'Chars'   # a变为字符串print a这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：int a = 123; // a是整数类型变量a = "Chars"; // 错误：不能把字符串赋给整型变量和静态语言相比，动态语言更灵活，就是这个原因。请不要把赋值语句的等号等同于数学的等号。比如下面的代码：x = 10x = x + 2如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。最后，理解变量在计算机内存中的表示也非常重要。当我们写：a = 'ABC'时，Python解释器干了两件事情：      在内存中创建了一个’ABC’的字符串；        在内存中创建了一个名为a的变量，并把它指向’ABC’。  也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：a = 'ABC'b = aa = 'XYZ'print b最后一行打印出变量b的内容到底是'ABC'呢还是'XYZ'？如果从数学意义上理解，就会错误地得出b和a相同，也应该是'XYZ'，但实际上b的值是'ABC'，让我们一行一行地执行代码，就可以看到到底发生了什么事：执行a = 'ABC'，解释器创建了字符串 'ABC'和变量 a，并把a指向 'ABC'：执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串'ABC'：执行a = 'XYZ'，解释器创建了字符串'XYZ'，并把a的指向改为'XYZ'，但b并没有更改：所以，最后打印变量b的结果自然是'ABC'了。字符串定义字符串前面我们讲解了什么是字符串。字符串可以用''或者""括起来表示。如果字符串本身包含’怎么办？比如我们要表示字符串 I'm OK ，这时，可以用" "括起来表示："I'm OK"类似的，如果字符串包含”，我们就可以用’ ‘括起来表示：'Learn "Python" in Chars's Blog'如果字符串既包含’又包含”怎么办？这个时候，就需要对字符串的某些特殊字符进行“转义”，Python字符串用\进行转义。要表示字符串 Bob said "I'm OK".由于 ‘ 和 “ 会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为'Bob said \"I\'m OK\".'注意：转义字符 \ 不计入字符串的内容中。常用的转义字符还有：\n 表示换行\t 表示一个制表符\\ 表示 \ 字符本身raw字符串与多行字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如：r'\(~_~)/ \(~_~)/'但是r'...'表示法不能表示多行字符串，也不能表示包含'和 "的字符串（为什么？）如果要表示多行字符串，可以用'''...'''表示：'''Line 1Line 2Line 3'''上面这个字符串的表示方法和下面的是完全一样的：'Line 1\nLine 2\nLine 3'还可以在多行字符串前面添加 r ，把这个多行字符串也变成一个raw字符串：r'''Python is created by "Guido".It is free and easy to learn.Let's start learn Python in Chars's Blog!'''Unicode字符串字符串还有一个编码问题。因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…‘表示，比如：print u'中文'中文注意: 不加 u ，中文就不能正常显示。Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效：转义：u'中文\n日文\n韩文'多行：u'''第一行第二行'''raw+多行：ur'''Python的Unicode字符串支持"中文","日文","韩文"等多种语言'''如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释# -*- coding: utf-8 -*-目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。List创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。比如，列出班里所有同学的名字，就可以用一个list表示：&gt;&gt;&gt; ['Michael', 'Bob', 'Tracy']['Michael', 'Bob', 'Tracy']list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。构造list非常简单，按照上面的代码，直接用 [ ] 把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list：&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates # 打印classmates变量的内容['Michael', 'Bob', 'Tracy']由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据：&gt;&gt;&gt; L = ['Michael', 100, True]一个元素也没有的list，就是空list：&gt;&gt;&gt; empty_list = []按照索引访问list由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。因此，要打印第一名同学的名字，用 L[0]:&gt;&gt;&gt; print L[0]Adam要打印第二名同学的名字，用 L[1]:&gt;&gt;&gt; print L[1]Lisa要打印第三名同学的名字，用 L[2]:&gt;&gt;&gt; print L[2]Bart要打印第四名同学的名字，用 L[3]:&gt;&gt;&gt; print L[3]Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of range报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。所以，使用索引时，千万注意不要越界。倒序访问list我们还是用一个list按分数从高到低表示出班里的3个同学：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']这时，老师说，请分数最低的同学站出来。要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2：&gt;&gt;&gt; print L[2]Bart有没有更简单的方法？有！Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素：&gt;&gt;&gt; print L[-1]BartBart同学表示躺枪。类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示：&gt;&gt;&gt; print L[-2]Lisa&gt;&gt;&gt; print L[-3]Adam&gt;&gt;&gt; print L[-4]Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of rangeL[-4] 报错了，因为倒数第四不存在，一共只有3个元素。使用倒序索引时，也要注意不要越界。添加新元素现在，班里有3名同学：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']&gt;&gt;&gt; L.append('Paul')&gt;&gt;&gt; print L['Adam', 'Lisa', 'Bart', 'Paul']append()总是把新的元素添加到 list 的尾部。如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']&gt;&gt;&gt; L.insert(0, 'Paul')&gt;&gt;&gt; print L['Paul', 'Adam', 'Lisa', 'Bart']L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。删除元素Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？如果Paul同学排在最后一个，我们可以用list的pop()方法删除：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; L.pop()'Paul'&gt;&gt;&gt; print L['Adam', 'Lisa', 'Bart']pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Paul', 'Bart']要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉：&gt;&gt;&gt; L.pop(2)'Paul'&gt;&gt;&gt; print L['Adam', 'Lisa', 'Bart']替换元素假设现在班里仍然是3名同学：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart']现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。另一个办法是直接用Paul把Bart给替换掉：&gt;&gt;&gt; L[2] = 'Paul'&gt;&gt;&gt; print LL = ['Adam', 'Lisa', 'Paul']对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作：&gt;&gt;&gt; L[-1] = 'Paul'Tuple创建tupletuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，tuple一旦创建完毕，就不能修改了。同样是表示班里同学的名称，用tuple表示如下：&gt;&gt;&gt; t = ('Adam', 'Lisa', 'Bart')创建tuple和创建list唯一不同之处是用( )替代了[ ]。现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试：&gt;&gt;&gt; t[0] = 'Paul'Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment创建单元素tupletuple和list一样，可以包含 0 个、1个和任意多个元素。包含多个元素的 tuple，前面我们已经创建过了。包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示：&gt;&gt;&gt; t = ()&gt;&gt;&gt; print t()创建包含1个元素的 tuple 呢？来试试：&gt;&gt;&gt; t = (1)&gt;&gt;&gt; print t1好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号“,”，这样就避免了歧义：&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; print t(1,)可变的tuple前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个“可变”的tuple：&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])注意到 t 有 3 个元素：’a’，’b’和一个list：[‘A’, ‘B’]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到：&gt;&gt;&gt; L = t[2]然后，我们把list的两个元素改一改：&gt;&gt;&gt; L[0] = 'X'&gt;&gt;&gt; L[1] = 'Y'再看看tuple的内容：&gt;&gt;&gt; print t('a', 'b', ['X', 'Y'])不是说tuple一旦定义后就不可变了吗？怎么现在又变了？别急，我们先看看定义的时候tuple包含的3个元素：当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。条件判断和循环条件判断计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。if语句比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现：age = 20if age &gt;= 18:    print 'your age is', age    print 'adult'print 'END'注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。注意: if 语句后接表达式，然后用:表示代码块开始。如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车：&gt;&gt;&gt; age = 20&gt;&gt;&gt; if age &gt;= 18:...     print 'your age is', age...     print 'adult'...your age is 20adultif-else语句当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块：if age &gt;= 18:    print 'adult'如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？方法是再写一个 if:if age &lt; 18:    print 'teenager'或者用 not 运算：if not age &gt;= 18:    print 'teenager'细心的读者可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if ... else ... 语句把它们统一起来：if age &gt;= 18:    print 'adult'else:    print 'teenager'利用 if ... else ... 语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。注意: else 后面有个“:”。if-elif-else语句有的时候，一个 if ... else ... 还不够用。比如，根据年龄的划分：条件1：18岁或以上：adult条件2：6岁或以上：teenager条件3：6岁以下：kid我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3：if age &gt;= 18:    print 'adult'else:    if age &gt;= 6:        print 'teenager'    else:        print 'kid'这样写出来，我们就得到了一个两层嵌套的 if ... else ... 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby：if age &gt;= 18:    print 'adult'else:    if age &gt;= 6:        print 'teenager'    else:        if age &gt;= 3:            print 'kid'        else:            print 'baby'这种缩进只会越来越多，代码也会越来越难看。要避免嵌套结构的 if ... else ...，我们可以用 if ... 多个elif ... else ... 的结构，一次写完所有的规则：if age &gt;= 18:    print 'adult'elif age &gt;= 6:    print 'teenager'elif age &gt;= 3:    print 'kid'else:    print 'baby'elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。循环for循环list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list：L = ['Adam', 'Lisa', 'Bart']print L[0]print L[1]print L[2]如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。这时，循环就派上用场了。Python的 for 循环就可以依次把list或tuple的每个元素迭代出来：L = ['Adam', 'Lisa', 'Bart']for name in L:    print name注意:  name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。这样一来，遍历一个list或tuple就非常容易了。while循环和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。比如要从 0 开始打印不大于 N 的整数：N = 10x = 0while x &lt; N:    print x    x = x + 1while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。break退出循环用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。比如计算1至100的整数和，我们用while来实现：sum = 0x = 1while True:    sum = sum + x    x = x + 1    if x &gt; 100:        breakprint sum咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。continue继续循环在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。假设我们已经写好了利用for循环计算平均分的代码：L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L:    sum = sum + x    n = n + 1print sum / n现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环：for x in L:    if x &lt; 60:        continue    sum = sum + x    n = n + 1多重循环在循环内部，还可以嵌套循环，我们来看一个例子：for x in ['A', 'B', 'C']:    for y in ['1', '2', '3']:        print x + yx 每循环一次，y 就会循环 3 次。Dict类型我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字：['Adam', 'Lisa', 'Bart']或者考试的成绩列表：[95, 85, 59]但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。如果把名字和分数关联起来，组成类似的查找表：'Adam' ==&gt; 95'Lisa' ==&gt; 85'Bart' ==&gt; 59给定一个名字，就可以直接查到分数。Python的 dict 就是专门干这件事的。用 dict 表示“名字”-“成绩”的查找表如下：d = {    'Adam': 95,    'Lisa': 85,    'Bart': 59}我们把名字称为key，对应的成绩称为value，dict就是通过 key 来查找 value。花括号 {} 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。由于dict也是集合，len() 函数可以计算任意集合的大小：&gt;&gt;&gt; len(d)3注意: 一个 key-value 算一个，因此，dict大小为3。访问Dict我们已经能创建一个dict，用于表示名字和成绩的对应关系：d = {    'Adam': 95,    'Lisa': 85,    'Bart': 59}那么，如何根据名字来查找对应的成绩呢？可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key：&gt;&gt;&gt; print d['Adam']95&gt;&gt;&gt; print d['Paul']Traceback (most recent call last):  File "index.py", line 11, in &lt;module&gt;    print d['Paul']KeyError: 'Paul'注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。要避免 KeyError 发生，有两个办法：一是先判断一下 key 是否存在，用 in 操作符：if 'Paul' in d:    print d['Paul']如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。二是使用dict本身提供的一个 get 方法，在Key不存在的时候，返回None：&gt;&gt;&gt; print d.get('Bart')59&gt;&gt;&gt; print d.get('Paul')NoneDict特点dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。由于dict是按 key 查找，所以，在一个dict中，key不能重复。dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样：d = {    'Adam': 95,    'Lisa': 85,    'Bart': 59}当我们试图打印这个dict时：&gt;&gt;&gt; print d{'Lisa': 85, 'Adam': 95, 'Bart': 59}打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明dict内部是无序的，不能用dict存储有序的集合。dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。但是list是可变的，就不能作为 key。可以试试用list作为key时会报什么样的错误。不可变这个限制仅作用于key，value是否可变无所谓：{    '123': [1, 2, 3],  # key 是 str，value是list    123: '123',  # key 是 int，value 是 str    ('a', 'b'): True  # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean}最常用的key还是字符串，因为用起来最方便。更新Dictdict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict：d = {    'Adam': 95,    'Lisa': 85,    'Bart': 59}要把新同学’Paul’的成绩 72 加进去，用赋值语句：&gt;&gt;&gt; d['Paul'] = 72再看看dict的内容：&gt;&gt;&gt; print d{'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 59}如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value：&gt;&gt;&gt; d['Bart'] = 60&gt;&gt;&gt; print d{'Lisa': 85, 'Paul': 72, 'Adam': 95, 'Bart': 60}遍历Dict由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。直接使用for循环可以遍历 dict 的 key：&gt;&gt;&gt; d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }&gt;&gt;&gt; for key in d:...     print key... LisaAdamBart由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。Set类型dict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素：&gt;&gt;&gt; s = set(['A', 'B', 'C'])可以查看 set 的内容：&gt;&gt;&gt; print sset(['A', 'C', 'B'])请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？&gt;&gt;&gt; s = set(['A', 'B', 'C', 'C'])&gt;&gt;&gt; print sset(['A', 'C', 'B'])&gt;&gt;&gt; len(s)3结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。访问Set由于set存储的是无序集合，所以我们没法通过索引来访问。访问 set中的某个元素实际上就是判断一个元素是否在set中。例如，存储了班里同学名字的set：&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart', 'Paul'])我们可以用 in 操作符判断：Bart是该班的同学吗？&gt;&gt;&gt; 'Bart' in sTrueBill是该班的同学吗？&gt;&gt;&gt; 'Bill' in sFalsebart是该班的同学吗？&gt;&gt;&gt; 'bart' in sFalse看来大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。Set的特点set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。最后，set存储的元素也是没有顺序的。set的这些特点，可以应用在哪些地方呢？星期一到星期日可以用字符串’MON’, ‘TUE’, … ‘SUN’表示。假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？可以用 if 语句判断，但这样做非常繁琐：x = '???' # 用户输入的字符串if x!= 'MON' and x!= 'TUE' and x!= 'WED' ... and x!= 'SUN':    print 'input error'else:    print 'input ok'注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。如果事先创建好一个set，包含’MON’ ~ ‘SUN’：weekdays = set(['MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN'])再判断输入是否有效，只需要判断该字符串是否在set中：x = '???' # 用户输入的字符串if x in weekdays:    print 'input ok'else:    print 'input error'这样一来，代码就简单多了。遍历Set由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。直接使用 for 循环可以遍历 set 的元素：&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart'])&gt;&gt;&gt; for name in s:...     print name... LisaAdamBart注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。更新Set由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事：一是把新的元素添加到set中，二是把已有元素从set中删除。添加元素时，用set的add()方法：&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4])如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了：&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; print sset([1, 2, 3])删除set中的元素时，用set的remove()方法：&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3])如果删除的元素不存在set中，remove()会报错：&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.remove(4)Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;KeyError: 4所以用add()可以直接添加，而remove()前需要判断。函数我们知道圆的面积计算公式为：S = πr²当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 * r1 * r1s2 = 3.14 * r2 * r2s3 = 3.14 * r3 * r3当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle 本身只需要写一次，就可以多次调用。抽象是数学中非常常见的概念。举个例子：计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作：100∑nn=1这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。而且，这种抽象记法是可扩展的，比如：100∑(n²+1)n=1还原成加法运算就变成了：(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。调用函数Python内置了很多有用的函数，我们可以直接调用。要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。可以直接从Python的官方网站查看文档：http://docs.python.org/2/library/functions.html#abs也可以在交互式命令行通过 help(abs) 查看abs函数的帮助信息。调用 abs 函数：&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given)如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：&gt;&gt;&gt; abs('a')Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str'而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x==y，返回 0，如果 x&gt;y，返回 1：&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0Python内置的常用函数还包括数据类型转换函数，比如   int()函数可以把其他数据类型转换为整数：&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12str()函数把其他类型转换成 str：&gt;&gt;&gt; str(123)'123'&gt;&gt;&gt; str(1.23)'1.23'编写函数在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return 语句返回。我们以自定义一个求绝对值的 my_abs 函数为例：def my_abs(x):    if x &gt;= 0:        return x    else:        return -x请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。return None可以简写为return。返回多值函数可以返回多个值吗？答案是肯定的。比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：# math包提供了sin()和 cos()函数，我们先用import引用它：import mathdef move(x, y, step, angle):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, ny这样我们就可以同时获得返回值：&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0但其实这只是一种假象，Python函数返回的仍然是单一值：&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0)用print打印返回结果，原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * … * n，用函数 fact(n)表示，可以看出：fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。于是，fact(n)用递归的方式写出来就是：def fact(n):    if n==1:        return 1    return n * fact(n - 1)上面就是一个递归函数。可以试试：&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000L如果我们计算fact(5)，可以根据函数定义看到计算过程如下：===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。定义默认参数定义函数的时候，还可以有默认参数。例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数：&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int('123', 8)83int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。我们来定义一个计算 x 的N次方的函数:def power(x, n):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2：def power(x, n=2):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s这样一来，计算平方就不需要传入两个参数了：&gt;&gt;&gt; power(5)25由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面：# OK:def fn1(a, b=1, c=2):    pass# Error:def fn2(a=1, b):    pass定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数：def fn(*args):    print args可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数：&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn('a')('a',)&gt;&gt;&gt; fn('a', 'b')('a', 'b')&gt;&gt;&gt; fn('a', 'b', 'c')('a', 'b', 'c')可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数：def average(*args):    ...这样，在调用的时候，可以这样写：&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4切片对list进行切片取一个list的部分元素是非常常见的操作。比如，一个list如下：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']取前3个元素，应该怎么做？笨办法：&gt;&gt;&gt; [L[0], L[1], L[2]]['Adam', 'Lisa', 'Bart']之所以是笨办法是因为扩展一下，取前N个元素就没辙了。取前N个元素，也就是索引为0-(N-1)的元素，可以用循环：&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):...     r.append(L[i])... &gt;&gt;&gt; r['Adam', 'Lisa', 'Bart']对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。对应上面的问题，取前3个元素，用一行代码就可以完成切片：&gt;&gt;&gt; L[0:3]['Adam', 'Lisa', 'Bart']L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。如果第一个索引是0，还可以省略：&gt;&gt;&gt; L[:3]['Adam', 'Lisa', 'Bart']也可以从索引1开始，取出2个元素出来：&gt;&gt;&gt; L[1:3]['Lisa', 'Bart']只用一个 : ，表示从头到尾：&gt;&gt;&gt; L[:]['Adam', 'Lisa', 'Bart', 'Paul']因此，L[:]实际上复制出了一个新list。切片操作还可以指定第三个参数：&gt;&gt;&gt; L[::2]['Adam', 'Bart']第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。倒序切片对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; L[-2:]['Bart', 'Paul']&gt;&gt;&gt; L[:-2]['Adam', 'Lisa']&gt;&gt;&gt; L[-3:-1]['Lisa', 'Bart']&gt;&gt;&gt; L[-4:-1:2]['Adam', 'Bart']记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。对字符串切片字符串 ‘xxx’和 Unicode字符串 u’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串：&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[-3:]'EFG'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG'在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们成为迭代（Iteration）。在Python中，迭代是通过 for … in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码：for (i=0; i&lt;list.length; i++) {    n = list[i];}可以看出，Python的for循环抽象程度要高于Java的for循环。因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括：  有序集合：list，tuple，str和unicode；  无序集合：set  无序集合并且具有 key-value 对：dict而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。索引迭代Python中，迭代永远是取出元素本身，而非元素的索引。对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？方法是使用 enumerate() 函数：&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; for index, name in enumerate(L):...     print index, '-', name... 0 - Adam1 - Lisa2 - Bart3 - Paul使用 enumerate() 函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把：['Adam', 'Lisa', 'Bart', 'Paul']变成了类似：[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')]因此，迭代的每一个元素实际上是一个tuple：for t in enumerate(L):    index = t[0]    name = t[1]    print index, '-', name如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为：for index, name in enumerate(L):    print index, '-', name这样不但代码更简单，而且还少了两条赋值语句。可见，索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。迭代Dict的value我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。如果我们希望迭代 dict 对象的value，应该怎么做？dict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value：d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.values()# [85, 95, 59]for v in d.values():    print v# 85# 95# 59如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样：d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues():    print v# 85# 95# 59那这两个方法有何不同之处呢？      values() 方法实际上把一个 dict 转换成了包含 value 的list。        但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。        打印 itervalues() 发现它返回一个  对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。  如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。迭代Dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。首先，我们看看 dict 对象的 items() 方法返回的值：&gt;&gt;&gt; d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }&gt;&gt;&gt; print d.items()[('Lisa', 85), ('Adam', 95), ('Bart', 59)]可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value：&gt;&gt;&gt; for key, value in d.items():...     print key, ':', value... Lisa : 85Adam : 95Bart : 59和 values() 有一个 itervalues() 类似， items() 也有一个对应的 iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。列表列表生成要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)：&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):...    L.append(x * x)... &gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list：&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。写列表生成式时，把要生成的元素 x * x 放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。复杂表达式使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。假设有如下的dict：d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格：tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'print '\n'.join(tds)print '&lt;/table&gt;'注：字符串可以通过 % 进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list 拼接成一个字符串。把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了：&lt;table border="1"&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;            Name      Score                  Lisa      85              Adam      95              Bart      59      条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如：&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100]如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选：&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。多层表达式for循环可以嵌套，因此，在列表生成式中，也可以用多层 for 循环来生成列表。对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列：&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']翻译成循环代码就像下面这样：L = []for m in 'ABC':    for n in '123':        L.append(m + n)]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> python </tag>
        
          <tag> 读书笔记 </tag>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[什么是iOS的安全模式]]></title>
      <url>/blog/ios-security-pattern/</url>
      <content type="text"><![CDATA[作为iOS开发，作品App肯定需要提交到App Store审核。平心而论，App Store确实成功地将许多恶意软件拒之门外。但是，对开发者而言，应用程序的审核流程是令人沮丧的黑箱操作。当然，什么是恶意程序是由Apple来定义。因为App Store的存在，所以，如果想要实现某些特定的功能，唯一的手段就是将设备越狱或者骗过App Store的审查。官方的App审查永远无法抓到那些钻空子的恶意程序，所以需要另外一套高效的机制，来阻止恶意程序破坏整个操作系统的安全。安全启动当启动一台iOS设备时，系统首先会从只读的引导ROM中读取初始化指令，即系统引导程序。这个引导ROM包含Apple官方权威认证的公钥，它会验证底层启动加载器（LLB）的签名，一旦通过验证就启动它。然后验证第二级引导程序iBoot，iBoot启动后设备就可以进入恢复模式或启动内核。在iBoot验证完成内核签名的合法性之后，整个启动程序开始步入正轨：加载驱动程序、检测设备、启动系统守护进程。这个信任链确保所有的系统组件都由Apple写入、签名、分发，不能来自第三方机构，特别是那些恶意的攻击者以及企图越狱设备的黑客。App启动时也会用信任链去审查签名。所有的App都必须直接或间接由Apple签名。越狱工作的原理正是攻击这一信任链。越狱工具的作者需要找到这一信任链条上的漏洞，从而禁掉链条中负责验证的组件。破解引导ROM通常是最可取的方法，因为该组件不会因Apple今后的软件更新而改变。有关更多签名知识可以参看：《iOS App 签名的原理》沙盒机制App的沙盒机制是一种基于FreeBSD系统TrustedBSD框架的强制访问控制（MAC）机制，它采用一种类似于Lisp的配置语言来描述哪些资源系统可以访问，哪些禁止访问。这些资源主要包括文件、系统服务、网络连接、内存资源等。MAC机制不同于传统的访问控制机制（比如自主访问控制（DAC）），它不允许主体（比如用户进程）操作对象（文件、套接字等）。DAC最常见的形式就是UNIX系统上的用户、组和其它权限，所有这些都可以被授予读、写或执行的权限。在DAC系统中，用户如果拥有一个对象的所有权，也就拥有该对象的修改权限。MAC在沙盒中意味着App被关进了一个虚拟的容器。该容器遵循一系列的特定规则，即哪些系统资源可以访问。在文件访问方面，一般只能访问App的包目录；App可以读写存储在该位置的文件。Android的访问控制机制与MAC不同。Android实现了一个更加传统的DAC模型，App都有自己的用户ID和属于该ID的文件夹，其权限管理严格按照传统的UNIX文件权限管理运作。虽然这两项机制工作起来都没有问题，但MAC的扩展性总体来说还是更强一些。比如，除了App目录隔离，MAC机制还可以限制网络访问或系统守护进程的操作。数据保护和全盘加密数据保护和全盘加密两机制可以实现远程抹除设备数据，在设备丢失的情况下保护用户数据免于泄漏。文件系统加密并不能防止从一个正在运行的设备上窃取数据的行为。如果一个App可以从磁盘中读取一个文件，那文件系统加密并没有任何用武之处，因为内核对于任何尝试读取这些文件的进程都是透明解密的。换句话说，相比那些读取文件的调用行为，文件系统加密工作都是更底层。一旦攻破者攻破了系统验证，那就能无障碍地读取任意文件。全盘加密对于以下两个安全特性是必要的：安全删除文件、远程设备擦出。iOS中使用的加密密钥是分层级的，只需要简单丢弃一个加密密钥就能彻底销毁整层的数据，甚至是销毁整个文件系统。加密密钥的层级iOS文件系统中用于数据加密的密钥是分等级的，即用密钥来加密其它密钥，这样Apple就能更精确的控制数据什么时候可用。文件密钥（File Key）针对每个文件独立生成，存储在文件的元数据中。层级密钥（Class Key）为数据提供不同级别的保护。文件系统密钥（Filesystem Key）是一种全局加密密钥，当元数据被层级密钥加密后，使用文件系统密钥来加密涉及文件安全的元数据。设备密钥（Device Key）通常被称为UID密钥，每台设备唯一，只能通过硬件的AES引擎访问，操作系统无法直接获取。它是系统的主密钥，用来加密文件系统密钥和层级密钥。用户密码（User Passcode），可与设备密钥结合起来加密层级密钥。一旦设置密码，这个密钥等级也允许开发者自己决定本地存储的数据该如何保护，包括在设备锁定时是否能被访问、数据能否备份到其它设备等。ASLR和XN及其它机制iOS用两套标准机制来预防代码执行攻击：地址空间结构随机化（ASLR）和XN bit（eXecute Never，标记该段内存区域不包含可执行代码）。每次执行程序时，ASLR都会随机分配程序、数据、堆和栈的内存位置。而共享库的内存地址只在每次系统重启时随机设置，因为共享库需要在多个进程中使用。ALSR机制可以预防缓存区移除攻击（return-to-libc），因为函数和库的内存地址随机，而这种攻击依赖于基本库和函数的已知地址。XN bit，一般对应非ARM平台的NX（No-eXecute）bit，允许操作系统将某段内存标记为不可执行，这由CPU来控制。在iOS中，这个机制默认应用在程序的栈和堆上。每个程序都有一段可写可执行的内存，但是它必须是经过Apple官方签名授权系统的签名。Safari浏览器中的JavaScript即时（JIT, Just-in-time）编译器会用到这段内存。而WebView并不具备JIT功能，这样虽然可以避免代码执行攻击，但是也使得iOS平台上的Chrome无法做到像Safari那样好用。越狱检测越狱的本质就是通过一系列步骤来禁掉签名机制，从而允许设备运行未经Apple官方审核的应用。黑箱测试应用程序是越狱的重要能力。其实，越狱不一定要禁掉iOS的沙盒机制，它只是允许你在沙盒外安装App。安装在移动用户主目录下的App（即通过App Store安装）仍然受到沙盒限制。第三方的App需要安装在越狱设备中权限更高的/Applications目录下，与Apple股票应用安装在一起。动态修复一般来说，如果一段原生代码没有经过Apple发布的密钥签名认证，App则无法运行它。如果Apple的签名验证逻辑中存在bug或漏洞，可能会允许下载和执行原生代码。iOS有一个特性，可以让程序分配一段没有NX保护的内存区块（该内存区块可读、可写，甚至可执行），里面运行的代码也不需要经过签名认证。这个机制在Safari上的JIT编译器上使用。这个运用场景中，就可能会产生漏洞，业界著名的例子就是Charlie Miller。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> 安全 </tag>
        
          <tag> 读书笔记 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[聊一聊iOS的那些生命周期]]></title>
      <url>/blog/ios-lifecycle/</url>
      <content type="text"><![CDATA[iOS应用程序的生命周期，还有程序是运行在前台还是后台，应用程序各个状态的变换，这些对于开发者来说都是很重要的。iOS系统的资源是有限的，应用程序在前台和在后台的状态是不一样的。在后台时，程序会受到系统的很多限制，这样可以提高电池的使用和用户体验。本文所要说到的生命周期，也不仅仅只是应用生命周期；还包括，视图生命周期。应用生命周期iOS的应用程序一共有5种状态:  Not Running(非运行状态)应用没有运行或被系统终止。  Inactive(前台非活动状态)应用正在进入前台状态，但是还不能接受事件处理。  Active(前台活动状态)应用进入前台状态，能接受事件处理。  Background(后台状态)应用进入后台后，依然能够执行代码。如果有可执行的代码，就会执行代码，如果没有可执行的代码或者将可执行的代码执行完毕，应用会马上进入挂起状态。有的程序经过特殊的请求后可以长期处于Backgroud状态。  Suspended(挂起状态)处于挂起的应用进入一种“冷冻”状态,不能执行代码。如果系统内存不够,系统就把挂起的程序清除掉，为前台程序提供更多的内存，应用会被终止。作为应用程序的委托对象，AppDelegate 类在应用生命周期的不同阶段会回调不同的方法。首先，让我们先了解一下 iOS 应用的不同状态及它们彼此间的关系，如下图所示 ：在应用状态跃迁的过程中，iOS 系统会回调AppDelegate中的一些方法，并且发送一些通知。实际上，在应用的生命周期中用到的方法和通知很多，我们选取了几个主要的方法和通知进行详细介绍，具体如下表所述：为了便于观察应用程序的运行状态，为AppDelegate.m中的方法添加一些日志输出，具体代码如下：@implementation AppDelegate   - (BOOL)application:(UIApplication *)application     didFinishLaunchingWithOptions:(NSDictionary *)launchOptions{    NSLog(@"%@", @"application:didFinishLaunchingWithOptions:");     return YES;}- (void)applicationWillResignActive:(UIApplication *)application{        NSLog(@"%@", @"applicationWillResignActive:");}- (void)applicationDidEnterBackground:(UIApplication *)application{        NSLog(@"%@", @"applicationDidEnterBackground:");}- (void)applicationWillEnterForeground:(UIApplication *)application{        NSLog(@"%@", @"applicationWillEnterForeground:");}- (void)applicationDidBecomeActive:(UIApplication *)application{        NSLog(@"%@", @"applicationDidBecomeActive:");}- (void)applicationWillTerminate:(UIApplication *)application{        NSLog(@"%@", @"applicationWillTerminate:");}@end为了让大家更直观地了解各状态与其相应的方法、通知间的关系，下面以几个应用场景为切入点进行系统的分析。（一）非运行状态——应用启动场景场景描述：用户点击应用图标的时候，可能是第一次启动这个应用，也可能是应用终止后再次启动。该场景的状态跃迁过程见下图，共经历两个阶段3个状态：Not running →Inactive→Active。  1)在Not running→Inactive 阶段。调用application:didFinishLaunchingWithOptions:方法，发出UIApplicationDidFinishLaunchingNotification 通知。  2)在Inactive →Active 阶段。调用 applicationDidBecomeActive: 方法，发出UIApplicationDidBecomeActiveNotification 通知。（二）点击Home键——应用退出场景场景描述：应用处于运行状态（即Active状态）时，点击Home键或者有其他的应用导致当前应用中断。该场景的状态跃迁过程可以分成两种情况：可以在后台运行或者挂起，不可以在后台运行或者挂起。根据产品属性文件（如HelloWorld-Info.plist）中的相关属性Application does not run in background 是与否可以控制这两种状态。如果采用文本编辑器打开HelloWorldInfo.plist文件该设置项对应的键是UIApplicationExitsOnSuspend。　状态跃迁的第一种情况：应用可以在后台运行或者挂起，该场景的状态跃迁过程见下图 ，共经历3 个阶段4个状态：Active → Inactive → Background→Suspended。  1)在Active→Inactive 阶段。调用 applicationWillResignActive:方法，发出UIApplicationWillResignActiveNotification 通知。  2)在Inactive →Background阶段。应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。  3)在Background→Suspended 阶段。调用applicationDidEnterBackground:方法，发出UIApplicationDidEnterBackgroundNotification 通知。状态跃迁的第二种情况：应用不可以在后台运行或者挂起，其状态跃迁情况见下图 ，共经历4个阶段5 个状态：Active  → Inactive  → Background→Suspended→Not running 。  1)在Active →Inactivd 阶段。应用由活动状态转为非活动状态（不涉及我们要重点说明的方法和通知）。  2)在Inactive →Background阶段。应用从非活动状态进入到后台（不涉及我们要重点说明的方法和通知）。  3)在Background→Suspended 阶段。调用applicationDidEnterBackground:方法， 发出UIApplicationDidEnterBackgroundNotification 通知。  4)在Suspended →Not running阶段。调用applicationWillTerminate:方法，发出UIApplicationWillTerminateNotification通知。iOS 在iOS 4之前不支持多任务，点击Home键时，应用会退出并中断；而在iOS 4之后（包括iOS 4），操作系统能够支持多任务处理，点击Home键应用会进入后台但不会中断（内存不够的情况除外）。应用在后台也可以进行部分处理工作，处理完成则进入挂起状态。（三）挂起重新运行场景场景描述：挂起状态的应用重新运行。该场景的状态跃迁过程如下图所示，共经历3 个阶段4 个状态：Suspended  → Background  → Inactive  → Active 。  1)Suspended→Background阶段。应用从挂起状态进入后台（不涉及我们讲述的这几个方法和通知）。  2)Background→Inactive 阶段。调用applicationWillEnterForeground: 方法，发出UIApplicationWillEnterForegroundNotification通知。  3)Inactive →Active 阶段。调用applicationDidBecomeActive:方法，发出UIApplicationDidBecomeActiveNotification 通知。（四）内存清除——应用终止场景场景描述：应用在后台处理完成时进入挂起状态（这是一种休眠状态），如果这时发出低内存警告，为了满足其他应用对内存的需要，该应用就会被清除内存从而终止运行，该场景的状态跃迁见下图 。内存清除的时候应用终止运行。内存清除有两种情况，可能是系统强制清除内存，也可能是由使用者从任务栏中手动清除（即删掉应用）。内存清除后如果应用再次运行，上一次的运行状态不会被保存，相当于应用第一次运行。在内存清除场景下，应用不会调用任何方法，也不会发出任何通知。视图生命周期视图是应用的一个重要组成部分，功能的实现与其息息相关，而视图控制器控制着视图，其重要性在整个应用中不言而喻。视图生命周期与视图控制器关系以视图的4 种状态为基础，我们来系统了解一下视图控制器的生命周期。在视图不同的生命周期中，视图控制器会回调不同的方法，具体如下图所示。在视图控制器已被实例化，视图被加载到内存中时调用viewDidLoad方法，这个时候视图并未出现。在该方法中，通常进行的是对所控制的视图进行初始化处理。视图可见前后会调用viewWillAppear:方法和viewDidAppear: 方法；视图不可见前后会调用viewWillDisappear: 方法和viewDidDisappear:方法。4个方法调用父类相应的方法以实现其功能，编码时该方法的位置可根据实际情况做以调整，参见如下代码：-(void)viewWillAppear:(BOOL)animated{    [super viewWillAppear:YES];    //something code}viewDidLoad 方法在应用运行的时候只调用一次，而这上述4 个方法可以被反复调用多次，它们的使用很广泛但同时也具有很强的技巧性。例如，有的应用会使用重力加速计，重力加速计会不断轮询设备以实时获得设备在z 轴、x 轴和y轴方向的重力加速度。不断的轮询必然会耗费大量电能进而影响电池使用寿命，我们通过利用这4个方法适时地打开或者关闭重力加速计来达到节约电能的目的。怎么使用这4 个方法才能做到“适时”是一个值得思考的问题。在低内存情况下，iOS 会调用didReceiveMemoryWarning: 和viewDidUnload:方法。在iOS 6 之后，就不再使用viewDidUnload:，而仅支持didReceiveMemoryWarning：。didReceiveMemoryWarning: 方法的主要职能是释放内存，包括视图控制器中的一些成员变量和视图的释放。现举例如下：- (void)didReceiveMemoryWarning {    self.button = nil;    self.myStringD = nil;     [myStringC release];    //ARC内存管理情况下不用    [super didReceiveMemoryWarning];}除了上述5 个方法视图控制器外，还有很多其他方法。iOS  UI 状态保持和恢复iOS 设计规范中要求，当应用退出的时候（包括被终止运行的时候），需要保持界面中UI元素的状态，当再次进来的时候看到的状态与退出时是一样的。在iOS 之后，苹果提供以下API使得UI状态保持和恢复变得很容易。在iOS 中，我们可以在以下3种地方实现状态保持和恢复：      应用程序委托对象        视图控制器        自定义视图  恢复标识是iOS为了实现UI状态保持和恢复添加的设置项目。我们还需要在应用程序委托对象AppDelegate代码部分做一些修改，添加的代码如下：-(BOOL) application:(UIApplication *)application shouldSaveApplicationState:(NSCoder *)coder{    return YES;}  -(BOOL) application:(UIApplication *)application shouldRestoreApplicationState:(NSCoder *)coder{    return YES;}  - (void)application:(UIApplication *)application willEncodeRestorableStateWithCoder:(NSCoder *)coder{    [coder encodeFloat:2.0 forKey:@"Version"];}  - (void)application:(UIApplication *)application didDecodeRestorableStateWithCoder:(NSCoder *)coder{    float lastVer = [coder decodeFloatForKey:@"Version"];    NSLog(@"lastVer = %f",lastVer);}其中application:shouldSaveApplicationState:方法在应用退出时调用，负责控制是否允许保存状态，返回YES 情况是可以保存，NO是不保存。application:shouldRestoreApplicationState:方法在应用启动时调用，负责控制是否恢复上次退出时的状态，返回YES 表示可以恢复，返回NO表示不可以恢复。application:willEncodeRestorableStateWithCoder:方法在保存时调用，在这个方法中实现UI状态或数据的保存，其中[coder encodeFloat:2.0 forKey:@"Version"] 语句是保存简单数据。application:didDecodeRestorableStateWithCoder:方法在恢复时调用，在这个方法中实现UI状态或数据的恢复，其中[coder decodeFloatForKey:@"Version"] 语句用于恢复上次保存的数据。想要实现具体界面中控件的保持和恢复，还需要在它的视图控制器中添加一些代码。我们在ViewController.m中添加的代码如下：-(void)encodeRestorableStateWithCoder:(NSCoder *)coder{    [super encodeRestorableStateWithCoder:coder];    [coder encodeObject:self.txtField.text forKey:kSaveKey];}  -(void)decodeRestorableStateWithCoder:(NSCoder *)coder{    [super decodeRestorableStateWithCoder:coder];    self.txtField.text = [coder decodeObjectForKey:kSaveKey];}在iOS 6之后，视图控制器都添加了两个方法——encodeRestorableStateWithCoder: 和decodeRestorableStateWithCoder: ，用来实现该控制器中的控件或数据的保存和恢复。其中encodeRestorableStateWithCoder:方法在保存时候调用，[coder encodeObject:self. txtField.textforKey:kSaveKey]语句是按照指定的键保存文本框的内容。decodeRestorableStateWithCoder:方法在恢复时调用，[coder decodeObjectForKey:kSaveKey]在恢复文本框内容时调用，保存和恢复事实上就是向一个归档文件中编码和解码的过程。移除Main.storyboard每次使用Single View Application模板创建工程之后，总是会有一个Main.storyboard文件，那么，当我们使用代码布局的时候，很显然是不需要它的。那么，如何将它从工程中移除呢？只要进行如下几步即可。在工程配置中移除关联在TARGETS中，将Main InInterface选项中的值清空并保存设置。移除Main.storyboard中的关联文件选择storyboard文件。将类关联文件项清空并保存设置。移除Main.storyboard文件从工程中移除文件。在AppDelegate中添加代码- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // Override point for customization after application launch.       self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];        ViewController *viewController = [[ViewController alloc] init];    self.window.rootViewController = viewController;      self.window.backgroundColor = [UIColor purpleColor];　[self.window makeKeyAndVisible];       return YES;}完成以上几步，运行工程即可，顺利运行，没有出现任何error或waring。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
          <tag> application </tag>
        
          <tag> ui </tag>
        
          <tag> 生命周期 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[日语-发音]]></title>
      <url>/blog/japanese-pronounce/</url>
      <content type="text"><![CDATA[日语以东京音为标准音，其声调可以分为如下几种：0型，①型，②型，③型，④型，⑤型，⑥型和⑦型等。高声调表示重音，低声调表示轻音。0型：表示只有第一拍低，其它各拍都高。①型：表示只有第一拍高，以下其它各拍都低。②型：表示只有第二拍高，第一拍和以下其它各拍都低。③型：表示第二拍，第三拍高，第一拍和以下其它各拍都低。④型：表示第二拍，第三拍，第四拍高，第一拍和以下其它各拍都低。依此类推其它型。1 五十音图1.1 清音                   あ段      い段      う段      え段      お段                  　あ行 　      　あ　ア a　      　い　イ i　      　う　ウ u　      　え　エ e　      　お　オ　o              　か行 k　      　か　カ ka　      　き　キ ki　      　く　ク ku　      　け　ケ ke　      　こ　コ　ko              　さ行 s　      　さ　サ sa　      　し　シ shi　      　す　ス su　      　せ セ　se　      　そ　ソ so　              　た行 t　      　た タ　ta　      　ち　チ chi　      　つ ツ　tsu　      　て　テ　te      　と　ト to　              　な行 n　      　な　ナ na　      　に　ニ ni　      　ぬ ヌ　nu　      　ね ネ　ne　      　の　ノ no　              　は行 h　      　は ハ　ha　      　ひ　ヒ hi　      　ふ フ　fu　      　へ　ヘ　he      　ほ　ホ ho　              　ま行 m　      　ま　マ ma　      　み　ミ　mi      　む　ム mu　      　め　メ　me　      　も　モ　mo              　や行 y　      　や　ヤ ya　      　      　ゆ　ユ yu　      　      　よ　ヨ yo　              　ら行 r　      　ら　ラ ra　      　り　リ ri　      　る　ル ru　      　れ　レ re　      　ろ　ロ ro　              　わ行 w　      　わ　ワ wa　      　      　      　      　を　ヲ wo　              　      　ん　ン n　                                  1.2 拨音 (ん)            后续音节      实际发音      示例                  ぱ、ば、ま行      /m/      　さんぽ、しんぶん、うんめい、こんぶ、かんぶ　              た、だ、ら、な行      /n/      　ほんとう、もんだい、ほんらい、しんねん、こんど、すんな　              其它或词尾      /ng/      　へんか、あんしん、れんあい、まんが、バン、おんせん　      1.3 浊音            が行 g      　が　ガ ga　      　ぎ　ギ　gi      　ぐ　グ gu　      　げ　ゲ ge　      　ご　ゴ go　                  ざ行 z      　ざ　ザ za　      　じ　ジ zi　      　ず　ズ zu　      　ぜ　ゼ ze　      　ぞ　ゾ zo　              だ行 d      　だ　ダ da　      　ぢ　ヂ zi　      　づ　ヅ zu　      　で　デ de　      　ど　ド do　              ば行 b      　ば　バ ba　      　び　ビ bi　      　ぶ　ブ bu　      　べ　ベ be　      　ぼ　ボ bo　      1.4 半浊音            ぱ行 p      　ぱ pa　      　ぴ　pi      　ぷ pu　      　ぺpe　      　ぽ　po                         　パ　      　ピ      　プ　      　ペ　      　ポ      1.5 拗音拗音是在“い段”假名后面加上复元音“や”、“ゆ”、“よ”拼成的音节。拗音符号是把“や”、“ゆ”、“よ”写在“い段”假名的右下角。把拗音自动拉长一拍就是拗长音。            きゃ　キャ kya      きゅ　キュ kyu      きょ　キョ kyo                  しゃ　シャ sha      しゅ　シュ shu      しょ　ショ sho              ちゃ　チャ cha      ちゅ　チュ chu      ちょ　チョ cho              にゃ　ニャ nya      にゅ　ニュ nyu      にょ　ニョ nyo              ひゃ　ヒャ hya      ひゅ　ヒュ hyu      ひょ　ヒョ hyo              みゃ　ミャ mya      みゅ　ミュ myu      みょ　ミョ myo              りゃ　リャ rya      りゅ　リュ ryu      りょ　リョ ryo              ぎゃ　ギャ gya      ぎゅ　ギュ gyu      ぎょ　ギョ gyo              じゃ　ジャ ja      じゅ　ジュ ju      じょ　ジョ jo              ぢゃ　ヂャ dya      ぢゅ　ヂュ dyu      ぢょ　ヂョ dyo              びゃ　ビャ bya      びゅ　ビュ byu      びょ　ビョ byo              ぴゃ　ピャ pya      ぴゅ　ピュ pyu      ぴょ　ピョ pyo      注意：1）が行假名出现在单词首位置，发本音（浊音）；若出现在单词其他位置，发鼻浊音。2）か行和た行假名出现在单词首位置，发本音（清音）；若出现在其他位置，发近对应的浊音。3）ぱ行假名出现在单词首位置，发本音（半浊音）；若出现在其他位置，发ば行对应的音。2 促音发音时用发音器官某一部分堵住呼吸，形成一个短促的顿挫，然后放开堵塞使呼气急冲而出，这种音节叫“促音”，用小“つ”表示，即“っ”。            类型      示例                  促音+か行假名      かっこ、がっき、じっけん、せっけん、はっけん、みっか              促音+さ行假名      あっさり、けっせき、ざっし、じっせん、しっそ、ねっしん              促音+た行假名      ねったい、おっと、ずっと、ぜったい、はってん、まったく              促音+ぱ行假名      いっぱい、いっぺん、じっぴ、じっぷん、にっぽん、りっぱ      3 长音            长音规则      示例      特例                  あ段假名后加あ      おかあさん                     い段假名后加い      おにいさん                     う段假名后加う      ゆうじん                     え段假名后加い，个别场合加え      せんせい      おねえさん、ええ              お段假名后加う，个别场合加お      おとうさん      大きい、こお、とお              外来语用ー      メーデー             4 “何”发音4.1 なん１）だ、で、と（表内容时）、の假名前何だ、これ？これは何ですか。何と読みますか。これは何の本ですか。２）数量词前今日は何曜日ですか。4.2 なに１）に、を、が、か、も假名前何にしますか。何を食べますか。何か食べますか。何もありません。何がありますか。２）专用名词何学校（がっこう）ですか。5 教室用语  1）同学们早みなさん、おはようございます。  2）同学们上午（下午）好みなさん、こんにちは。  3）同学们晚上好みなさん、こんばんは。  4）请大声朗读大（だい）きな声（こえ）で読（よ）んでください。  5）再来一次もう一度（いちど）。  6）请大家写みなさん、書（か）いてください。  7）明白了吗？わかりましたか。  8）同学们再见みなさん、さようなら。  9）老师再见先生（せんせい）、さようなら。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 日语 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[sublime text 实用技巧]]></title>
      <url>/blog/sublime-text-tool/</url>
      <content type="text"><![CDATA[Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。笔者整理了一些使用快捷方式，以及一些常用插件，分享一下。安装包控制（Package Control）打开Sublime Text 2，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；将以下代码复制粘贴进命令行后回车：import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read())重新启动Sublime Text 2，如果在Preferences → Package Settings 中看到 Package Control 这一项，就说明安装成功。安装Alignment插件对于喜欢整齐的码农来说，这不失为一个省事的插件。该插件可以通过上面安装好的 Package Control 来安装：按ctrl + shift + P调出命令面板；输入 install 调出 Package Control：Install Package 选项，并回车；输入Alignment，选中并按回车安装；重启Sublime Text 2，选中文本并按ctrl + alt + a 就可以进行对齐操作了。安装 Soda 主题这里的主题不同于针对代码的 color scheme，而是针对Sublime Text 2该软件本身的主题，该主题也可以通过万能的 Package Control 来安装。按ctrl + shift + P调出命令面板；输入 install 调出 Package Control：Install Package 选项，并回车；输入 theme soda 选中后回车即可安装；安装完之后要激活主题，打开 Preferences → Global Settings – User，加上以下代码保存即可生效："theme": "Soda Light.sublime-theme" 或者 "theme" : "Soda Dark.sublime-theme"安装cTags插件首先，从Ctags官网下载压缩包下来，解压到电脑的某个地方，比如“C:\Program Files\ctags”，然后把cTags添加到系统变量里去：在“我的电脑”右键属性 → 高级 → 环境变量 → 在“系统变量”里找到“Path”，点击“编辑” → 把“;C:\Program Files\ctags”（不包括双引号）复制到最后 → 最后一路“确定”保存。然后通过 Package Control 来安装 cTags 插件：按ctrl + shift + P调出命令面板；输入 install 调出 Package Control：Install Package 选项，并回车；输入 ctags 选中后回车即可安装。安装完之后，在项目的当前目录下按ctrl + t, ctrl + r，会生成.tags的文件。当光标停留在某个函数上时，按快捷键 ctrl+t, ctrl+t就可以打开函数所在的文件，并跳转到相应的位置了。PS 安装这个插件折腾了我蛮久，主要是不知道还要从ctags官网下载压缩包，以及修改系统的变量，后来还是一博友给我发的国外的参考资料才知道要这样配置 的。刚开始知道这软件之所以没用是因为没有像eclipse可以追踪函数的功能，后来才知道可以通过安装cTags插件来实现。装上此功能后，就更喜欢用 Sublime Text 2了。jsFormat插件格式化js：选中一段文本，control+alt+f。DocBlockr在JS函数上方输入/**，然后回车，doc就生成好了非常好用。sublime-jslint打开一个js文件，control+j，即可输出jsLint检查的结果。打开Packages目录，找到插件目录sublime-jslint，打开 sublime-jslint.sublime-settings文件，可以修改jsLint配置，还可以配置文件保存时自动检查等，如：{ // Path to the jslint jar. // Leave blank to use bundled jar. "jslint_jar": "",   // Options pass to jslint. // Jerry Qu注：全部可用配置参考这里，https://github.com/fbzhong/sublime-jslint/wiki/Available- jslint4java-options "jslint_options": "--encoding utf-8 --bitwise --browser --cap --css --devel --debug --evil --forin --fragment --on --sub --white --windows --sloppy",   // Ignore errors, regex. "ignore_errors": [ // "Expected an identifier and instead saw 'undefined' \(a reserved word\)" ],   // run jslint on save. "run_on_save": false,   // debug flag. "debug":false }SideBarEnhancements推荐通过 Package Control 安装 SideBarEnhancements 这个插件，可以大大加强在侧栏目录树中右键的选项推荐插件：1）Zen Coding2）jQuery Package for sublime Text3）Clipboard History4）Bracket Highlighter5）GBK to UTF86）Git常用快捷键            按键组合      作用                  Command+Shift+L      选中多行即可可以同时编辑这些行              control + Command +G      可以一次性选择全部相同的文件进行同时编辑              Ctrl+D      选词（反复按快捷键，即可继续向下同时选中下一个相同的文本进行同时编辑）              Ctrl+G      跳转到相应的行              Ctrl+J      合并行（已选择需要合并的多行时）              Ctrl+L      选择整行（按住-继续选择下行）              Ctrl+M      光标移动至括号内开始或结束的位置              Ctrl+T      词互换              Ctrl+U      软撤销              Ctrl+P      查找当前项目中的文件和快速搜索；输入@查找文件主标题/函数；或者输入:跳转到文件某行；              Ctrl+R      快速列出/跳转到某个函数              Ctrl+KBackspace      从光标处删除至行首              Ctrl+KB      开启/关闭侧边栏              Ctrl+KK      从光标处删除至行尾              Ctrl+KT      折叠属性              Ctrl+KU      改为大写              Ctrl+KL      改为小写              Ctrl+K0      展开所有              Ctrl+Enter      插入行后（快速换行）              Ctrl+Tab      当前窗口中的标签页切换              Ctrl+Shift+A      选择光标位置父标签对儿              Ctrl+Shift+D      复制光标所在整行，插入在该行之前              ctrl+shift+F      在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找              Ctrl+Shift+K      删除整行              Ctrl+Shift+L      鼠标选中多行（按下快捷键），即可同时编辑这些行              Ctrl+Shift+M      选择括号内的内容（按住-继续选择父括号）              Ctrl+Shift+P      打开命令面板              Ctrl+Shift+/      注释已选择内容              Ctrl+Shift+↑      可以移动此行代码，与上行互换              Ctrl+Shift+↓      可以移动此行代码，与下行互换              Ctrl+Shift+[      折叠代码              Ctrl+Shift+]      展开代码              Ctrl+Shift+Enter      光标前插入行              Ctrl+PageDown、Ctrl+PageUp      文件按开启的前后顺序切换              Ctrl+Z      撤销              Ctrl+Y      恢复撤销              Ctrl+F2      设置书签              Ctrl+/      注释整行（如已选择内容，同“Ctrl+Shift+/”效果）              Ctrl+鼠标左键      可以同时选择要编辑的多处文本              Shift+鼠标右键（或使用鼠标中键）      可以用鼠标进行竖向多行选择              Shift+F2      上一个书签              Shift+Tab      去除缩进              Alt+Shift+1~9（非小键盘）      屏幕显示相等数字的小窗口              Alt+.      闭合当前标签              Alt+F3      选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑              Tab      缩进,自动完成              F2      下一个书签              F6      检测语法错误              F9      行排序(按a-z)              F11      全屏模式      ]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[想说说文章版权]]></title>
      <url>/blog/article-copyright/</url>
      <content type="text"><![CDATA[文章版权，这个词汇以前笔者以前是不怎么有体会的，认为在当今互联网的时代，随便网上Google一下很多地方的文章如出一辙，而作者也是千奇百怪，甚至都不清楚谁才是作者。这篇文章，笔者是遇见了真实的事件，现在很想说一说，看看大家是否也是一样，认为一个版权意识高的视界里，资源与时间都是高效的。不用在看一条，两条都是一样的，浪费时间和资源。不知道是否有人明白什么叫“版权”。说实在的，笔者并不是很清楚它的定义。这里引入百科的解释：  版权（copyright）是用来表述创作者因其文学和艺术作品而享有的权利的一个法律用语。  版权是对计算机程序、文学著作、音乐作品、照片、电影等的复制权利的合法所有权。除非转让给另一方，版权通常被认为是属于作者的。大多数计算机程序不仅受到版权的保护，还受软件许可证的保护。版权只保护思想的表达形式，而不保护思想本身。算法、数学方法、技术或机器的设计均不在版权的保护之列。这个是属于法律领域了，只不过在天朝，大家都不认为这是事儿。不过现在好了，慢慢的付费阅读，付费视频等等开始流行，这样大家虽然花了米米，不过质量却是有了保证。说回这篇文章的初衷，就是在这两天，笔者遇到了自己博客网站的文章别他人拿去分享，并攫取了利益。更巧的是，被笔者知道了。曾经在知乎一个问答里看见，关于招聘，面试官会直接pass掉那些抄袭他们文章的应聘者。看到之后笔者将自己转载，并备注了“转载”二字的文章删除干净。不错，或许笔者没有从中获利，不过确实有些文章是没有联系到作者的，虽然给了原链接，可是确实吸引了眼球。现在，保证文章都是原创，无论深浅文雅如何，总归是自己的作品。相反，在不断撰写过程中，会发现很多自身的漏洞。网络已经很发达了，大家都能在网上找到自己需要的文章，干嘛还要做搬运工呢，笔者认为，高手应该转载于无形，即看懂原文加上自己的思考，想必比简单的复制拷贝要有价值得多。笔者之前在一个“同行说”的平台分享自己的文章，后来转行了，渐渐时间少了，也就远离了一段时间的撰文。现在，又要安利大家了，这款 开发者头条，内容不错，文章也很是有质量，笔者使用pocket已经收藏了不少好文。不过，这篇文章的始因也是源于此平台。平台有激励作者自荐的机制，积分商城应该算得上为数不多的几家良心公司。为此，笔者有空会创作原创，因为这样才能登上文章精选的列表。可是，不得不说的一点是，平台没有很好的原创保护机制。笔者作为一个技术人员。看到几点问题：1.平台有精选文章缓存。这样的后果就是，即使作者发现了自己文章的错误，修改之后还是不能同步到精选文章列表。2.对于原创和非原创没有好的保护与甄别，除非巧合遇到像笔者这样的情况，且还是个较真的人。3.软件聊天体验有待提高。emoji发送太麻烦，iOS平台必须依赖系统键盘的发送。Android端没有用过不清楚。第一个问题，笔者建议可以使用定时机制，一段时间检测分享链接的内容，这样也能很好的保护原创。当原创作者发现自己的文章被他人肆意分享，只需改变文章地址即可令其失效。这样也就不存在原创甄别问题了。还保证了文章内容的同步。第二个问题，技术不是问题，关键是否会为这个的细节付出时间。不过，笔者自己也想过使用什么方式能够避免这样的问题，URL混淆？反爬虫？不知道是否可行。不过迫于无奈，现在笔者的文章顶部都加了一条申明。其实就是小偷和锁的问题，是否有效只取决于剽窃者。最后，很感谢平台的及时沟通和处理，为笔者补回了损失。不过，却便宜了剽窃者。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS的那些面试]]></title>
      <url>/blog/ios-interview/</url>
      <content type="text"><![CDATA[笔试面试是程序员应聘绕不过的坎，想进大厂就一定要有知识储备量，而这个却是最佳的考察方式。笔者分享一些收集的iOS面试题，答案仅供参考，如有错误，还请指正。第一部分1.Objective-C语言的基本特点？Objective-C语言是C语言的一个超集，只是在C的基础之上添加了面向对象（OO）的特性；Objective-C与Java语言相同都是单继承，这一点与C++语言不同（多重继承），这一点可以参看之前有关讲解继承的文章；Objective-C不支持命名空间，取而代之的是在类名之前添加前缀，以此来区分。2.#include与#import的区别，#import与@class的区别？1）#include和#import效果相同，只是后者不会引起交叉编译，确保头文件只会被导入一次。2）#import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。使用#import编译效率高，防止相互包含的编译错误。3.简述类目优缺点，如果覆盖本类或者父类的方法会出现什么问题？优点：不需要通过增加子类而增加现有类的行为（方法），且类目中的方法与原始类方法基本没有区别。缺点：无法向类目添加实例变量。覆盖原始类方法后，原始类的方法没办法调用。4.简述内存管理基本原则？如果使用alloc、copy（mutableCopy）或者retain一个对象时，你就有义务向它发送一条release或autorelease消息。其他方法创建的对象，不需要由你来管理内存。5.什么是ARC技术？与GC是否相同？ARC是Automatic Reference Counting的简称，我们称之为自动引用计数，是iOS5.0之后推出的内存管理的新特性。本质上还是使用引用计数来管理对象，只是我们在编写代码时，不需要向对象发送release或autorelease方法，也不可以调用dealloc方法，编译器会在合适的位置自动给用户生成release（autorelease）消息。GC是Garbage Collection，内存垃圾回收机制，ARC比GC性能好。6.iOS中是否支持垃圾回收机制？iOS开发只支持MRC与ARC，Mac开发支持GC垃圾回收机制，10.8之后弃用了GC，推荐使用ARC。7.深、浅复制的基本概念以及区别？浅复制：只复制对象本身，不对里面的属性复制。深复制：不仅复制对象本身，对象持有的属性对象也做复制。8.内存中的堆区和栈区的差别？栈区（stack）由编译器自动分配释放，存放方法（函数）的参数值，局部变量的值等。堆区（heap）一般由程序员分配与释放，若程序员不释放，则会内存溢出。9.用户自定义了一个对象，如何实现拷贝（可变和不可变拷贝）？必须实现copying和mutableCopying协议，表示返回一个不可变和可变的对象。否则，程序将会出现异常。-(id)copyWithZone:(NSZone *)zone {	Person *person = [[self Class] allocWithZone:zone];	person-&gt;age = self.age;	person-&gt;name = self.name;	return person;}-(id)mutableCopyWithZone:(NSZone *)zone;10.定义属性时，什么时候用assign、retain、copy和nonatomic？assign：普通赋值，一般常用于基本数据类型，常见委托设计模式，以此来防止循环引用。retain：保留计数，获得了对象的所有权。引用计数在原有基础上加1。copy：用来复制对象，一般字符串使用，Foundation中的不可变对象使用，效果相当于retain，只是引用计数加1。nonatomic：非原子性访问，不加同步，多线程并发访问会提高性能。11.strong和weak，_unsafe_unretained与weak的区别？strong：强引用，在ARC中告诉编译器帮助我们自动插入retain。weak：弱引用，是普通赋值，相当于手动管理内存的assign。_unsafe_unretained：与weak功能一致，区别在于当指向的对象销毁后，weak会将变量置为nil，防止调用野指针。12.ARC存在内存泄露吗？ARC中如果内存管理不当的话，同样会存在内存泄露。例如，ARC中也会循环引用导致内存泄露；Objective-C对象与CoreFoundation类之间桥接时，管理不当也会产生内存泄露。13.当我们释放对象时，为什么需要调用[super dealloc]方法？子类是继承自父类，那么子类中有一些实例变量（对象），是继承自父类的，因此，我们需要调用父类方法，将父类所拥有的实例进行释放。14.自动释放池是什么，如何工作？自动释放池是NSAutorelease类的一个实例，当向一个对象发送autorelease消息时，该对象会自动入池，待池销毁时，将会向池中所有对象发送一条release消息，释放对象。15.为什么delegate（代理）属性都是assign而不是retain的？防止循环引用，以至对象无法得到正确的释放。16.delegate使用weak还是strong？为什么？苹果有delegate使用strong的类吗？为什么？delegate一般使用weak，主要是为了避免出现循环引用。苹果官方NSURLSession类中的delegate使用strong引用。因为苹果要求所有的网络请求都用同一个对象去发送，那么这个对象就封装为一个单例对象。第二部分1.iOS开发中数据持久性有哪几种？plist文件写入，对象归档，sqlite3数据库，CoreData。2.什么是KVC和KVO？它们之间的关系是什么？KVC：键值编码，是一种间接访问对象实例变量的机制，该机制可以不通过存取方法就可以访问对象的实例变量。KVO：键值观察，是一种能使得对象获取到其他对象属性变化的通知机制。实现KVO键值观察模式，被观察的对象必须使用KVC键值编码来修改它的实例变量，这样才能被观察者观察到。因此，KVC是KVO的基础或者说KVO的实现是建立在KVC的基础之上的。3.简述常见的设计模式？单例模式、代理设计、观察者（通知）、工厂方法、模板方法。4.内存管理在dealloc方法中用release方法与self.xx=nil哪个好？使用self.xx=nil更好，因为先调用了release方法，而且还将变量设置为nil，这样就更安全的释放对象，防止野指针调用。5.线程与进程的区别和联系？一般的应用程序是单个进程，也有多进程（Chrome），进程是个静态的容器，里面容纳了很多个线程，线程是一系列方法的线性执行路径。6.Objective-C语言的优缺点？优点：类目、动态识别、支持C语言、Objective-C与C++可以混编。缺点：不支持命名空间、不支持运算符重载、不支持多重继承。7.代理delegate、通知Notification与block的使用区别？delegate和block一般是用于两个对象一对一之间的通信交互，delegate需要定义协议方法，代理对象实现协议方法，并且需要建立代理关系才可以实现通信。block更加简洁，不需要定义繁琐的协议方法，但是如果通信事件比较多的话，建议使用delegate。Notification主要用于一对多情况下通信，而且，通信对象之间不需要建立关系，但是使用通知，代码可读性差。8.控制器ViewController的loadView、viewDidLoad、viewWillApear和viewDidUnload分别是在什么时候调用？loadView：当控制器的根视图view为空，且此view被访问时调用。viewDidLoad：loadView调用之后被调用。viewWillApear：当控制器根视图view被添加到父视图上时调用。viewDidUnload：iOS6.0之前，当内存警告时，先卸载视图，再调用viewDidUnload来释放内存。9.@synthesize和@dynamic的区别？@synthesize：系统自动生成getter和setter属性声明。@dynamic：告诉编译器，属性的获取与赋值方法由用户自己实现，不自动生成。10.事件响应者链的概念？响应者链表示一系列的响应者对象。事件被交由第一响应者对象处理，如果第一响应者不处理，事件被沿着响应者链向上传递，交给下一个响应者。一般来说，第一响应者是个视图对象或者其子类对象，当其被触摸后事件交由它处理，如果它不处理，事件会被传递给它的视图控制器对象（如果存在），然后是它的父视图对象（如果存在），以此类推，直到顶层视图。接下来会沿着顶层视图到窗口（UIWindow对象），再到程序（UIApplication对象）。如果整个过程都没有响应这个事件，该事件被丢弃。一般情况下，在响应者链中只要有对象处理事件，事件就停止传递。但有时候可以在视图的响应方法中根据一些条件判断来决定是否需要继续传递事件。11.C语言中的static变量和static函数有什么作用？1）表示变量是静态存储变量，表示变量存放在静态存储区。2）加在函数前面的时候表示该函数是内部连接，只在本文件中有效，别的文件中不能使用该函数。12.指针题1）int a; //一个数值。2）int *a; //一个指向数值的指针。3）int **a; //一个指向指针的指针。4）int a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。5）int *a[10]; //一个有10个指针的数组，该指针是指向一个整型数的。6）int (*a)[10]; //一个指向有10个整型数数组的指针。7）int (*a)(int); //一个指向函数的指针，该函数有一个整型参数并返回一个整型数。8）int (*a[10])(int); //一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数。13.写一个NSString类的实现？+(id)initWithCString:(const char *)nullTerminatedCString encoding:(NSStringEncoding)encoding {	NSString *obj;	obj = [self allocWithZone:NSDefaultMallocZone()];	obj = [obj initWithCString:nullTerminatedCString encoding:encoding];	return autorelease(obj);}14.Objective-C与C如何混用？Objective-C与C++如何混用？实现文件的扩展名.m改成.mm即可，但cpp文件必须只能使用C/C++代码，而且cpp文件include的头文件中，也不能出现Objective-C的代码，因为cpp只能写C++的代码。15.Objective-C中有私有方法和私有变量吗？使用private修饰的全局变量是私有的变量。Objective-C在语法上没有设计私有的方法，不过可以通过延展在实现文件里定义方法作为私有的方法。但不是真正意义上的私有方法，也是可以调用的，只是外部不可见而已。第三部分1.下面关键字const有什么含义？const int a;int const a;const int *a;int * const a;前两个的作用是一样的，a是一个常整型数。第三个意味着a是一个指向常整型数的指针（即整型数是不可修改的，但指针可以）。第四个意味着a是一个指向整型数的常指针（即指针指向的整型数是可以修改的，但指针是不可修改的）。2.C语言中extern的作用，extern “C”的作用？1）extern可以置于变量或者函数前，以标示变量或函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。2）C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。3.Objective-C是如何管理内存的？Objective-C语言是使用引用计数来管理一个对象的生命周期，当对象被其他“人”使用的时候引用计数加1，不使用时减1，当此对象的引用计数为0时，则对象被系统回收。4.什么是动态绑定（多态）？动态绑定是面向对象特性之一多态的体现，声明一个变量，在运行的时候可以绑定不同的对象，比如在方法的参数中声明这样一个变量UIView *view，运行的时候，我们可以根据不同的应用场景给view变量传入不同的对象，可以传递一个UIButton对象，也可以传入UIImageView对象。5.如何理解delegate？delegate，又称为委托或代理，它是一种设计模式。delegate主要用于两个对象之间的通信交互，并且解除两个通信对象的耦合性，iOS中大量使用了delegate设计，主要用于视图与使用对象之间的通信交互。6.block与函数有何异同？block有何优点？1）block类似于C里面的函数指针，都可以作为参数进行传递，用于回调。但是block的实现可以定义在方法中，函数则不可以。2）block语法简洁，可以在方法中定义实现，这样可以访问方法中的局部变量，使代码更加的紧凑，结构化。7.为什么标准头文件都有类似以下的结构？#ifndef __INCvxWorksh#define __INCvxWorksh#ifdef __cplusplusextern "C" {#endif/*...*/#ifdef __cplusplus}#endif#endif /*__INCvxWorksh*/显然，头文件中的编译宏“#ifndef __INCvxWorksh、#define __INCvxWorksh、#endif”的作用是防止该头文件被重复引用。8.CocoaTouch框架？UIKit、Foundation、CoreGraphic、CoreAnimation1）音频和视频：Core Audio、OpenAL、Media Library、AV Foundation2）数据管理：Core Data、SQLite3）图形和动画：Core Animation、OpenGL ES、Quartz 2D、Core Graphic4）用户应用：Address Book、Core Location、Map Kit、Store Kit9.栈结构与队列的区别？栈（stack）：限定只能在表的一端进行插入和删除操作的线性表。队列（queue）：限定只能在表的一端插入和在另一端进行删除操作的线性表。1）队列先进先出，栈先进后出。2）对插入和删除操作的“限定”不同。3）遍历数据速度不同。队列遍历数据的速度要快得多。10.Objective-C中有无多重继承？如何实现多重继承？Objective-C是没有多重继承的。Cocoa中所有的类都是NSObject的子类，多继承在这里是用protocol委托代理来实现的。面向对象语言大部分都是单继承，例如：Java、C#。C++支持多继承。11.static全局变量与普通的全局变量的区别？局部变量呢？函数呢？1）static全局变量与普通全局变量的区别：static全局变量只初始化一次，防止在其他文件单元中被引用。2）static局部变量与普通局部变量的区别：static局部变量只被初始化一次，下一次依据上一次结果值。3）static函数与普通函数的区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。12.什么是类目与延展？类目：为已知的类增加新的方法。延展：通知在本类的定义里使用类目来声明私有方法。13.Objective-C中的协议和Java中的接口区别？协议定义的方法，可以设置可选实现和必须实现。接口则是必须全部实现。14.在一个对象的方法里self.name=”object”和name=”object”有什么不同？前者调用的是设置器方法，后者是普通赋值。15.单例设计模式的实现？为什么使用单例设计？static File *instance = nil;@implementation File//获取单例的方法+(id)shareInstance {	@synthesize (self) {		if(instance == nil) {			instance = [[File alloc] init];		}	}	return instance;}//覆写allocWithZone、copyWithZone、retain、release和autorelease方法，目的是限制这个类只创建一个对象为什么使用单例设计？1）单例设计是用来限制一个类只能创建一个对象，那么此对象中的属性可以存储全局共享的数据，所有的类都可以访问、设置此单例对象中的属性数据。2）如果一个类创建的时候非常的耗费性能，那么此类如果能满足要求，可以设置为单例节约性能。第四部分1.层CALayer和UIView的区别是什么？两者最大的区别是，图层不会直接渲染到屏幕上。UIView是iOS系统中界面元素的基础，所有的界面元素都是继承自它，它本身是由CoreAnimation来实现的，它真正绘图的部分是由一个CALayer类来管理的。UIView本身更像是一个CALayer的管理器。一个UIView上可以有多个CALayer，每个CALayer显示一种东西，增强UIView的展现能力。2.什么是GCD？GCD是Apple开发的一个多核编程的较新的解决方法。在Mac OS X 10.6雪豹中首次推出，并引入到iOS4.0。GCD是一个替代诸如NSThread等技术的很高效和强大的技术。GCD完全可以处理诸如数据锁定和资源泄漏等复杂的异步编程问题。3.TCP/UDP的区别和联系？1）TCP的全称为传输控制协议，这种协议可以提供面向连接的、可靠的、点到点的通信。2）UDP的全称为用户数据报协议，它可以提供非连接的不可靠的点到多点的通信。3）用TCP还是UDP，需要看程序注重哪一个方面，需要可靠还是快速。4.Socket连接和Http连接的区别？Http连接：Http连接就是所谓的短链接，即客户端向服务器发送一次请求，服务器响应后连接即会断掉。Socket连接：Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉。5.什么是TCP连接的三次握手？第一次握手：客户端发送SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认。第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。第三次握手：客户端接收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。6.frame和bounds的区别？frame指的是：该view在父view坐标系统中的位置大小（参照点是父视图的坐标系统）。bounds指的是：该view在本身坐标系统中的位置和大小（参照点是本身的坐标系统）。7.如何理解MVC设计模式？MVC是一种架构设计，M表示数据模型，V表示视图，C表示控制器。数据模型：负责存储、定义、操作数据。视图：用来展示数据给用户，和用户进行操作交互。控制器：它是M与V的协调者，控制器获取数据，将数据交给视图去展示。8.控制器的xib是怎么加载的？当UIViewController的loadView被调用时，在此方法中，通过NSBundle加载xib，先通过控制器的类名作为xib的文件名加载此xib文件。如果找到此xib文件，则加载为view对象作为控制器的根视图，如果没有xib文件，则通过alloc创建一个view对象作为根视图。9.控制器如何处理系统内存不足警告？内存不足时，系统会调用控制器didReceiveMemoryWaring方法通知控制器内存不足。iOS6.0与6.0之前的处理方式不一样。1）iOS6.0之前：调用didReceiveMemoryWaring后，将self.view设置为nil，并且再调用viewDidUnload方法，在此方法中我们应该释放子视图。2）iOS6.0之后：调用didReceiveMemoryWaring后，不再调用viewDidUnload方法，则应该在didReceiveMemoryWaring方法中手动将self.view=nil，并且释放子视图。10.iOS中对象间有哪些通信方式？代理delegate、block、通知和KVO。11.block在内存管理上的特点？需要注意循环引用，如何解决循环引用？1）block中使用了局部对象，则会将此对象retain，引用了当前对象的属性或者方法，则会将当前对象retain。2）解决循环引用：将当前对象赋值给一个局部变量，并且使用__block关键字修饰该局部变量，使用该变量访问当前对象的属性和方法。12.Objective-C中有线程池（线程队列）吗？NSOperationQueue是如何管理线程的？NSOperationQueue是Objective-C的线程池，线程池中可以存放多个线程。NSOperationQueue可以管理线程的并发数，还可以管理线程间的优先级。13.timer的间隔周期准吗？为什么？怎样实现一个精准的timer？定时器timer一般都是准确的，但是当主线程有些时候难免会出现堵塞情况，这样就有可能导致定时器timer会延迟从而不准确。我们可以开发一个多线程，在此多线程上运行定时器，这样多线程只运行定时器，不会因堵塞而导致误差。14.Http协议的特点？GET与POST的区别？什么是Https协议？1）Http协议是短链接，都是客户端主动发送请求，服务器做出响应，服务器响应之后，连接则断开。2）GET请求没有请求体，POST含有请求体，请求参数可以放入请求体中，所以，POST可以提交大量的数据给服务器，更加安全。3）HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层（SSL）进行信息交换，简单来说它是HTTP的安全版。15.XML数据的解析方式各有什么不同？JSON解析有哪些框架？XML数据解析有两种方式：DOM解析和SAX解析。DOM解析：必须完成DOM树的构造，在处理规模较大的XML文档时就很耗费内存，占用资源较多。SAX解析：与DOM不同的是，SAX是用事件驱动模型，解析XML文档时每遇到一个开始或者结束标签、属性或一条指令时，程序就产生一个事件来进行相应的处理。因此，SAX相对于DOM来说更适合操作大的XML文档。JSON解析：现在性能比较好的主要是第三方的JSONKit和iOS自带的JSON解析类，自带的JSON解析性能是最高的，但是只能是iOS5之后才可以使用。第五部分1.tableView是如何复用的？如果屏幕上能显示10个单元格，则tableView只会创建11个单元格，也就是n+1，当滑到第12个单元格时就会复用第1个单元格对象。tableView中有个单元格池的概念，tableView调用协议方法获取单元格时，先从池子中查找是否有可复用的单元格，如果有则复用，如果没有则创建一个单元格对象。2.如何优化tableView的滑动速度？1）复用单元格。2）使用不透明的视图，单元格中尽量少使用动画。3）图片加载使用异步加载，并且设置图片加载的并发数。4）滑动时不加载图片，停止滑动开始加载。5）文字、图片可直接drawInRect绘制。6）如非必要，减少reloadData全部cell，只reloadRowsAtIndexPaths。7）如果cell是动态行高度，计算出高度后缓存。8）cell高度固定的话直接用cell.rowHeight设置高度。3.谈谈对Runloop的理解？Run loops是线程相关的基础框架的一部分。一个run loop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。使用run loop的目的是让你的线程在有工作的时候忙于工作，而没有工作的时候处于休眠状态。4.如何调用drawRect方法与layoutSubView方法？这两个方法的作用？通过setNeedsLayout方法异步调用layoutSubView方法。通过setNeedsDisplay方法异步调用drawRect方法。drawRect方法用于绘图，layoutSubView方法用于布局子视图。5.UIView与UIViewController的关系？每个控制器都有一个根视图，控制器UIViewController用来管理此视图的加载和显示。6.iOS中有哪些手势？轻击、捏合、平移、轻扫、旋转和长按。7.Http和Socket的区别？Http是客户端用Http协议进行请求，发送请求时需要封装http请求头，并绑定请求的数据，服务器一般有Web服务器配合（当然也非绝对）。Http请求方式为客户端主动发起请求，服务器才能给响应，一次请求完毕后则断开连接，以节省资源。服务器不能主动给客户端响应（除非采用http长连接技术）。iPhone主要使用的类是NSURLConnection。Socket是客户端跟服务器直接使用Socket套接字进行连接，并没有规定连接后断开，所以客户端和服务器可以保持连接通道，双方都可以主动发送数据。一般在游戏开发或股票开发，这种要求即时性很强并且保持发送数据量比较大的场合使用。主要使用的类是CFSocketRef。8.storyboard有什么特点？storyboard是iOS5新增的特性，是对xib的升级版本，引入了一个容器用于管理多个xib文件，和它们之间的跳转交互。优点：不用再为每个控制器创建xib文件；可以使用静态cell，当cell固定且不多时，使用起来比较方便。缺点：storyboard单个文件，不利于团队协作开发。9.如何打包静态库？新建一个Framework&amp;Library的项目，编译的时候会将项目中的代码文件打包成一个.a静态库文件。10.APP发布的上架流程？1）在苹果官网的开发者中心，新建一个APP，填写此APP相关的一些描述信息。2）下载安装发布证书。3）选择发布证书，使用Archive编译发布包。4）使用Xcode提交发布包。11.iOS5有哪些新特性？iCloud、定制UI、storyboard、ARC、CoreImage滤镜、新增JSON解析类。12.iOS6有哪些新特性？UIRefreshControl水滴效果下拉刷新、UICollectionView控件的使用、SLComposeViewController新浪微博控件、PassKit中Passbook、AutoLayout自动布局。13、iOS7有哪些新特性？系统：全新的UI设计与交互；Control Center控制中心；全新的多任务Multitasking；AirDrop共享文件；全新的Safari浏览器交互式体验。SDK：动态UIKit，新增了UIDynamicItem委托，用来为UIView制定动态行为；新增游戏引擎Sprite Kit Framework框架，类似于Cocos2D。14.ARC有什么特点？ARC是编译器特性，iOS5.0新添加的特性，使用ARC开发者不需要再retain、release、autorelease，因为编译器会在合适的地方自动插入retain、release。ARC不会因少release而导致内存泄漏，过度使用release导致程序崩溃，ARC可以产生更简洁的代码和更健壮的应用。15.SVN、Git协作开发，怎么防止代码文件冲突？防止代码冲突：不要多人同时修改同一个文件。例如，A、B都修改同一个文件，先让A修改，然后提交到服务器，然后B更新下来，再进行修改。服务器上的项目文件xcodeproj，仅让一个人管理提交，其他人只更新。防止此文件产生冲突。第六部分1.什么是ARC？ARC是automatic reference counting自动引用计数，在程序编译时自动加入retain/release。在对象被创建时retain count+1，在对象被release时count-1，当count=0时，销毁对象。程序中加入autoreleasepool对象会由系统自动加上autorelease方法，如果该对象引用计数为0，则销毁。那么ARC是为了解决MRC手动管理内存存在的一些而诞生的。MRC下内存管理的缺点：1）释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。(避免提前释放)2）释放指针指向的堆空间，首先要确定哪些指向同一个堆，这些指针只能释放一次。(避免释放多次，造成内存泄露)3）模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁释放。4）多线程操作时，不确定哪个线程最后使用完毕。虽然ARC给我们编程带来的很多好多，但也可能出现内存泄露。如下面两种情况：1）循环参照：A有个属性参照B，B有个属性参照A，如果都是strong参照的话，两个对象都无法释放。2）死循环：如果有个ViewController中有无限循环，也会导致即使ViewController对应的view消失了，ViewController也不能释放。2.block一般用哪个关键字修饰，为什么？block一般使用copy关键之进行修饰，block使用copy是从MRC遗留下来的“传统”，在MRC中，方法内容的block是在栈区的，使用copy可以把它放到堆区。但在ARC中写不写都行：编译器自动对block进行了copy操作。3.用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？用@property声明 NSString、NSArray、NSDictionary 经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作，为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。copy此特质所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝” (copy)。 当属性类型为NSString时，经常用此特质来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变” (immutable)的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的” (mutable)，就应该在设置新属性值时拷贝一份。4.runloop、autorelease pool以及线程之间的关系？每个线程(包含主线程)都有一个Runloop。对于每一个Runloop，系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个像callstack一样的一个栈式结构，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个Object会被release。5.@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的？“属性”(property)有两大概念：ivar(实例变量)、存取方法(access method=getter)，即@property = ivar + getter + setter。例如下面的这个类：@interface WBTextView :UITextView  @property (nonatomic,copy)NSString *placehold;  @property (nonatomic,copy)UIColor *placeholdColor;  @end类完成属性的定以后，编译器会自动编写访问这些属性的方法(自动合成autosynthesis)，上述代码写出来的类等效与下面的代码：@interface WBTextView :UITextView  - (NSString *)placehold;  -(void)setPlacehold:(NSString *)placehold;  -(UIColor *)placeholdColor;  -(void)setPlaceholdColor:(UIColor *)placeholdColor;  @end详细介绍见：http://blog.csdn.net/jasonjwl/article/details/494273776.分别写一个setter方法用于完成@property (nonatomic,retain)NSString *name和@property (nonatomic,copy) NSString *name？retain属性的setter方法是保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而且两个值又指向同一个对象，先执行的release操作就可能导致系统将此对象永久回收。-(void)setName:(NSString *)name{    [name retain];    [_name release];    _name = name;}-(void)setName:(NSString *)name{         [_name release];    _name = [name copy];}7.说说assign和weak，_block和 _weak的区别？assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。assign其实也可以用来修饰对象，那么为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续内存分配中，刚巧分到了这块地址，程序就会崩溃掉。而weak修饰的对象在释放之后，指针地址会被置为nil。_block是用来修饰一个变量，这个变量就可以在block中被修改。_block:使用_block修饰的变量在block代码块中会被retain(ARC下，MRC下不会retain)。_weak:使用_weak修饰的变量不会在block代码块中被retain。8.请说出下面代码是否有问题，如果有问题请修改？@autoreleasepool {        for (int i=0; i&lt;largeNumber; i++) {            Person *per = [[Person alloc] init];            [per autorelease];        }    }内存管理的原则：如果对一个对象使用了alloc、copy、retain，那么你必须使用相应的release或者autorelease。咋一看，这道题目有alloc，也有autorelease，两者对应起来，应该没问题。但autorelease虽然会使引用计数减一，但是它并不是立即减一，它的本质功能只是把对象放到离他最近的自动释放池里。当自动释放池销毁了，才会向自动释放池中的每一个对象发送release消息。这道题的问题就在autorelease。因为largeNumber是一个很大的数，autorelease又不能使引用计数立即减一，所以在循环结束前会造成内存溢出的问题。解决方案如下：@autoreleasepool {        for (int i=0; i&lt;100000; i++) {             @autoreleasepool {            Person *per = [[Person alloc] init];            [per autorelease];        }      }    }在循环内部再加一个自动释放池，这样就能保证每创建一个对象就能及时释放。9.请问下面代码是否有问题，如有问题请修改？@autoreleasepool {        NSString *str = [[NSString alloc] init];        [str retain];        [str retain];        str = @"jxl";        [str release];        [str release];        [str release];}这道题跟第8题一样存在内存泄露问题，1）内存泄露 ；2）指向常量区的对象不能release。指针变量str原本指向一块开辟的堆区空间，但是经过重新给str赋值，str的指向发生了变化，由原来指向堆区空间，到指向常量区。常量区的变量根本不需要释放，这就导致了原来开辟的堆区空间没有释放，造成内存泄露。10.什么情况下使用weak关键字，相比assign有什么不同？什么情况使用weak关键字？1）在ARC中，在有可能出现循环引用的时候，往往要通过让其中一端使用weak来解决。比如delegate代理。2）自身已经对它进行一次强引用，没有必要再强引用一次，此时也会使用weak，自定义控件属性一般也使用weak。不同点：1）weak此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性与assign一样，然而在属性所指的对象遭到销毁时，属性值也会清空。而assign的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。2）assign可以用非OC对象，而weak必须用于OC对象。11.内存管理语义(assign、strong、weak等的区别)?1）assign “设置方法” 只会执行针对“纯量”的简单赋值操作。2）strong  此特性表明该属性定义了一种“拥有关系”。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。3）weak 此特性表明该属性定义了一种“非拥有关系”。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特性同assign类似，然而在属性所指的对象遭到销毁时，属性值也会清空。4）unsafe_unretained  此特性的语义和assign相同，但是它适用于“对象类型”，该特性表达一种“非拥有关系”，当目标对象遭到销毁时，属性值不会自动清空，这一点与weak有区别。5）copy 此特性所表达的所属关系与strong类似。然而设置方法并不保留新值，而是将其“拷贝”。当属性类型为NSString*时，经常用此特性来保护其封装性，因为传递给设置方法的新值有可能指向一个NSMutableString类的实例。这个类是NSString的子类，表示一种可以修改其值的字符串，此时若是不拷贝字符串，那么设置完属性之后，字符串的值就可能会在对象不知情的情况下遭人更改。所以，这时就要拷贝一份“不可变”的字符串，确保对象中的字符串值不会无意间变动。只要实现属性所用的对象是“可变的”，就应该在设置新属性值时拷贝一份。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Objective-C中的NSPredicate]]></title>
      <url>/blog/objective-c-NSPredicate/</url>
      <content type="text"><![CDATA[编写软件时，经常需要获取一个对象集合，并通过某些已经条件计算该集合的值。你需要保留符合某个条件的对象，删除那些不满足条件的对象，从而提供一些有意义的对象。在使用软件iPhoto的过程中，经常会看到这种现象，如果通知iPhoto仅显示等级为三星级或三星级以上的图片，则指定的条件为“照片的等级必须为三星级或三星级以上”。这样，所有照片都需要经过该过滤器过滤。满足条件的对象通过了过滤器，而其他对象被筛除了。最后，iPhoto将显示出所有高质量的图片。Cocoa提供了一个名为NSPredicate的类，它用于指定过滤器的条件。可以创建NSPredicate对象，通过该对象准确地描述所需的条件，对每个对象通过谓词进行筛选，判断它们是否与条件相匹配。这里的“谓词”通常用在数学和计算机科学概念中，表示计算真值或假值的函数。Cocoa用NSPredicate描述查询的方式，原理类似于在数据库中进行查询。可以在数据库风格的API中使用NSPredicate类，例如Core Data和Spotlight。可以将NSPredicate看成另一种间接操作方式。例如，如果需要查询满足条件的机器人，可以使用谓词对象进行检查，而不必使用代码进行显示查询。通过交换谓词对象，可以使用通用代码对数据进行过滤，而不必对相关条件进行硬编码。创建1）方式一创建许多对象，并将它们组合起来。如果正在构建通用用户接口来指定查询，采用这种方式比较简单。2）方式二查询代码中的字符串。Car *car;Car = makeCar(@"Herbie", @"Honda", @"CRX",  1984, 2, 110000, 58);[garage addCar:car];/*构建的汽车：品牌为Herbie，型号为双门1984Honda CRX，马力引擎为58，已经行驶距离为110000英里*//*创建谓词*/NSPredicate *predicate;predicate = [NSPredicate predicateWithFormat:@"name == 'Herbie'"];计算谓词BOOL match = [predicate evaluateWithObject:car];NSLog(@"%s",(match) ? "YES":"NO");另外一个谓词：NSPredicate *predicate = [NSPredicate predicateWithFormat:@"engine.horsepower &gt;150"];/*查看车库中哪些车的功率最大，可以循环测试每个汽车的谓词*/NSArray *cars = [garage cars];for(Car *car in cars){    if([predicate evaluateWithObject:car]){        NSLog(@"%@", car.name);    }}过滤器如果我们不必像上文那样编写for循环和if语句，这有什么不好？实际上，某些类别将谓词过滤方法添加到了Cocoa集合类中。-filteredArrayUsingPredicate:是NSArray数组中的一种类别方法，它将循环过滤数组内容，根据谓词计算每个对象的值，并将值为YES的对象累积到将被返回的新数组中：NSArray *results;results = [cars filteredArrayUsingPredicate:predicate];NSLog(@"%@",results);假如有一个可变数组，你需要剔除不属于该数组的所有项目：NSMutableArray *carsCopy = [cars mutableCopy];[carsCopyfilterUsingPredicate:predicate];格式说明符资深编程人员都知道，硬编码并非好方法，因此，我们可以通过格式符构建谓词：NSPredicate  *predicate = [NSPredicate predicateWithFormat:@"engine.horsepower &gt; %d", 50];运算符NSPredicate的格式字符串包含大量不同的运算符。1）比较和逻辑运算符谓词字符串语法支持C语言中一些常用的运算符，例如等号运算符==和=。不等号运算符具有各种形式：&gt;：大于&gt;=和=&gt;：大于或等于&lt;：小于&lt;=和=&lt;：小于或等于!=和&lt;&gt;：不等于            此外，谓词字符串语法还支持括号表达式和AND、OR、NOT逻辑运算符或者C样式的等效表达式&amp;&amp;、             和!。      2）数组运算符谓词字符串“(engine.horsepower&gt; 50) OR (engine.horsepower &lt; 200)”是一种十分常见的模式。等效于：predicate= [NSPredicate predicateWithFormat:@"engine.horespower BETWEEN {50,200}"];花括号表示数组，BETWEEN将数组中第一个元素看成是数组的下界，第二个元素看成是数组的上界。NSArray *betweens = [NSArray arrayWithObjects:[NSNumber numberWithInt:50],[NSNumber   numberWithInt:200], nil];predicate = [NSPredicate predicateWithFormat:@"engine.horsepower BETWEEN %@",betweens];数组不仅仅用来指定某个区间的端点值。你可以使用IN运算符查找数组中是否含有某个特定值。predicate = [NSPredicate predicateWithFormat:@"name IN {'Herbie', 'Snugs', 'Badger','Flap'}"];]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[日语-助词]]></title>
      <url>/blog/japanese-auxiliary-word/</url>
      <content type="text"><![CDATA[助词，又称为语助词。文法术语，指的是一种词类，属于虚词，附着在其他词汇、词组，或是句子上，作为辅助之用。通常用于句子前、中、后，表示各种语气；或是用于语句中间，表示结构上的关系。日语中的助词极为丰富，而每一个助词的使用场景也非常多，不得不承认这是一大难点，也是重点。1 に用法  1）表地点，场所名词+に+名词，具体位置部屋に机があります。  2）表时间点（包含数字的时间）学校は８時半に始まります。  3）表附着点  温泉に入ります。  船に乗ります。  4）表目的  日本へ花見に行きます。  土曜日か日曜日に買い物に行きます。（第一个に表示时间点，第二个に表示目的）  5）表对象，人物对象，抽象事物友達に会います。  6）表频率  李さんは１週間に２回プールへ行きます。  李さんは週に２回プールへ行きます。  7）表目的地  日本に行きます。  家に帰ります。  8）表选择赤いほうがいいです。じゃあ、これにします。  9）表基准（“相对而言”）体にいいです。对身体好。  10）表结果中国語を日本語に訳(やく)す。2 で用法  1）表交通手段上海まで飛行機で行きます。  2）表地点范围，名词+で+动词  図書館で勉強します。  お昼は食堂（しよくどう）で食べます。  妹は部屋で音樂を聞きます。  3）表方式，手段  速達で送ります。  メールで両親と連絡します。  4）表原材料（で表示能看出原材料，から表示不能看出原材料）こむぎこでパンを作ります。  5）表花费（时间，金钱）このケーキは３個で１５０円です。  6）表主体みなさんで読みましょう。  7）表并列（二类形容词或名词）森さんは親切（しんせつ）で優（やさ）しいです。  8）表原因、理由仕事(しごと)、楊(よう)さんと会(あ)っていたんですよ。  9）表状态患者(かんじゃ)でいっぱい。2.1 で和に的区别１）で强调后接动态动词。に强调后接静态动词。3 が用法  1）表情感词前ネズミがこれい。  2）表能力词前  日本語が分かる。  日本語ができる。  3）自动词前  足が疲れる。  足が痛い。  4）形容词前箱根はホテルや旅館が多いですね。  5）存在句（が表听话方不知道的，は表双方都知道的）ホテルで友達の写真展があります。  6）疑问词作主语この中でどの料理がいちばんおいしいですか。4 を用法  1）表对象，动宾结构，名词+を+动词パンヤミルクなどを食べます。  2）表范围，路线駅前を通る（とおる）。  3）表出发点家をでます。5 から用法  1）表时间起点來週、金曜日の夜７時から、ホテルでパーテイーがあります。  2）表空间起点大阪（おおさか）から上海（シャンハイ）まで飛行機（ひこうき）で行きますか。  3）表因为私はドリアンを全然食べません。嫌いですから。6 へ用法  1）表去向吉田さんは中国へ行きます。7 か用法  1）表选择，二选一，名词+か+名词毎月（まいつき）１回か２回映画（えいが）を見ます。8 假设用法总结8.1 と注意：不能和祈使语气连用。动词原形／动词ない形+と表示必然结果或假设。8.1.1 必然结果翻译成 “一···就···”。  1）恒常状态  ボタンを押す（おす）と電源（でんげん）が入る（はいる）。  お金を入れ（いれ）ると、切符（きっぷ）が出る（だる）。  2）自然现象  春（はる）になると、花（はな）が咲く（さく）。  夜（よる）になると、気温（きおん）が下がる（さがる）。  3）习惯  彼（あれ）は家（うち）に帰ると、パソコンに向かって（むかって）いる。  朝起（お）きると、コーヒーを飲む。  4）意外发现  学校（がっこう）に着（つき）くと、雨（あめ）が止（や）んだ。  窓（まど）を開（ひら）けると、富士山が見えました。  5）客观真理道（みち）を右（みぎ）に曲がる（まがる）と、床屋（とこや）があります。床屋：理发店8.1.2 假设翻译成“如果···的话”。人間（にんげん）は水（みず）を飲まないと、生（い）きていけない。8.2 たら动词た形/A1 かった/N/A2 だった+ら表示假设，意外发现，之后。N/A2 で~~は~~なかったら 表示假设，意外发现，之后。例句：  1億（おく）円の宝くじに当たったら、世界旅行をします。  安かったら買います。  明日暇だったら、行きません。  明日雨だったら、行きません。      明日雨で~~は~~なかったら、行く。    窓を開けたら、富士山が見えた。      会社へ行ったら、休みだった。    家に着いたら、電話してください。  卒業したら、どうするつもりですか。8.3 ば&lt;条件&gt;一般不能用于祈使语气，但是，当前后主语不一样时可以使用祈使语气。前项是后项的条件。例句：  暇があれば行きます。“只要闲暇就去。”  夏になれば、海へ行く。“一到夏天就去海边。”  体が元気であれば、働いていきます。“如果身体健康，一直工作下去。”  安ければ、買う。“如果便宜就买。”  天気がよければ、行きます。“如果天气好就去。”  あなたが行げば、私も行く。“如果你去，我就去。”  質題があれば、聞いてください。“(你)如果有问题，请问我。”  雨が降らなければ、ハイキングに行きましょう。“要是不下雨，就去郊游。”  質題がなければ、ましょう終わり。“如果没问题，我就结束。”  質題がなければ、ここで終わり。“如果没问题，我就结束。”8.4 なら&lt;话题&gt;动词原型／名词+なら“…的话”。后面多接建议、提醒。例句：  温泉なら箱根が最高（せいこ）だよ。“泡温泉的话，箱根最好。”  電気（でんき）製品を買うなら、秋葉原（あきはばら）のがいいですよ。“买电器的话，秋叶原最好。”  タバコを吸うなら、出てください。“如果抽烟请出去。”  先生なら、トイレにいます。“老师在厕所。”]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 日语 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MySQL 安装配置]]></title>
      <url>/blog/mysql-install-config/</url>
      <content type="text"><![CDATA[MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件。MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。以v5.6.36为例配置拷贝/usr/local/mysql/support-files/中my-default.cnf文件，改名为my.cnf并放至/usr/local/mysql/文件夹下。后续数据库的配置都可以在此文件中设置。密码修改Mac 安装完 MySQL 之后，软件会生成一个默认密码给我们。但是，当我使用Navicat来建立连接是却提示密码失效，无奈，只能修改数据库默认密码。接下来，记录整个root密码修改过程。在开始下面的步骤之前必须先停止mysql服务！1, cd /usr/local/mysql/bin/2, sudo su跨过权限验证:3, ./mysqld_safe --skip-grant-tables &amp;这时不要关窗口，再打开一个终端窗口。以root身份登录，因为第三步的原因不需要密码了。4, ./mysql -uroot4，sudo /usr/local/mysql/bin/mysql -u root5, use mysql;6, update user set authentication_string='123456' where User='root';7, flush privileges;8, exit;网上流传的版本全部是set password ＝‘’ ，这样写一直报错说 ‘password’列不存在！最终用sql命令查出来只有authentication_string字段，并没有password字段。上一步执行之后本来以为已经可以登录了，可是navicat连接测试时出现了：ERROR 1862 (HY000): Your password has expired. To log in you mustchange it using a client that supports expired passwords.所以还需要下面步骤1, cd /usr/local/mysql/bin/2, sudo su3, ./mysql -uroot  -p1234564, set password = password('123456')用户名：root，密码：123456修改成功关闭或启动MySQL：sudo /usr/local/mysql/support-files/mysql.server stopsudo /usr/local/mysql/support-files/mysql.server start打开MySQL数据库：sudo /usr/local/mysql/bin/mysql -uroot  -p123456Warning可能在打开数据库时会出现下面错误提示：Warning: Using a password on the command line interface can be insecure.ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: YES)解决方案：在my.cnf配置文件中添加账户配置:[client]user = whatever #账户，一般配置rootpassword = whatever #账户密码host = whatever #主机，可以为localhost使用为了方便使用，我们可以设置几个常用的命令。# 启动MySQLstartmysql() {	sudo /usr/local/mysql/support-files/mysql.server start}# 关闭MySQLstopmysql() {	sudo /usr/local/mysql/support-files/mysql.server stop}# 连接MySQLopenmysql() {	sudo /usr/local/mysql/bin/mysql -u"$1"}]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> mysql </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[FMDB 代码阅读]]></title>
      <url>/blog/fmdb-reading/</url>
      <content type="text"><![CDATA[FMDB 是iOS平台的SQLite数据库框架，以ObjC的方式封装了SQLite的C语言的API。FMDB使用起來更加的面向对象，省去了很多麻烦、冗余的C语言代码。相比Apple自带的Core Data框架，更加的轻量和灵活。提供了多线程安全的数据库操作的方法，有效的防止数据混乱。项目文件      FMDatabase : 一个SQLite数据库操作单例，通过它可以对数据库进行增删改查等操作。        FMResultSet : FMDatabase执行查询之后的结果集。        FMDatabaseAdditions : 拓展FMDatabase类，新增对查询结果只返回单个值的方法进行简化，对表、列是否存在，版本号，校验SQL等功能。        FMDatabaseQueue : 使用串行对列 ，操作多线程。        FMDatabasePool : 使用任务池的形式，操作多线程。  FMDatabase打开数据库连接      -(BOOL)open; 其实是对sqlite3_open()函数的封装。        - (void)setMaxBusyRetryTimeInterval:(NSTimeInterval)timeout; 设置重试时间。其实调用的是 int sqlite3_busy_handler(sqlite3 *,int(*)(void *,int),void *);  该函数的第一个参数：需要告知哪一个数据库需要设置busy handler。第二个参数：需要回调的busy handler，当你调用该回调函数的时候，需要传给它一个void*的参数，也就是sqlite3_busy_handler的第三个参数。第三个参数：需要传给回调函数的int参数表示这次锁事件，该回调函数被调用的次数。如果回调函数返回0时，将不再尝试再次访问数据库，而返回SQLITE_BUSY或者SQLITE_IOERR_BLOCKED。如果回调函数返回非0，将会不断尝试操作数据库。程序运行过程中，如果有其他进程或者线程在读写数据库，那么sqlite3_busy_handler会不断用用该回调函数，直到其他线程或者进程释放锁。获得锁之后，不会再调用该回调函数，从而继续向下执行下去，进行数据库操作。该函数是在获取不到锁的时候，以执行回调函数的次数來进行延时，等待其他进程或者线程操作数据库结束，从而获得锁进行操作数据库。查询数据库executeQuery 系列函数从根本上看，其实调用的都是- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arrayArgs orDictionary:(NSDictionary *)dictionaryArgs orVAList:(va_list)args      参数sql: 需要查詢的sql语句。        参数arrayArgs: 数组类型的参数。  FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM t_student WHERE age &gt; ?" withArgumentsInArray:@[@20]];  参数dictionaryArgs: 字典类型的参数。FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM t_student WHERE age &gt; :age" withParameterDictionary:@{@"age":@20}];  参数args: 可变参数类型。FMResultSet *resultSet = [_db executeQuery:@"SELECT * FROM t_student WHERE age &gt; ?",@(20)];更新数据库操作这并不只是单单更新数据，而是对数据库有更改的操作，增删改都算。FMDB调用的都是executeupdate系列函数。这个函数基本上跟executeQuery系列函数的实现基本相同。只是它生成statement对象后，直接调用rc = sqlite3_step(pStmt);更新执行，而没有像executeQuery延迟到FMResultSet中的next函数中执行。一次性执行多条sql语句。使用executeStatements函数可以一次性执行多条sql语句。其实现方式就是对sqlite3_exec函数的封装。FMDB的加解密FMDataase中使用- (BOOL)setKey:(NSString*)key;和- (BOOL)setKeyWithData:(NSData *)keyData;输入数据库密码以求验证用户身份，使用- (BOOL)rekey:(NSString*)key;和- (BOOL)rekeyWithData:(NSData *)keyData;来给数据库设置密码或者清除密码。这两类函数分別对sqlite3_key和sqlite3_rekey函数进行了封装。FMDatabaseAdditionsXXXForQuery系列函数对查询结果只有一个值的情况进行优化，有多个值也只取第一个值。/** *  使用FMDatabaseAdditions中的intForQuery函数查找数据,如果返回结果有多个数据只取第一条数据 */- (void)queryForIntForQuery{    int idx = [_db intForQuery:@"SELECT id FROM t_student WHERE age = ?",@(26)];}数据库的一些概要信息-(BOOL)tableExists:(NSString*)tableName;数据库表是否存在。-(BOOL)columnExists:(NSString*)columnName inTableWithName:(NSString*)tableName;在tableName表中columnName是否存在。-(FMResultSet*)getSchema;数据库的一些概要信息。校验sql语句是否合法-(BOOL)validateSQL:(NSString *)sql error:(NSError **)error;FMResultSet初始化对象  参数1：(FMStatement *)statement该对象主要是对sqlite3_stmt的封装，sqlite3_stmt * 所表示的内容可以看成是预处理过的sql语句，已经不是我们熟知的sql语句。它是一个已经把sql语句解析了，用sqlite自己表示记录的内部数据结构。  参数2：(FMDatabase *)aDB该结果集所属于的FMDatabase数据库操作对象。+ (instancetype)resultSetWithStatement:(FMStatement *)statement usingParentDatabase:(FMDatabase*)aDB;遍历取得所有的结果集合-(BOOL)next; 其实是对 -(BOOL)nextWithError:(NSError **)outErr; 函数的封装。主要作用是通过sqlite3_step函数对FMStatement中的sqlite3_stmt对象进行逐行取值。列名与该列的列数的一一对应关系      @property (readonly) NSMutableDictionary  *columnNameToIndexMap; 对象中保存了列名与索引一一对应的关系的对照表。        -(int)columnIndexForName:(NSString *)columnName; 根据列名获取该列所在第几列（列的索引）        -(NSString *)columnNameForIndex:(int)columnIdx; 根据列的索引获取该列的名称。  获得每一行中每一个列字段的值。      -XXXForColumnIndex:(int)columnIdx; 根据列的索引获取该列的值。        -XXXForColumn:(NSString*)columnName; 根据列的名称获取该列的值。        -XXXForColumnIndex:(int)columnIdx; 其实是对sqlite3column*函数的封装。  - (int)intForColumnIndex:(int)columnIdx {    return sqlite3_column_int([_statement statement], columnIdx);}获取每一行中所有的结果集合- (NSDictionary*)resultDictionary;FMDatabaseQueue使用实例:FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];[queue inDatabase:^(FMDatabase *db) {    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:1]];    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:2]];    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:3]];    FMResultSet *rs = [db executeQuery:@"select * from foo"];    while ([rs next]) {        …    }}];[queue inTransaction:^(FMDatabase *db, BOOL *rollback) {    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:1]];    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:2]];    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:3]];    if (whoopsSomethingWrongHappened) {        *rollback = YES;        return;    }    // etc…    [db executeUpdate:@"INSERT INTO myTable VALUES (?)", [NSNumber numberWithInt:4]];}];事务的实现数据库中的事务也是保证数据库安全的一种手段。一段sql语句，要么全部成功，要么全部不成功。  关于延时性事务和独占性事务的区别在SQLite 3.0.8或更高版本中，事务可以是延迟的，即时的或者独占的。“延迟的”即是说在数据库第一次被访问之前不获得锁。这样就会延迟事务，BEGIN语句本身不做任何事情。直到初次读取或访问数据库时才获取锁。对数据库的初次读取创建一个SHARED锁，初次写入创建一个RESERVED锁。由于锁的获取被延迟到第一次需要时，别的线程或进程可以在当前线程执行BEGIN语句之后创建另外的事务写入数据库。若事务是即时的，则执行BEGIN命令后立即获取RESERVED锁，而不等数据库被使用。在执行BEGIN IMMEDIATE之后， 你可以确保其它的线程或进程不能写入数据库或执行BEGIN IMMEDIATE或BEGIN EXCLUSIVE. 但其它进程可以获取数据库。 独占事务在所有的数据库获取EXCLUSIVE锁，在执行BEGIN EXCLUSIVE之后，你可以确保在当前事务结束前没有任何其它线程或进程能够读写数据库。FMDatabasePoolFMDatabasePool : 使用任务池的形式，对多线程的操作提供支持。不过官方对这种方式并不推荐使用（ONLY_USE_THE_POOL_IF_YOU_ARE_DOING_READS_OTHERWISE_YOULL_DEADLOCK_USE_FMDATABASEQUEUE_INSTEAD），优先选择FMDatabaseQueue的方式。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> objc </tag>
        
          <tag> 存储 </tag>
        
          <tag> 框架 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[日语-动词的变形和分类]]></title>
      <url>/blog/japanese-verb/</url>
      <content type="text"><![CDATA[动词（Verb），简称v 。 一般就是用来表示动作或状态的词汇。基本上每个完整的句子都有一个动词，要表示第二个动作时可使用不定词、动名词、对等连接词、从属连接词或增加子句等方法连结。 突跃,突击,突袭等描述动作过程均属动词。中文语法中表示人或事物的动作或一种动态变化。一般出现在名词主语或主句后面。日语中动词主要分为3大类，称为一类动词，二类动词和三类动词（简称，动1，动2和动3），而三类动词中又可以分为2类，即カ变和サ变动词。另外，还有一种经常用到的动词，即授受动词。1 授受动词1.1 授受主体为物品  あげます：我或我方给别人，常用于上对下私は小野さんにパンカチをあげます。彼氏は李さんにバラをあげます。注意：若分不清我方和别人时，一律用这种句型。父は母に本をあげます。私は先生に本をあげます。注意：变疑问句[我方]は誰（だれ）に何をあげますか。  もらいます：我或我方从别人那里得到，礼貌用法私は先生からに辞書をもらいます。私は会社からパソコンをもらいます。注意：别人为个人时，后面用に；别人为团体时，后面用から。  くれます：别人给我或我方，平级间使用先生は私に辞書をくれます。社長は弟におもちゃをくれます。注意 还有一些动词也属于授受类，例如，借东西，还东西。教えます、貸します：我或我方教别人学习东西或借东西给别人。習います、借ります：我或我方跟别人学习东西或从别人那里借东西。1.2 授受主体为动作  てあげます：我或我方为别人做某事，常用于上对下おじいさんが孫(まご)に本を読んであげました。分(わ)からないですか、じゃ教え(おしえ)てあげましよう。  てもらいます：我或我方请别人做某事，礼貌用法冷蔵庫はもう電話して明日送(おく)ってもらいました。冷蔵庫はもう電話して明日届(とど)けてもらいました。  てくれます：别人为我或我方做某事，平级间使用信(しん)じてくれて。ごみを出(だ)してくれますか。2 自动词和他动词2.1 他动词带宾语才能完整表达意思。规律：え段＋る；以す结尾。ドアを開ける、消す、話す2.2 自动词无需带宾语就能完整表达意思。规律：あ段＋る；一般以く结尾。ドアが開く、歩く、咲く2.3 分类  没有他动词的自动词歩く、帰る、行く、遊ぶ、走る  没有自动词的他动词食べる、見る、話す、言う、買う、飲む  既有自动词，也有他动词開ける、開く；閉める、閉まる  既是自动词，又是他动词笑う（わらう）、終わる、休み3 动词分类            类型      规则      示例                  一类动词（动1）      以う段假名结尾的词　      　行く、読む、帰る（かえる）、滑る（すべる）　              二类动词（动2）      以る结尾，且る前为い段假名或え段假名的词　      　寝る、見る、食べる （注意一个汉字一个音）              三类动词（サ变）      する（万能动词）      　勉強する、電話する　              三类动词（カ变）      　来（く）る　      　      4 动词变形4.1 原形变ます形            类型      规则      示例                  一类动词      う段-&gt;い段＋ます　      　行く-&gt;行きます　              二类动词      去る-&gt;＋ます　      　見る-&gt;見ます　              三类动词（サ变）      　する-&gt;します　      　勉強する-&gt;勉強します　              三类动词（カ变）      　くる-&gt;きます　      　来る-&gt;来ます　      4.2 ます形变原形            类型      规则      示例                  一类动词      去掉ます，将ます前一个假名按行后移一个　      　あります-&gt;ある　              二类动词      将ます去掉，直接换成る　      　見ます-&gt;見る　              三类动词（サ变）      　します-&gt;する　      　勉強します-&gt;勉強する　              三类动词（カ变）      　きます-&gt;くる　      　来ます-&gt;来る　      4.3 原形变命令形            类型      规则      示例                  一类动词      去掉最后一个假名按行后移到え段　      　とまります-&gt;とまれ、行く-&gt;行け、死(し)ぬ-&gt;死ね　              二类动词      将る去掉，直接换成ろ　      　見る-&gt;見ろ、やめる-&gt;やめろ、逃(に)げる-&gt;逃げろ　              三类动词（サ变）      　する-&gt;しろ　      　勉強する-&gt;勉強しろ　              三类动词（カ变）      　来(く)る-&gt;こい　      　来る-&gt;こい　      命令形一般男性使用，但是在看球赛或危险时使用。女性可以使用动词&lt;动词ます形去掉ます&gt;+なさい语法来表达。しっかりしろ。给我醒醒。4.4 原形变意志形（よう形）动词よう形是动词ましよう的口语，表示劝诱。翻译成“···吧”            类型      规则      示例                  一类动词      把最后一个假名变成え段，再加ば　      　行く-&gt;行けば　              二类动词      将る去掉，直接换成れば　      　見る-&gt;見れば　              三类动词（サ变）      　する-&gt;すれば　      　勉強する-&gt;勉強すれば　              三类动词（カ变）      　くる-&gt;くれば　      　来る-&gt;くれば　      4.5 原形变ば形            类型      规则      示例                  一类动词      把最后一个假名变成お段，再加う　      　行く-&gt;行こう　              二类动词      将る去掉，直接换成よう　      　見る-&gt;見よう　              三类动词（サ变）      　する-&gt;しよう　      　勉強する-&gt;勉強しよう　              三类动词（カ变）      　くる-&gt;こよう　      　来る-&gt;来よう　      4.6 原形变能动态(られる)            类型      规则      示例                  一类动词      把最后一个假名变成え段，再加る　      　行く-&gt;行ける　              二类动词      将る去掉，直接换成られる　      　見る-&gt;見られる　              三类动词（サ变）      　する-&gt;できる　      　勉強する-&gt;勉強できる　              三类动词（カ变）      　くる-&gt;こられる　      　来る-&gt;こられる　      注意： を要变が，其他不变。4.7 原形变被动态(される)            类型      规则      示例                  一类动词      把最后一个假名变成あ段，再加れる　      　行く-&gt;行かれる、買う-&gt;買われる　              二类动词      将る去掉，直接换成られる　      　見る-&gt;見られる　              三类动词（サ变）      　する-&gt;される　      　勉強する-&gt;勉強される　              三类动词（カ变）      　くる-&gt;こられる　      　来る-&gt;こられる　      4.8 原形变使役态(させる)            类型      规则      示例                  一类动词      把最后一个假名变成あ段，再加せる　      　行く-&gt;行かせる　              二类动词      将る去掉，直接换成させる　      　見る-&gt;見させる　              三类动词（サ变）      　する-&gt;させる　      　勉強する-&gt;勉強させる　              三类动词（カ变）      　くる-&gt;こさせる　      　来る-&gt;こさせる　      4.9 原形变使役被动态(させられる)            类型      规则      示例                  一类动词      把最后一个假名变成あ段，再加される/せられる　      　行く-&gt;行かされる、行く-&gt;行かせられる　              二类动词      将る去掉，直接换成させられる　      　見る-&gt;見させられる　              三类动词（サ变）      　する-&gt;させられる　      　勉強する-&gt;勉強させられる　              三类动词（カ变）      　くる-&gt;こさせられる　      　来る-&gt;こさせられる　      4.10 原形变て形て形作用：两个动词间使用，表中顿，表相继；语法接续。  一类动词变て形1）う、つ、る结尾，促音变。即去掉结尾假名变成って示例：買う-&gt;買って、待つ-&gt;待って、売る（うる）-&gt;売って2）ぬ、ぶ、む结尾，拨音变。即去掉结尾假名变成んで示例：死ぬ-&gt;死んで、飛ぶ-&gt;飛んで、飲む-&gt;飲んで3）く、ぐ结尾，い音变。即去掉结尾假名分别变成いて、いで示例：歩く-&gt;歩いて、急ぐ-&gt;急いで4）す变成して示例：話す-&gt;話して特例行く-&gt;行って  二类动词变て形去る+て示例：見る-&gt;見て、食べる-&gt;食べて  三类动词变て形1）する-&gt;して示例：勉強する-&gt;勉強して2）来る（くる）-&gt;来て（きて）4.11 原形变た形变形规则和原形变て形一样，只要将て换成た即可。4.12 原形变ない形  一类动词变ない形变う段为あ段+ない示例：行く（いく）-&gt;行か（いか）ない特例：う-&gt;わ手伝う（てつだう）-&gt;手伝わない（てつだわない）  二类动词变ない形去る+ない示例：見る-&gt;見ない、食べる-&gt;食べない  三类动词变ない形1）する-&gt;しない示例：勉強する-&gt;勉強しない2）来る（くる）-&gt;来ない（こない）4.13 原形变禁止形动词原形+な5 动词规则  一类动词            あ段      い段      う段      え段      お段                  ない形      ます形      原形      命令形/能动态(え段+る)      意志形      ]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 日语 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[个人作品]]></title>
      <url>/blog/personal-projects/</url>
      <content type="text"><![CDATA[偶尔写写自己的小应用，主要有 靓手艺、Piclip、今日账单 等。日本语社区———— 语言是生产力晋升的阶梯这款软件主要收集日语学习资源，整合各种文本、音频和视频学习资料。下载地址：https://itunes.apple.com/cn/app/id1184113889今日账单———— 清晰简洁、记录每一单帐单记录与数据分析，内含云备份功能，界面简洁清爽。下载地址：https://itunes.apple.com/cn/app/id1176787145Piclip———— 切图分享、不一样的风格即兴想起的一款九宫格切图软件，当然还有六、四等宫格布局。下载地址：https://itunes.apple.com/cn/app/id1188174656靓手艺———— 健康美食、快乐生活【靓手艺】里面有美容健身、疾病调理、节气习俗、适宜人群、小吃、外国美食等二十二大分类，总共六十多万条菜谱配方，全方位满足我们的吃货需求。面对这么多的菜谱数据，我们可以很便捷的查找我们需要的菜谱，只需要我们简单的搜索我们想要的菜谱或者食材，就能找到满意的答案。另外，根据我们的喜好口味，推荐热门爆款菜谱、热点兴趣菜谱，帮助我们发现不一样的美食世界，挖掘我们内心潜在的吃货属性。不仅如此，我们还能看到每天最受欢迎的菜谱分类，可以清楚掌握在美食的世界里，我们的小伙伴都喜欢吃些什么，如果愿意，我们也能和大家靠近，尝试不一样的口味菜系。作为一个真正的吃货，是一定能够自己满足自己的。我们也能将我们喜欢的菜谱“收藏”起来，也能推荐分享给他人。当然，我们也能边看边做，菜谱里的做法步骤提供能“朗读”功能，完美释放我们的双手，可以边听边做，真的不要太美好啦。下载地址：http://itunes.apple.com/cn/app/id1177823334]]></content>
      <categories>
        
          <category> project </category>
        
      </categories>
      <tags>
        
          <tag> project </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac 安装和配置 Tomcat]]></title>
      <url>/blog/mac-install-apache-tomcat/</url>
      <content type="text"><![CDATA[Tomcat是由Apache软件基金会下属的Jakarta项目开发的一个Servlet容器，按照Sun Microsystems提供的技术规范，实现了对Servlet和JavaServer Page（JSP）的支持，并提供了作为Web服务器的一些特有功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。由于Tomcat本身也内含了一个HTTP服务器，它也可以被视作一个单独的Web服务器。但是，不能将Tomcat和Apache Web服务器混淆，Apache Web Server是一个用C语言实现的HTTP web server；这两个HTTP web server不是捆绑在一起的。Apache Tomcat包含了一个配置管理工具，也可以通过编辑XML格式的配置文件来进行配置。这篇文章主要介绍Mac环境下，使用Eclipse + Tomcat搭建Java EE开发环境。下载资源前去官网下载安装包，zip和tar.gz均可。安装解压下载的压缩包文件，将文件放置/Library/Tomcat路径。设置权限：sudo chmod 755  /Library/Tomcat/bin/*.sh启动Tomacatsudo sh /Library/Tomcat/bin/startup.sh成功的话会出现：Tomcat started.打开浏览器输入：localhost:8080 。就可以看见Tomcat:关闭Tomcatsudo sh /Library/Tomcat/bin/shutdown.sh创建快捷命令每次按照上述的开启，关闭命令来操作，太麻烦，我们可以使用下列方法创建简洁快捷的命令。创建shell文件cd /usr/local/bin sudo touch tomcat设置权限chmod 777 /usr/local/bin/tomcat 添加shell代码#!/bin/bashcase $1 instart)sudo sh /Library/Tomcat/bin/startup.sh;;stop)sudo sh /Library/Tomcat/bin/shutdown.sh;;restart)sudo sh /Library/Tomcat/bin/shutdown.shsudo sh /Library/Tomcat/bin/startup.sh;;*)echo "Usage: start|stop|restart"esacexit 0使用tomcat starttomcat stoptomcat restart配置为了便于配置Tomcat，我们需要安装Eclipse Tomcat插件 。打开Eclipse，选择菜单中的Preferences，选择Tomcat的版本，安装路径等。第一个Web程序创建      File-&gt;New-&gt;Dynamic Web Project        File-&gt;New-&gt;JSP File 新建JSP文件index.jsp，保存在WebContent根目录下。        添加代码至index.jsp文件  &lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% java.util.Date d = new java.util.Date(); %&gt;&lt;h1&gt;Today's date is &lt;%= d.toString() %&gt; and this jsp page worked!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;运行选中项目，Run As-&gt;Run on Server运行效果：]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
          <tag> tomcat </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[日语-形容词的分类和变形]]></title>
      <url>/blog/japanese-adjective/</url>
      <content type="text"><![CDATA[形容词（Adjective），很多语言中均有的主要词类中的一种。形容词主要用来描写或修饰名词或代词，表示人或事物的性质、 状态、特征或属性，常用作定语，也可作表语、补语或状语。日语中的形容词分为两大类，称为一类形容词和二类形容词（简称，形1和形2）。形容词所表示的事物的属性，一般具有静止的、固定的、永恒的特点。1 形容词分类            类型      规则      示例                  一类形容词（形1）      以い结尾的词      美味しい（おいしい）、暑い（あっい）　              二类形容词（形2）      不以い结尾的词      　元気（げんき）、暇（ひま）      注意特例綺麗い（きれい）、嫌い（きらい）、いっぱい 是形2。2 形容词变形2.1 形容词变否定            类型      规则      示例                  一类形容词（形1）      去い变成くない或者くありません      　１）この料理は美味しくないです。２）この料理は美味しくありません。              二类形容词（形2）      　形2＋ではありません      　この通りはにぎやかではありません。      注意特例いいです的否定形式是よくないです或よくありません。2.2 形容词变过去时            类型      规则      示例                  一类形容词（形1）      　去い变成かった　      　よい-&gt;よかった              二类形容词（形2）      　      　有名です-&gt;有名でした      2.3 形容词变过去否定时            类型      规则      示例                  一类形容词（形1）      　去い变成くなかった　      　よい-&gt;よくなかった              二类形容词（形2）      　      　有名です-&gt;有名ではありませんでした　      示例            时态      一类形容词      变形      二类形容词      变形                  否定      よい      よくない      有名です      有名ではありません              过去时      よい      よかった      有名です      有名でした              过去否定时      よい      よくなかった      有名です      有名ではありませんでした      2.4 形容词变副词            类型      规则      示例                  一类形容词（形1）      　去い变成く　      　多い（おおい）-&gt;多く              二类形容词（形2）      　直接加に　      　きれい-&gt;きれいに      注意名词变副词规则与形2一致。2.5 形容词变て形            类型      规则      示例                  一类形容词（形1）      　去い变成くて　      　広い（ひろい）-&gt;広くて              二类形容词（形2）      　直接加で　      　簡単（かんたん）-&gt;簡単で      注意いい不能用来变形，要用其对应的よい进行变形。名词变て形规则与形2一致。2.6 形容词变ば形            类型      规则      示例                  一类形容词（形1）      　去い变成ければ　      　広い（ひろい）-&gt;広ければ              二类形容词（形2）      　直接加なれば　      　簡単（かんたん）-&gt;簡単なれば      2.7 形容词名词化            类型      规则      示例                  一类形容词（形1）      　去い变成さ　      　多い（おおい）-&gt;多さ              二类形容词（形2）      　直接加さ　      　きれい-&gt;きれいさ      注意きれい-&gt;きれいさ  ❌暇-&gt;暇さ   ❌]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 日语 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS App 上架（Analysis 工具使用）]]></title>
      <url>/blog/apple-app-release-analysis/</url>
      <content type="text"><![CDATA[随着iOS开发的流行，针对iOS开发涉及的方方面面，早有一些公司提供了专门的解决方案或工具。这些解决方案或工具包括：用户行为统计工具（友盟，Flurry，Google Analytics等), App Store销售分析工具（例如App annie)， App crash收集工具（例如Crashlytics)，App测试发布工具（Test Flight）, App Push服务等。这些解决方案或工具节省了iOS开发者大量的开发时间，但是由于相关介绍文章的缺乏，许多开发者都在重复着自己一次又一次重新造轮子。所以将自己使用的相关的第三方服务使用经验，整理成一系列文章，以便广大开发者能够省去大量的重复性工作。用户习惯数据收集了解用户的使用习惯以及相关数据信息，可以更好的帮助开发者调整产品的方向和重点。首先是数据的收集，受工作的影响，选择 百度移动统计 。不得不说，这是一款很符合国人使用习惯的工具。使用方法很简单，接入过程直接根据官方文档。自定义统计事件需要自己在web端逐个添加。而页面访问统计则不需要，只需要在App上将名字传入调用接口即可。百度移动统计不仅仅是做应用统计，也可以做crash分析，游戏统计分析，DSP统计，还有广告营销分析。页面数据的分析，可以帮助开发者很明了的知道用户群体的习惯与流失，有助于产品成长。Crash 数据收集作为上线App，最担心的就是crash数据的收集。Crashlytics 是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。使用Crashlytics的好处      Crashlytics不会漏掉任何应用崩溃信息。在iTunes Connect的后台查看不到任何崩溃信息。但是用户通过微博或者客服电话反馈应用崩溃的情况，在Crashlytics中都可以统计到。        Crashlytics可以像Bug管理工具那样，管理这些崩溃日志。例如：Crashlytics会根据每种类型的Crash的出现频率以及影响的用户量来自动设置优先级。对于每种类型的Crash，Crashlytics除了会像一般的工具提供Call Stack外，还会显示更多相关的有助于诊断的信息，例如：设备是否越狱，当时的内存量，当时的iOS版本等。对于修复掉的Crash日志，可以在Crashlytics的后台将其关掉。        Crashlytics可以每天和每周将崩溃信息汇总发到你的邮箱，所有信息一目了然。  使用  注册使用邮箱在Crashlytic官网注册。稍后会收到官方验证邮件，根据邮件内容及稍后提示一步步操作。  接入工程根据官方接入引导教程，分为使用pod方式和手动下载sdk接入方式。具体的可以根据官方文档来操作。这里主要分享一下自己遇到的问题。1) 忘记添加 Run Script ，这个步骤会导致App无法build成功。2) 重新配置 Crashlytics 之后，需要删除 ~/Library/Caches/com.crashlytics.data/ 和 ~/Library/Caches/com.crashlytics.mac/ 文件夹下的所有文件，重新build。3) 注意配置 Build Settings 中 Debug Information Format 选项将debug和release全部设置成DWARF with dSYM File。4) 如果提示 missing dSYMs ，就需要自行上载文件，具体方法教程 。希望对大家有所帮助。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> application </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Effective Objective-C 2.0 读书笔记 -- 熟悉Objective-C语言]]></title>
      <url>/blog/effective-objc-2-introduction-objc/</url>
      <content type="text"><![CDATA[看到Effective这个词，大家一定会想到《Effective C++》、《Effective Java》等业界名著，那些书里汇聚了多项实用技巧，又系统而深入的讲解了各种编程知识。那么，《Effective Objective-C 2.0》也是如此。作为Mac OS X与iOS应用程序的开发语言，Objective-C作为首选。那么，它有哪些需要注意的呢？起源Objective-C与C++、Java一样，是面向对象的语言，是由Smalltalk演化而来。Smalltalk是消息型语言的鼻祖。消息与函数调用之间的区别看上去就像这样：//Messaging (Objective-C)Object *obj = [Object new];[obj performWith:parameter1 and:parameter2];//Function calling (C++)Object *obj = new Object;obj-&gt;perform(parameter1, parameter2);关键区别在于：使用消息结构的语言，其运行时所应执行的代码由运行环境来决定；而使用函数调用的语言，则由编译器决定。Objective-C是C的“超集”(superset)，所以C语言中的所有功能在编写Objective-C代码时依然适用。理解C语言的内存模型(memory model)，有助于理解Objective-C的内存模型及其“引用计数”(reference counting)机制的工作原理。Objective-C语言中的指针是用来指示对象的。关于使用头文件主要使用 import 关键字。然而，我们在 .h 文件中一般首选使用 @class 关键字，它能“向前声明”一个类。对于不需要知道类细节的情况下我们使用它。否则不会轻易使用 import 来引入整个头文件。过多的引入头文件，会增加编译时间。这就是我们多使用 @class 关键字的直接原因。除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用“向前声明”来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。有时无法使用“向前声明”，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。字面量语法在编写Objective-C程序时，总会用到某几个类，它们属于Foundation框架。虽然从技术上来说，不用Foundation框架也能写出Objective-C代码，但是实际上却经常要用到此框架。这几个类是NSString、NUNumber、NSArray、NSDictionary。从类名上即可看出各自所表示的数据结构。Objective-C以语法繁杂而著称。不过从Objective-C 1.0起，有一种简单的方式能创建NSString 对象。这就是“字符串字面量”(string literal)，其语法如下：NSString *string = @"Effective Objective-C 2.0";字面数值NSNumber *number = [NSNumber numberWithInt:10];//等价于NSNumber *number = @10;更多表示：NSNumber *intNumber = @11;NSNumber *floatNumber = @2.5f;NSNumber *doubleNumber = @3.1415926;NSNumber *boolNumber = @YES;NSNumber *charNumber = @'ABC';字面量语法也适用于下述表达式int x =5;float y = 6.5fNSNumber *expressionNumber = @(x * y);字面量数组NSarray *animals = [NSArray arrayWithObjects:@"cat", @"dog", @"mouse", @"badger", nil];// 等价于NSarray *animals = @[@"cat", @"dog", @"mouse", @"badger"];使用数组NSString *dog = [animals objectAtIndex:1];// 等价于NSString *dog = animals[1];字面量字典NSDictionary *personData = [NSDictionary dictionaryWithObjectsAnsKeys:@"Matt", @"firstName", @"Galloway", @"lastName", [NSNumber numberWithInt:28], @"age", nil];// 等价于NSDictionary *personData = @{@"firstName":@"Matt", @"lastName":@"Galloway", @"age":[NSNumber numberWithInt:28]};使用字典NSString *lastName = [personData objectForKey:@"lastName"];// 等价于NSString *lastName = personData[@"lastName"];可变数组和字典[mutableArray replaceObjectAtIndex:1 withObject:@"dog"];[mutableDictionary setObject:@"Galloway" forKey:@"lastName"];// 等价于mutableArray[1] = @"dog";mutableDictionary[@"lastName"] = @"Galloway";局限性字面量语法有个小小的限制，就是除了字符串以外，所创建出来的对象必须属于Foundation框架才行。如果自定义了这些类的子类，则无法用字面量语法创建其对象。要想创建自定义子类的实例，必须采用“非字面量语法”(nonliteral syntax)。使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable)。若想要可变版本的对象，则需要复制一份：NSMutableArray *mutable = [@[@1, @2, @3, @4] mutableCopy];这么做会多调用一个方法，而且还要再创建一个对象，不过使用字面量语法所带来的好处还是多于上述缺点的。用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。多用类型常量 少用#define预处理指令编写代码时经常要定义常量。掌握了Objective-C与其C语言的基础的人，也许会用这种方法来做：#define ANIMATION_DURATION 0.3上述预处理指令会把源代码中的ANIMATION_DURATION字符串替换为0.3.预处理过程会把碰到的所有ANIMATION_DURATION一律替换成0.3，这样的话，假设此指令声明在某个头文件中，那么所有引入了这个头文件的代码，其ANIMATION_DURATION都会被替换。要解决此问题，应该设法利用编译器的某些特性才对。static const NSTimeInterval kAnimationDuration = 0.3;用此方式定义的常量包含类型信息，其好处的清楚地描述了常量的含义。常用的命名法是：  若常量局限于某”编译单元”(translation unit，也就是“实现文件”，implementation file)之内，则在前面加字母k；  若常量在类之外可见，则通常以类名为前缀。定义常量的位置很重要。在头文件里声明预处理指令，这样会增加常量名称互相冲突的可能性。在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。枚举使用枚举只是一种常量命名方式。某个对象所经历的各种状态就可以定义为一个简单的枚举集(enumeration set)。enum IHConnectionState {	IHConnectionStateDisconnected,	IHConnectionStateConnecting,	IHConnectionStateConnected};默认情况下，枚举起始值为0，以后依次递增，1,2,3…其实还可以我们自己指定枚举值：enum IHConnectionState {	IHConnectionStateDisconnected = 1,	IHConnectionStateConnecting,	IHConnectionStateConnected};也可以定义为位移值：enum UIViewAutoresizing {	UIViewAutoresizing = 0,	UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,	UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,	UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,	UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,	UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,	UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5};关于枚举，Foundation框架中定义了一些辅助的宏，用这些来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型。typedef NS_ENUM(NSUInteger, IHConnectionState) {	IHConnectionStateDisconnected = 1,	IHConnectionStateConnecting,	IHConnectionStateConnected};typedef NS_OPTIONS(NSUInteger, IHPermittedDirection) {	IHPermittedDirectionUp = 1 &lt;&lt; 0,	IHPermittedDirectionDown = 1 &lt;&lt; 1,	IHPermittedDirectionLeft = 1 &lt;&lt; 2,	IHPermittedDirectionRight = 1 &lt;&lt; 3};这些宏的定义如下：#if(__cplusplus &amp;&amp; __cplusplus &gt;= 201103L &amp;&amp; (__has_extension(cxx_strong_enums) || __has_feature(objc_fixed_enum))) || (!__cplusplus &amp;&amp; __has_feature(objc_fixed_enum))	#define NS_ENUM(_type, _name)		enum _name:_type _name; enum _name:_type	#if (__cplusplus)		#define NS_OPTIONS(_type, _name)			type _name; enum:_type	#else		#define NS_OPTIONS(_type, _name)			enum _name:_type _name; enum _name:_type	#endif#else	#define NS_ENUM(_type, _name) _type _name; enum	#define NS_OPTIONS(_type, _name) _type _name; enum#endif第一个#if用于判断编译器是否支持新式枚举。如果不支持，那么就用老式语法来定义枚举。在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac 如何升级 Ruby 版本]]></title>
      <url>/blog/mac-ruby-update/</url>
      <content type="text"><![CDATA[Ruby 是一种面向对象、命令式、函数式、动态的通用编程语言。 在20世纪90年代中期由日本人松本行弘（Matz）设计并开发。 遵守BSD许可证和Ruby License。 它的灵感与特性来自于Perl、Smalltalk、Eiffel、Ada以及Lisp语言。Ruby 可运行于多种平台，如 Windows、MAC OS 和 UNIX 的各种版本。Ruby用于最明显，且和Apple系列的程序员最直接关联的就是Mac的开发环境，直接关联于Cocoapods工具。但是，cocoapods工具与Ruby的版本有一定的关联性，难免不涉及到升级。那么，如何升级最方便快捷呢？这就是rvm大展身手的时候啦。rvm是什么？rvm是ruby版本管理器。为什么要安装rvm呢？因为rvm可以让你拥有多个版本的Ruby，并且可以在多个版本之间自由切换。第一步：安装rvm$ curl -L get.rvm.io | bash -s stable$ source ~/.profile等待终端加载完毕，后输入：$ rvm -v如果能显示版本号,则安装成功。第二步：安装ruby列出ruby可安装的版本信息$ rvm list known安装一个ruby版本$ rvm install 2.3如果想设置为默认版本，可以用这条命令来完成$ rvm use 2.1.4 --default查看已安装的ruby$ rvm list卸载一个已安装ruby版本$ rvm remove 2.3第三步：更换源查看已有的源$ gem source -l显示如下：CURRENT SOURCEShttp://rubygems.org/然后我们需要修改更换源（由于国内被墙），所以要把源切换至淘宝镜像服务器，在终端执行以下命令$ gem update --system$ gem uninstall rubygems-update$ gem sources -r http://rubygems.org/$ gem sources -a https://ruby.taobao.org]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac OS 开发 － 聊聊如何打包dmg文件]]></title>
      <url>/blog/mac-os-archive-app/</url>
      <content type="text"><![CDATA[最近因为博主自己的需求，而App Store上的App不能满足需求，或者是说，想借此机会涉猎一下Mac OS的开发。之前一直臆想iOS开发和Mac OS差不多，实则不然。BTW 推荐一款非Apple官方的App Store，HackStore是一款来自俄罗斯的Mac应用商店，我们可以将自己开发完的App免费发布上去，也是具有审核机制的，博主目前推广自己的ImageHosting，一款图床软件，目前支持七牛云存储。有需求欢迎大家使用，吐槽。 ImageHosting for Mac现在，分享一下，当我们完成Mac开发，release一个.app文件之后，我们应该如何打包成一个dmg文件的方法。言归正传，说到dmg，这个我们熟悉的格式，那么它是怎么生成的呢，跟着接下来的步骤吧。博主将它们分为系统默认和自定义，不过，两者都离不开一个工具 －－ 磁盘工具（Disk Utility）。系统默认打开 磁盘工具 －&gt; 文件 －&gt; 新建映像 －&gt; 来自文件夹的映像资源文件夹内容配置 选择包括 .app 和 Applications 替身 文件夹的路径，也就是上图说的 资源文件夹 路径点击 打开 ，配置相关信息 点击 存储 即可。自定义1 准备资源，包括：背景图片，.app 和 Applications 替身 文件。2 创建一个空的映像文件配置信息3 配置资源 －－ 配置背景图1）打开显示选项2）配置背景图3）隐藏背景图片文件使用mv命令进行重命名$ mv background.tif .background.tif4 配置资源 －－ 拖拽.app 和 Applications 替身5 转换配置转换信息6 效果附言每次自定义类型打包dmg，都需要从零开始，不能使用上一次的未转换时的文件直接替换.app文件。否则，呈现的样式将不是CD样式。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ImageHosting 开源软件的使用说明]]></title>
      <url>/blog/ImageHosting-use-introduction/</url>
      <content type="text"><![CDATA[博主在转战iOS开发以来，一直坚持撰写自己的技术博客。使用Github Pages + Hexo 搭建了属于自己的空间。具体搭建方法可以参考《手把手教 GitHub + Hexo 搭建博客》 。 然而，博客中有很多时候需要使用图片说明，俗话说“一图胜千言”，博主使用 七牛云 做图床，然每次编写博客时需要打开Web版上传图片，甚是繁琐。故此，博主自己编写了一个自己的图片上传软件。软件下载地址：ImageHosting for Mac源代码地址安装遇到提示“不能安装未知来源程序”时，处理方法为，将权限改为“任何来源”即可。软件菜单栏打开软件配置，添加账户信息打开文件选择页，选择文件上传文件上传进度提示上传完成操作提示未添加账户信息提示未选择上传文件提示上传文件成功提示]]></content>
      <categories>
        
          <category> project </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[简单聊聊大小端问题]]></title>
      <url>/blog/memory-big-little-endian/</url>
      <content type="text"><![CDATA[在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。先来看一段代码：#include&lt;stdio.h&gt;union{        unsigned long bits32;        unsigned char bytes[4];}value;int isLittleEndian(){        value.bytes[0] = 0;        value.bytes[1] = 1;        value.bytes[2] = 0;        value.bytes[3] = 0;        return value.bits32 == 256;}int main(){        if( isLittleEndian())                printf("is little endian! ");        else                printf("is big endian! ");        return 0;}所谓的大端模式，是指数据的低位（就是权值较小的后面那几位）保存在内存的高地址中，而数据的高位，保存在内存的低地址中。这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；所谓的小端模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器）。另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如何将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。 下面这段代码可以用来测试一下你的编译器是大端模式还是小端模式：short int x; char x0, x1; x = 0x1122; x0 = ((char*)&amp;x)[0]; //低地址单元 x1 = ((char*)&amp;x)[1]; //高地址单元 若x0=0x11,则是大端; 若x0=0x22,则是小端。上面的程序还可以看出，数据寻址时，用的是低位字节的地址。什么是字节对齐，为什么要对齐?现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。对齐的作用和原因：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。显然在读取效率上下降很多。字节对齐对程序的影响？先让我们看几个例子(32bit，x86环境，gcc编译器)：设结构体如下定义：struct A{    int a;    char b;    short c;};struct B{    char b;    int a;    short c;};现在已知32位机器上各种数据类型的长度如下：char:1(有符号无符号同) short:2(有符号无符号同) int:4(有符号无符号同) long:4(有符号无符号同) float:4    double:8那么上面两个结构大小如何呢?结果是：sizeof(strcut A)值为8sizeof(struct B)的值却是12结构体A中包含了4字节长度的int一个，1字节长度的char一个和2字节长度的short型数据一个,B也一样；按理说A，B大小应该都是7字节。之所以出现上面的结果是因为编译器要对数据成员在空间上进行对齐。上面是按照编译器的默认设置进行对齐的结果，那么我们是不是可以改变编译器的这种默认对齐设置呢，当然可以。例如：#pragma pack (2) /*指定按2字节对齐*/struct C{    char b;    int a;    short c;};#pragma pack () /*取消指定对齐，恢复缺省对齐*/sizeof(struct C)值是8。修改对齐值为1：#pragma pack (1) /*指定按1字节对齐*/struct D{    char b;    int a;    short c;};#pragma pack () /*取消指定对齐，恢复缺省对齐*/sizeof(struct D)值为7。编译器是按照什么样的原则进行对齐的?先让我们看四个重要的基本概念：1.数据类型自身的对齐值：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，单位字节。2.结构体或者类的自身对齐值：其成员中自身对齐值最大的那个值。3.指定对齐值：#pragma pack (value)时的指定对齐值value。4.数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。有了这些值，我们就可以很方便的来讨论具体数据结构的成员和其自身的对齐方式。有效对齐值N是最终用来决定数据存放地址方式的值，最重要。有效对齐N，就是表示“对齐在N上”，也就是说该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序来排放的。第一个数据变量的起始地址就是数据结构的起始地址。结构体的成员变量要对齐排放，结构体本身也要根据自身的有效对齐值圆整(就是结构体成员变量占用总长度需要是对结构体有效对齐值的整数倍，结合下面例子理解)。这样就不难理解上面的几个例子的值了。例子分析：struct B{    char b;    int a;    short c;};假设B从地址空间0x0000开始排放。该例子中没有定义指定对齐值，在笔者环境下，该值默认为4。第一个成员变量b的自身对齐值是1，比指定或者默认指定对齐值4小，所以其有效对齐值为1，所以其存放地址0x0000符合0x0000%1=0。第二个成员变量a，其自身对齐值为4，所以有效对齐值也为4，所以只能存放在起始地址为0x0004到0x0007这四个连续的字节空间中，复核0x0004%4=0,且紧靠第一个变量。第三个变量c，自身对齐值为2，所以有效对齐值也是2，可以存放在0x0008到0x0009这两个字节空间中，符合0x0008%2=0。所以从0x0000到0x0009存放的都是B内容。再看数据结构B的自身对齐值为其变量中最大对齐值(这里是b）所以就是4，所以结构体的有效对齐值也是4。根据结构体圆整的要求，0x0009到0x0000=10字节，（10＋2）％4＝0。所以0x000A到0x000B也为结构体B所占用。故B从0x0000到0x000B共有12个字节，sizeof(struct B)=12;其实如果就这一个就来说它已经满足字节对齐了，因为它的起始地址是0，因此肯定是对齐的。之所以在后面补充2个字节，是因为编译器为了实现结构数组的存取效率，试想如果我们定义了一个结构B的数组，那么第一个结构起始地址是0没有问题，但是第二个结构呢?按照数组的定义，数组中所有元素都是紧挨着的，如果我们不把结构的大小补充为4的整数倍，那么下一个结构的起始地址将是0x000A，这显然不能满足结构的地址对齐了，因此我们要把结构补充成有效对齐大小的整数倍。其实诸如：对于char型数据，其自身对齐值为1，对于short型为2，对于int,float,double类型，其自身对齐值为4，这些已有类型的自身对齐值也是基于数组考虑的，只是因为这些类型的长度已知了，所以他们的自身对齐值也就已知了。同理，分析下面例子：#pragma pack (2) /*指定按2字节对齐*/struct C{    char b;    int a;    short c;};#pragma pack () /*取消指定对齐，恢复缺省对齐*/第一个变量b的自身对齐值为1，指定对齐值为2，所以，其有效对齐值为1，假设C从0x0000开始，那么b存放在0x0000，符合0x0000%1=0；第二个变量，自身对齐值为4，指定对齐值为2，所以有效对齐值为2，所以顺序存放在0x0002、0x0003、0x0004、0x0005四个连续字节中，符合0x0002%2=0。第三个变量c的自身对齐值为2，所以有效对齐值为2，顺序存放在0x0006、0x0007中，符合0x0006%2=0。所以从0x0000到0x00007共八字节存放的是C的变量。又C的自身对齐值为4，所以C的有效对齐值为2。又8%2=0，C只占用0x0000到0x0007的八个字节。所以sizeof(struct C)=8。如何修改编译器的默认对齐值?            1.在VC IDE中，可以这样修改：[Project]      [Settings],c/c++选项卡Category的Code Generation选项的Struct Member Alignment中修改，默认是8字节。      2.在编码时，可以这样动态修改：#pragma pack。注意：是pragma而不是progma。针对字节对齐，我们在编程中如何考虑?如果在编程的时候要考虑节约空间的话,那么我们只需要假定结构的首地址是0，然后各个变量按照上面的原则进行排列即可，基本的原则就是把结构中的变量按照类型大小从小到大声明，尽量减少中间的填补空间。还有一种就是为了以空间换取时间的效率，我们显示的进行填补空间进行对齐，比如：有一种使用空间换时间做法是显式的插入reserved成员：struct A{	char a;	char reserved[3];//使用空间换时间	int b;}reserved成员对我们的程序没有什么意义，它只是起到填补空间以达到字节对齐的目的。当然即使不加这个成员，通常编译器也会给我们自动填补对齐，我们自己加上它只是起到显式的提醒作用。字节对齐可能带来的隐患？代码中关于对齐的隐患，很多是隐式的。比如在强制类型转换的时候。例如：unsigned int i = 0x12345678;unsigned char *p=NULL;unsigned short *p1=NULL;p=&amp;i;*p=0x00;p1=(unsigned short *)(p+1);*p1=0x0000;最后两句代码，从奇数边界去访问unsigned short型变量，显然不符合对齐的规定。在x86上，类似的操作只会影响效率，但是在MIPS或者sparc上，可能就是一个error，因为它们要求必须字节对齐。如何查找与字节对齐方面的问题？如果出现对齐或者赋值问题首先查看:  编译器的big little端设置；  看这种体系本身是否支持非对齐访问；  如果支持，看设置了对齐与否；如果没有，则看访问时需要加某些特殊的修饰来标志其特殊访问操作。ARM下的对齐处理？对齐的使用：1.__align(num)这个用于修改最高级别对象的字节边界。在汇编中使用LDRD或者STRD时，就要用到此命令__align(8)进行修饰限制来保证数据对象是相应对齐。这个修饰对象的命令最大是8个字节限制，可以让2字节的对象进行4字节对齐，但是不能让4字节的对象2字节对齐。__align是存储类修改，它只修饰最高级类型对象，不能用于结构或者函数对象。2.__packed__packed是进行一字节对齐1）不能对packed的对象进行对齐；2）所有对象的读写访问都进行非对齐访问；3）float及包含float的结构联合及未用__packed的对象将不能字节对齐；4）__packed对局部整型变量无影响；5）强制由unpacked对象向packed对象转化是未定义，整型指针可以合法定义为packed。__packed int* p;  //__packed int 则没有意义6）对齐或非对齐读写访问带来问题__packed struct STRUCT_TEST{   char a;   int b;   char c;};    //定义如下结构此时b的起始地址一定是不对齐的       //在栈中访问b可能有问题,因为栈上数据肯定是对齐访问[from CL]//将下面变量定义成全局静态不在栈上 static char* p;static struct STRUCT_TEST a;void Main(){__packed int* q;  //此时定义成__packed来修饰当前q指向为非对齐的数据地址下面的访问则可以p = (char*)&amp;a;          q = (int*)(p+1);      *q = 0x87654321; /*   得到赋值的汇编指令很清楚ldr      r5,0x20001590 ; = #0x12345678[0xe1a00005]   mov      r0,r5[0xeb0000b0]   bl       __rt_uwrite4  //在此处调用一个写4byte的操作函数       [0xe5c10000]   strb     r0,[r1,#0]   //函数进行4次strb操作然后返回保证了数据正确的访问[0xe1a02420]   mov      r2,r0,lsr #8[0xe5c12001]   strb     r2,[r1,#1][0xe1a02820]   mov      r2,r0,lsr #16[0xe5c12002]   strb     r2,[r1,#2][0xe1a02c20]   mov      r2,r0,lsr #24[0xe5c12003]   strb     r2,[r1,#3][0xe1a0f00e]   mov      pc,r14*//*如果q没有加__packed修饰则汇编出来指令是这样直接会导致奇地址处访问失败[0xe59f2018]   ldr      r2,0x20001594 ; = #0x87654321[0xe5812000]   str      r2,[r1,#0]*///这样可以很清楚的看到非对齐访问是如何产生错误的//以及如何消除非对齐访问带来问题//也可以看到非对齐访问和对齐访问的指令差异导致效率问题}有关于内存对齐的问题，可以看看《内存对齐详解》]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 内存 </tag>
        
          <tag> c </tag>
        
          <tag> windows </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac OS 开发 (一) 准备工作]]></title>
      <url>/blog/mac-os-develop-prepare/</url>
      <content type="text"><![CDATA[  程序猿，一个另类的物种。其实很多时候，懒懒的程序猿因为自己的需要，或者是因为使用别人的工具并不满意，而催发出自己解决问题的想法。这个 Mac OS 开发系列，就是因为博主自己写博客是需要上传图片，而目前的 App 并不满意的情况下，决心自己学习，自己开发出喜欢的 App 而诞生的。本文章为该系列开篇，循序渐进，从基础开始。Mac这是开发的基础，至于是 Mac Book Pro，还是iMac，或者Mac mini 就随个人喜欢和实际状况。总之，不建议使用黑苹果。Xcode这是毫无置疑的开发工具，具体如何使用，Google 一大把，这里就不再详说，以后若是博主自己写了相关内容，会后续放上链接跳转。创建启动Xcode，选择Create a new Xcode project，(非首次运行Xcode，从菜单File-New-&gt;Project) 进入工程模版选择界面，选择OSX-&gt;Application-&gt;Cocoa Application配置info.plist Application is agent(UIElement)  字段可以控制App的MainMenu是否显示，Logo在Dock是否显示。Capabilities这里我们重点关注下App Sandbox，Apple现在要求上架Mac AppStore的应用必须使用沙盒，所以发布到Mac商店的应用你必须选择打开。如果你的应用要访问服务器的API接口，必须打开Outgoing Connections。Hardware里面必须选择打开Printing，否则审核不通过。File Accedd:如果你需要让用户选择访问本地的文件，User Selected File 中选择读/写权限。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[配色和排版（基础篇）]]></title>
      <url>/blog/design-harmonize-colours/</url>
      <content type="text"><![CDATA[  在什么样的团队就能成为什么样的人来到公司已经有一段时间了，在这段时间里，自我感觉是快速成长的。今天，终于决定扯来公司这张虎皮来给自己镀镀金，这里主要分享一下公司设计团队的设计技巧，希望对大家有帮助。基本颜色  暖色  冷色  中性色以上色块示例只是日常使用中的基础颜色，各种颜色可以延伸出较多的相近色。这个需要根据内容主题来搭配颜色。所有的颜色搭配都是为了突出和强调主题。颜色搭配基础  暖色暖色系的搭配包括深色+浅色，也可以使用少量冷色衬托。  冷色冷色系的搭配包括深色+浅色，也可以使用少量暖色衬托。  对比色对比色是深色和浅色，暖色和冷色的搭配。  中性色中性色可以搭配冷色、暖色。图文排版基础  左对齐左对齐分两种：1）文字位于整张图片左侧，图片内容居右。2）文字位于整张图片中间，但文字还是左对齐。  居中对齐居中对齐是文字位于整张图片中间，背景加入素材作为衬托。  右对齐文字位于整张图片右侧，图片内容居左。总结配色是否协调需要长期观摩。排版需要注意适当的留白。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> design </tag>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Xcode 常用插件]]></title>
      <url>/blog/xcode-plugin-list/</url>
      <content type="text"><![CDATA[  工欲善其事，必先利其器这里主要罗列一些常用的 Xcode 插件。  BBUncrustify代码格式化https://github.com/benoitsan/BBUncrustifyPlugin-Xcode  Backlight光标选中行高亮https://github.com/limejelly/Backlight-for-XCode  HighlightSelectedString代码变量选中高亮https://github.com/keepyounger/HighlightSelectedString  VVDocumenter快捷注释https://github.com/onevcat/VVDocumenter-Xcode  KSImageNamed根据图片名，输入代码时图片预览https://github.com/ksuther/KSImageNamed-Xcode]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[谈谈iOS App打包发布]]></title>
      <url>/blog/ios-app-distribution/</url>
      <content type="text"><![CDATA[来到 ZAKER 工作已经有一段时间了，博主也开始了自己的 iOS 开发之旅，因为博主是自学的，难免有些知识点的遗漏，很巧的是，关于App打包发布就是其中之一。而在最近，机缘巧合之下，需要自己打包上传到公司自己服务器用来做demo演示。在此，博主分享一下有关iOS App打包的过程。1.安装发布证书  自己去Apple开发者中心配置  找其他已经有证书的小伙伴导出p12文件2.设置SchemeXcode-&gt;Product-&gt;Scheme-&gt;Edit Scheme3.设置软件版本号版本号格式：数字.数字-字符(驼峰式).数字示例：1.1-beta.1 , 1.1.1-beta说明：版本号从0开始，不过一般版本号为0的数字省略。4.Archive注意：选择真机或者Generic iOS DeviceProduct-&gt;Archive5.Export6.安装企业应用证书7.上传到ZAKER服务器]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> application </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[打造自己的 Mac 环境]]></title>
      <url>/blog/custom-myself-develop-tool/</url>
      <content type="text"><![CDATA[作为一个程序猿，每天接触最多的就是自己的“女朋友”，那么猿们肯定都有自己的一套撸具，我们都会根据自己的喜好配置自己的万能功能。无非是对于terminal的使用与配置。文章主要分享记录博主自己搭建环境的过程。清单罗列一下博主 Mac 上的盆友们，顺便来个简要介绍。1）开发类  Xcode：苹果官方开发工具  PaintCode：可视化设计转代码神器  GitX：git可视化工具，开源  SimPholders：直接打开模拟器App文件神器2）工具类  奇妙清单：云记事本  Beyond Compare：文件比较神器，付费  Charles：网络抓包神器，付费  Go2Shell：命令行打开工具，可以实现Finder下打开terminal  Navicat Premium：数据库可视化工具，付费  Chrome：谷歌浏览器  The Unarchiver：文件解压缩工具  DaisyDisk：磁盘清理工具，付费  MindNode Pro：思维导图，付费3）文本编辑类  Sublime Text：文本编辑神器  Pages：苹果官方办公工具  Mou：markdown语法文本编辑器4）阅读类  Reeder：博客订阅  Pocket：文章收藏  Dash：离线开发文档阅读  Skim：PDF阅读，开源  CHM View：chm文件阅读5）图像类  Acorn：轻量级PhotoShop  ScreenFlow：录屏，生成视频文件，付费  licecap：录屏，生成.gif文件  Snip：截图Sublime Text配置命令打开 Sublime Textln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" /usr/local/bin/subl之后使用时，使用如下命令即可打开：$ subl实际上这就是一个软链接的应用。JSON代码格式化网上有很多工具可用，博主自己现在使用一个 Tidy 的插件，效果还是蛮不错的。1.打开链接https://gist.github.com/charsdavy/cd2324f9483ff83425bbacf85a6ea9be，下载文件。2.将解压后的文件夹中的 prettify_json.py 和 tidy_xml.py 问价拷贝到 ~/Library/Application Support/Sublime Text 2/Packages/User 路径3.打开 Sublime Text，从菜单中打开“Key-Bindings Default”文件4.添加快捷键{ "keys": ["ctrl+shift+x"], "command": "tidy_xml" },{ "keys": ["ctrl+shift+j"], "command": "prettify_json" }, 5.使用全选，然后按下 Control + shift + j 键即可。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mac 中 Git 命令自动补全]]></title>
      <url>/blog/git-auto-completion-mac/</url>
      <content type="text"><![CDATA[转战iOS开发已经有一段时间了，现在使用Mac，对于命令行的使用，真的是越来越喜欢，但是，在使用Git命令的时候，不能使用【Tab】来自动补全，为此，博主找寻方法，来完善Git命令补全功能。本文分享此功能实现。安装Homebrew使用Homebrew安装的git，如何安装Honebrew及其使用在此就跳过，烦请自行查看(http://brew.sh/index_zh-cn.html)。安装bash-completion$ brew list查看是否已经安装了”bash-completion”，如果没有，继续往下看：$ brew install bash-completion#####安装完成之后######$ brew info bash-completion 　#####下边这句话很重要#######==&gt; CaveatsAdd the following lines to your ~/.bash_profile:if [ -f $(brew --prefix)/etc/bash_completion ]; then. $(brew --prefix)/etc/bash_completionfi将if…then…那一句添加到~/.bash_profile（如果没有该文件，新建一个）获取git-completion.bash将git源码clone到本地$ git clone https://github.com/git/git.git找到”contrib/completion/”目录下的git-completion.bash，将该文件拷贝到~/下并重命名为.git-completion.bash$ cp git-completion.bash ~/.git-completion.bash配置git-completion.bash在~/.bash_profile文件（该目录下如果没有，新建一个）中添加下边的内容source ~/.git-completion.bash重启终端即可$ git --h[tab][tab]--help        --html-path]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> git </tag>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[在Finder中打开终端]]></title>
      <url>/blog/finder-open-terminal/</url>
      <content type="text"><![CDATA[在Mac中，如果要在终端中进入在Finder中打开的目录，常用的方法是在终端中先敲入一个”cd “，然后在Finer中选中文件夹拖入到终端中，再回车即可实现。不过这样做终究还是麻烦了点，下面介绍如何直接在Finder中直接操作。在终端里打开Finder很简单，使用open .即可系统设置在Finder打开terminal这个功能其实是有的，但是系统默认没有打开，我们可以通过如下方法将其打开进入系统偏好设置-&gt;键盘-&gt;快捷键-&gt;服务。在右边新建位于文件夹位置的终端窗口上打勾。如此设置后，在Finder中右击某文件，在出现的菜单中找到服务，然后点击新建位于文件夹位置的终端窗口即可。Go2Shell在Mac App Store中下载 Go2Shell 软件，下载后在”应用程序“里找到Go2Shell软件，按住Cmd键，将其拖动到Finder的工具栏上。打开Go2Shell设置的方法是：在终端中输入命令 open -a Go2Shell --args config，然后回车。优点：可以不需要选中文件夹，直接点Go2Shell按钮就可以打开终端。缺点：每次都是在新的终端窗口中打开，而不是在新的终端标签中打开。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> mac </tag>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Git可视化比较工具P4Merge]]></title>
      <url>/blog/git-diff-p4merge/</url>
      <content type="text"><![CDATA[在转战Mac之后，BeyondCompare 不再那么容易免费使用，今天终于让我找到了一个Git的GUI比较工具P4Merge，免费的，支持中文，还不错，推荐一下下载打开这个链接: perforce-visual-merge-and-diff-tools，点左上角的 FREE DOWNLOAD P4Merge , 找到 Perforce Clients 中的 P4Merge: Visual Merge Tool 项，在右边的第二行选择Mac OS 10.6+ (64bit） ，点下面橙色的 Accept and Download，选择跳过 Skip Registration ，就会开始下载了。下载到P4V.dmg文件后，双击打开，拖动P4Merge到Application文件夹上就可以完成安装了。配置git config --global diff.tool p4mergegit config --global difftool.p4merge.cmd /Applications/p4merge.app/Contents/MacOS/p4mergegit config --global difftool.p4merge.cmd "/Applications/p4merge.app/Contents/Resources/launchp4merge \$LOCAL \$REMOTE"如果直接复制原文的代码，运行上面的代码时会提示： error: key does not contain a section: -global 跟别人的命令比较一下，就会发现应该是—global（要两个短横连在一起的），原文的短横线有问题现在敲git difftool命令执行时，会提示：/usr/libexec/git-core/mergetools/p4merge: line 2: p4merge: command not found原因是路径还需要再配置一下，如下git config --global difftool.p4merge.path "/Applications/p4merge.app/Contents/Resources/launchp4merge"以后想要比较Git中的代码时，敲git difftool filepath 即可Linux、Windows下也都可以使用这个工具进行比较代码，只是需要另行配置了。P4Merge除了有比较功能，还有合并功能，怎么配置可以借鉴下面给出的参考链接。另外还有一个可视化比较工具meld，据说也不错，有时间试试.参考《Mac os x下git merge工具P4Merge的安装与配置》《Git 用户信息》《Setup p4merge as a visual diff and merge tool for git》]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> git </tag>
        
          <tag> 工具 </tag>
        
          <tag> mac </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[说说升级Xcode中SDK与真机调试版本]]></title>
      <url>/blog/xcode-update-sdk-devicesupport/</url>
      <content type="text"><![CDATA[相信作为一名iOS开发者，每当WWDC开始，iOS升级时，那种切肤之痛，是只有开发者才能体会而又无言的一种沉默抗议。Apple很残暴的将MAC OS、iOS、Xcode牢固的捆绑在一起。如果需要真机调试，那么Xcode的SDK版本一定不能低于真机，Xcode版本的安装有MAC OS的版本要求，这样一来，只要升级一下iOS版本，那么恭喜你，很有可能你需要升级MAC OS和Xcode。而对于动辄数十个G的文件，在天朝的绿色网络保护下，是一件多么伤神的事情啊。更甚的是，现在的MAC OS系统越来越不好用了，我很是怀恋之前的版本，无奈胳膊拗不过大腿。现在，终于有了可行的办法，能够解决上述神伤，在此总结分享给大家。下载Xcode历史版本Apple提供了官方下载地址：https://developer.apple.com/download/more打开链接，登录账户，即可看见下图所示：根据左侧栏，筛选自己需要的软件，下载即可。升级Xcode真机调试版本1）在一台已经安装好的高版本中，获取需要的文件。2）替换自己的电脑上的Xcode对应的文件。步骤如下：1）找到应用程序，显示包中的文件2）进入路径/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport拷贝需要的文件，如 9.3文件夹。粘贴至自己电脑对应的位置即可。升级Xcode的SDK延续上述步骤，只需要进入文件路径/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs拷贝SDKs文件夹，粘贴至自己电脑相对应位置即可。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hexo 博客功能扩展 - 添加回滚到顶部按钮]]></title>
      <url>/blog/hexo-extern-scroll-top/</url>
      <content type="text"><![CDATA[承接前文《手把手教 GitHub + Hexo 搭建博客》 ，对现有博客进行功能扩展。因为随着文章的发表，页面变得很长，长文章也较多，偶尔需要立即回到顶部，这个时候，就需要添加新的快捷方式。于是乎，诞生了这个功能扩展。文章主要分享实现滚动到顶部按钮功能。** 以Yilia主题为例，不同的主题可以类比找到对应的文件地址。 **添加html代码打开文件夹/themes/Yilia/layout/_partial在此文件夹下，新建文件totop.ejs，并向其中加入如下代码：&lt;div id="totop" style="position:fixed;bottom:50px;right:30px;cursor: pointer;"&gt;&lt;a title="返回顶部"&gt;&lt;img src="/img/scrollup.png"/&gt;&lt;/a&gt;&lt;/div&gt;注意： 文件的编码格式为utf-8。添加js代码打开文件夹/themes/Yilia/source/js，新建文件totop.js，将如下代码复制其中：(function($) {    // When to show the scroll link    // higher number = scroll link appears further down the page    var upperLimit = 1000;    // Our scroll link element    var scrollElem = $('#totop');    // Scroll to top speed    var scrollSpeed = 1600;    // Show and hide the scroll to top link based on scroll position    scrollElem.hide();    $(window).scroll(function () {        var scrollTop = $(document).scrollTop();        if ( scrollTop &gt; upperLimit ) {            $(scrollElem).stop().fadeTo(300, 1); // fade back in        }else{            $(scrollElem).stop().fadeTo(300, 0); // fade out        }    });    // Scroll to top animation on click    $(scrollElem).click(function(){        $('html, body').animate({scrollTop:0}, scrollSpeed); return false;    });})(jQuery);可以对upperLimit和scrollSpeed参数进行修改，控制显示位置和回滚速度。添加文件引用打开文件/themes/Yilia/layout/_partial/after_footer.ejs，在文件的末尾添加以下两行代码：&lt;%- partial('totop') %&gt;&lt;script src="&lt;%- config.root %&gt;js/totop.js"&gt;&lt;/script&gt;资源将下面的图片复制到/themes/Yilia/source/img目录下，文件名为scrollup.png，页面足够长时，就可以看见按钮出现。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> hexo </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[简单聊聊 iOS 中的网络加密]]></title>
      <url>/blog/ios-network-encrypt/</url>
      <content type="text"><![CDATA[公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。导言公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。但是不论在任何时候，都应该将服务置于HTTPS上，因为它可以避免中间人攻击的问题，还自带了基于非对称密钥的加密通道。HTTPS交互原理简答说，HTTPS 就是 HTTP协议加了一层SSL协议的加密处理，SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA（如GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。HTTPS 客户端与服务器交互过程：1）客户端发送请求，服务器返回公钥给客户端；2）客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器；3）服务器收到后，利用私钥解开得到对称加密秘钥，保存；4）之后的交互都使用对称加密后的数据进行交互。证书简单说，证书有两种，一种是正经的：CA颁发的证书一种是不正经的：自己生成签发的证书我们需要做什么如果遇到正经的证书，我们直接用AFNetworking 直接请求就好了，AFNetworking 内部帮我们封装了HTTPS的请求方式，但是大部分公司接口都是不正经的证书，这时需要我们做以下几步：1）将服务器的公钥证书拖到Xcode中2）修改验证模式manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];原理简单来说，就是你本可以修改AFN这个设置来允许客户端接收服务器的任何证书，但是这么做有个问题，就是你无法验证证书是否是你的服务器后端的证书，给中间人攻击，即通过重定向路由来分析伪造你的服务器端打开了大门。AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];securityPolicy.allowInvalidCertificates = YES;解决方法AFNetworking是允许内嵌证书的，通过内嵌证书，AFNetworking就通过比对服务器端证书、内嵌的证书、站点域名是否一致来验证连接的服务器是否正确。由于CA证书验证是通过站点域名进行验证的，如果你的服务器后端有绑定的域名，这是最方便的。将你的服务器端证书，如果是pem格式的，用下面的命令转成cer格式openssl x509 -in &lt;你的服务器证书&gt;.pem -outform der -out server.cer然后将生成的server.cer文件，如果有自建ca，再加上ca的cer格式证书，引入到app的bundle里，AFNetworking在AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate];或者AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey];情况下，会自动扫描bundle中.cer的文件，并引入，这样就可以通过自签证书来验证服务器唯一性了。AFSecurityPolicy三种验证模式      AFSSLPinningModeNone这个模式表示不做SSL pinning，只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书就不会通过。        AFSSLPinningModeCertificate这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。        AFSSLPinningModePublicKey这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。  参考http://www.jianshu.com/p/75d96b72bfb1]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 框架 </tag>
        
          <tag> 安全 </tag>
        
          <tag> 网络 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[State 模式]]></title>
      <url>/blog/state-pattern/</url>
      <content type="text"><![CDATA[State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.文章主要分享State模式相关内容.定义不同的状态,不同的行为;或者说,每个状态有着相应的行为.何时使用State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用 if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.参考网址：http://www.jdon.com/designpatterns/designpattern_State.htm举例来说：一个人具有生气，高兴和抓狂等状态，在这些状态下做同一个事情可能会有不同的结果，一个人的心情可能在这三种状态中循环转变。使用一个moodState类表示一个人的心情，使用mad,Happy,Angry类代表不同的心情。使用UML图表示如下所示：适用性：在下面的两情况下均可以使用State模式：      一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变它的行为。        一个操作中含有庞大的多分支的条件豫剧，并且这些分支依赖于该对象的状态，这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，State模式将每一个条件分支放入一个单独的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。  参与者：      Context(环境，Person)定义客户感兴趣的类。        State(Moodstate)：定义一个接口以封装与Context的一个特定状态相关的行为        ConcreteState Subclasses(具体状态子类，如Angry)每一个子类实现一个与Context的状态相关的行为。  他们的协作关系是：      Context将于状态相关的请求委托给当前的ConcreteState对象处理。        Context可将自身作为一个参数传递给处理该请求的状态对象，这使得状态对象在必要的时候可访问Context。        Context是客户使用的主要接口，客户可用状态对象来配置一个Context，一旦一个Context配置完毕，他的客户不再需要直接与状态对象打交道。        Context或者ConcreteState子类都可以决定哪个状态是另外那个状态的后继者，以及是在何种条件下进行状态转换。  相应的代码：MoodState代码：package state;public interface MoodState{	public void doSomething();	public void changeState();}Angry代码:package state;public class implements MoodState{	Person p;	public Angry(Person p){		this.p = p;	}	public void doSomething(){		System.out.println("I'm angry!");	}	public void changeState(){		p.setState(new Happy(p));	}}Happy代码：package state;public class Happy implements MoodState{	Person p;	public Happy(Person p){		this.p = p;	}	public void doSomething(){		System.out.println("I'm happy!");	}	public void changeState(){		p.setState(new Mad(p));	}}Mad代码：package state;public class Mad implements MoodState{	Person p;	public Mad(Person p){		this.p=p;	}	public void doSomething(){		System.out.println("I'm Mad");	}	public void changeState(){		p.setState( new Angry(p));	}}Person代码：package state;public class Person{	private MoodState state;	public Person(){		state = new Mad(this);	}	public void setState(MoodState state){		this.state = state;	}	public void doSomething(){		state.doSomething();		state.changeState();	}}Client代码：package state;public class Client{	public static void main(String[] args){		Person p = new Person();		for(int i=0;i&lt;10;i++)			p.doSomething();	}}总结状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，使得状态转换显式化并且可以被共享。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> 设计模式 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Git 使用 - 远程操作]]></title>
      <url>/blog/git-using-remote/</url>
      <content type="text"><![CDATA[Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop 的项目也迁移到了 Git 上。Git有很多优势，其中之一就是远程操作非常简单。但是，Git也是一把双刃剑，使用得当，将会尽享Git的便利与强大。本文将主要介绍几个常用的Git远程操作命令。git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。$ git clone &lt;版本库的网址&gt;比如，克隆Weibo的版本库。$ git clone https://github.com/charsdavy/iWeibo.git该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。$ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git $ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/SSH协议还有另一种写法：$ git clone [user@]example.com:path/to/repo.git/通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机。$ git remoteorigin使用-v选项，可以参看远程主机的网址。$ git remote -vorigin  git@github.com:charsdavy/iWeibo.git (fetch)origin  git@github.com:charsdavy/iWeibo.git (push)上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。$ git clone -o Weibo https://github.com/charsdavy/iWeibo.git$ git remoteWeibo上面命令表示，克隆的时候，指定远程主机叫做Weibo。      git remote show命令加上主机名，可以查看该主机的详细信息。    $ git remote show &lt;主机名&gt;        git remote add命令用于添加远程主机。    $ git remote add &lt;主机名&gt; &lt;网址&gt;        git remote rm命令用于删除远程主机。    $ git remote rm &lt;主机名&gt;        git remote rename命令用于远程主机的改名。    $ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;  git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。$ git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回origin主机的master分支。$ git fetch origin master所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。$ git branch -rorigin/master$ git branch -a* master  remotes/origin/master上面命令表示，本地主机的当前分支是master，远程分支是origin/master。取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。$ git checkout -b newBrach origin/master上面命令表示，在origin/master的基础上，创建一个新分支。此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。$ git merge origin/master# 或者$ git rebase origin/master上面命令表示在当前分支上，合并origin/master。git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。$ git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。$ git pull origin next上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。$ git fetch origin$ git merge origin/next在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。Git也允许手动建立追踪关系。git branch --set-upstream master origin/next上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。$ git pull origin上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。$ git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用–rebase选项。$ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。$ git pull -p# 等同于下面的命令$ git fetch --prune origin $ git fetch -pgit pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;注意：分支推送顺序的写法是:，所以`git pull`是:，而`git push`是:。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。$ git push origin master上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。$ git push origin :master# 等同于$ git push origin --delete master上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。$ git push origin上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。$ git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。$ git push -u origin master上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。$ git config --global push.default matching# 或者$ git config --global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。$ git push --all origin上面命令表示，将所有本地分支都推送到origin主机。如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。$ git push --force origin 上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。最后，git push不会推送标签（tag），除非使用–tags选项。$ git push origin --tagsgit fetch最近工作上有点忙，不免回家之后还需要办公，可是工作用公司的设备。回家之后只能使用自己的MAC。不过，如何在两台设备同步代码就成了问题。需要能够在一个文件夹不断的同步新的分支，而不会产生新的文件夹。这里，分享博主的解决办法。1）从远端获取分支$ git fetch origin2）基于远端分支创建本地分支$ git checkout -b local_branch_name origin/remote_branch_name这样，就会在本地创建一个基于远端分支的分支。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> git </tag>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[七牛云存储应用]]></title>
      <url>/blog/qiniu-using/</url>
      <content type="text"><![CDATA[七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。前言七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。七牛云官网http://www.qiniu.com/ ，进入开发者平台，浏览了所有的开发指南，可是却是没有具体清晰的操作步骤。今天自己试着通过网络，实现了使用七牛云存储文件。现在，将操作步骤记录如下。准备工作1.注册七牛云账号。2.创建空间。3.获取Access Key。4.获取Secret Key。5.获取官方SDK（https://github.com/qiniu/objc-sdk ）。导入工程1.打开Xcode创建Project。2.从获取的官方SDK导入库，如下图3.获取token这一步，网上大家都说得很简单，在这一步卡壳许久。现在说说自己使用的方法：1）获取服务器代码，编译工程，以备生成token。服务器代码地址：https://github.com/CharsDavy/QiNiuGenertorToken2）使用Eclipse导入上述服务器代码在Test.java文件中，修改自己的空间名称，Access Key和Secret Key。运行程序，即可获得token。这种方式生成的token的有效期是可以自己设定的，如果你想，设定1000年过期也是可以的。4.使用代码上传文件#import &lt;QiniuSDK.h&gt;...    NSString token = @"从服务端SDK获取";    QNUploadManager *upManager = [[QNUploadManager alloc] init];    NSData *data = [@"Hello, World!" dataUsingEncoding : NSUTF8StringEncoding];    [upManager putData:data key:@"hello" token:token        complete: ^(QNResponseInfo *info, NSString *key, NSDictionary *resp) {        NSLog(@"%@", info);        NSLog(@"%@", resp);    } option:nil];...调试工程导入之后，可能会出现以下几种可能的错误。1.若报 Undefined symbols for architecture x86_64: "_crc32", referenced from:，项目中需导入 libz.dylib。(Build Phases—Link Binary With Libraries)2.若报"_res_9_ninit", referenced from: _setup_dns_server in QNResolver.o等，1）项目中需导入 libresolv.dylib或libresolv.9.dylib。(Build Phases— Link Binary With Libraries)；2）或 (Build Settings— Linking— Other Linker Flags) 添加 -lresolv选项。3.若报 Thread 1: EXC_BAD_ACCESS(code=1,address=0x180f4beb8)类似错误，将 QN打头的都设置 arc (Build Phases — Compile Sources)4.可能需要修改部分内容，如 #import &lt;AFNetworking/AFNetworking.h&gt;改为 #import "AFNetworking.h"小结以上就是本人在工程中使用七牛云进行文件云存储的过程，本文中使用的仅仅是上传文件，更多其他操作功能请参照官方文档。最后，附上一个使用七牛云存储的软件，源码地址：https://github.com/CharsDavy/MyNotes其实，对于获取token来完成上载操作，也可以参考官方文档，地址http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> 存储 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[手把手教 GitHub + Hexo 搭建博客]]></title>
      <url>/blog/build-blog-by-hexo/</url>
      <content type="text"><![CDATA[本文章主要介绍使用hexo框架搭建博客，使用GitHub免费托管自己的博客代码，并使用GitHub Pages提供的免费服务。换句话说，就是使用免费资源搭建属于自己的博客网站。前言在很久以前，博主就想着要有自主的博客专栏或者网站。经历了博客园这个需要所谓的编辑审核，一直比较困惑，这些编辑是什么出身，怎么知道技术博客的价值性。接下来找到了开源中国，这个可以自由发言的地方。不过，不知道是不是受众面不广，访问量都不是很理想。再然后就来自己动手开始搭建博客。从手写html发布文章，到使用jekyll，最后到了hexo阵营。终于，有种找到家的赶脚。hexo不仅搭建方便，而且在后续的功能扩展以及文章发布都是非常方便的。不仅如此，还可以本地调试，预览效果。最方便的是支持markdown编写文档。本文就是介绍如何安装使用hexo搭建属于自己的博客。从此不再担心投稿被莫名拒绝。可以在自己的一亩三分地讲述着自己的故事。环境准备安装GitMAC OS X 是自带Git命令行工具。Windows 可以安装Git Bash。安装Node.js前往官网地址，根据教程安装即可。安装hexo$ sudo npm install hexo-cli -g使用hexo# 创建hexo文件夹$ mkdir hexo# 进入hexo文件夹$ cd hexo# 初始化hexo$ hexo init# 安装依赖包$ npm install# 本地查看# 先运行下面的命令，再在浏览器输入localhost:4000即可$ hexo server# 问题：执行hexo server提示找不到该指令# 解决办法：在Hexo 3.0 后server被单独出来了，需要安装server，安装的命令如下：$ npm install hexo -server --save生成静态网站$ hexo generate目录结构.├── .deploy #需要部署的文件├── node_modules #Hexo插件├── public #生成的静态网页文件├── scaffolds #模板├── source #博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts #草稿| └── _posts #文章├── themes #主题├── _config.yml #全局配置文件└── package.json全局配置 _config.yml# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title:  #标题subtitle:  #副标题description:  #站点描述，给搜索引擎看的author:  #作者email:  #电子邮箱language: zh-CN #语言# URL #链接格式url:  #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮  enable: true #是否启用  line_number: true #显示行号  tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy:  type: git  repo: github创库地址.git  branch: master注意  配置文件的冒号“:”后面有一个空格  repo: github创库地址.githexo命令行使用常用命令：hexo help #查看帮助hexo init #初始化一个目录hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成网页，可以在 public 目录查看整个网站的文件hexo server #本地预览，'Ctrl+C'关闭hexo deploy #部署.deploy目录hexo clean #清除缓存，强烈建议每次执行命令前先清理缓存，每次部署前先删除 .deploy 文件夹简写：hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy使用GitHub注册账号前往GitHub官网注册账号，按照网站提示注册。创建代码仓库这个仓库的名字需要和你的账号对应。格式: yourname.github.io具体使用GitHub可以参考：《GitHub 使用》编辑文章# 新建文章$ hexo new "标题"在 _posts 目录下会生成文件标题.md---title: Hello Worlddate: 2015-07-30 07:56:29 #发表日期，一般不改动categories: hexo #文章文类tags: [hexo,github] #文章标签，多于一项时用这种格式---正文，使用Markdown语法书写编辑完后保存, 预览$ hexo serverhexo部署执行下列指令完成部署hexo generatehexo deploy以下提示说明部署成功[info] Deploy done: githexo插件使用添加rss订阅功能安装hexo-generator-feed插件$ npm install hexo-generator-feed --save安装完后，会在node_modules目录下生成hexo-generator-feed目录。然后将其配置到根目录的_config.yml# Extensions## Plugins: http://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed: #可选项，可以不填type: atompath: atom.xmllimit: 20最后，在你当前主题下的_config.yml下，添加RSS订阅链接即可，这里博主用的是Yilia主题，subnav下添加rss：# SubNavsubnav:rss: "/atom.xml"至此，博客搭建完成，基本使用介绍完毕。希望对大家有所帮助。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> hexo </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[你和日本的距离只差5mm]]></title>
      <url>/blog/chopsticks-using/</url>
      <content type="text"><![CDATA[世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。日本在使用筷子的时候，也有很大的「箸（はし）」学问，有什么禁忌是千万不要犯的呢？！✖握り箸（にぎりばし）——握筷子，这是初级错误，一般来说只有初学使用筷子的孩子和外国人会犯。✖クロス箸——两根筷子交叉，很不雅观。✖迷い箸（まよいばし）——拿起筷子犹豫不决，前后左右晃动，似乎在挑拣食物。✖移り箸（うつりばし）——前面食物的味道还残留在口中，就取另外的食物。✖こじ箸——在碗底翻腾取食物。✖寄せ箸（よせばし）——用筷子拨动、移动盘子。✖刺し箸（さしばし）——用筷子扎取食物（对于不会用筷子的人来说，吃丸子的时候不这样会很难~）。✖涙箸——“泪筷子”，这个名称很形象，筷子夹起食物滴滴答答的流汤。✖かき箸——把碗放在嘴边，用筷子把食品拨拉到嘴里。✖込み箸（こみばし）——筷子进嘴塞食。✖持ち箸（もちばし）——把筷子拿在手里，端起碗吸食，日本农民 。✖ねぶり箸——把筷子放在嘴里吸允。✖渡し箸（わたしばし）——把筷子架在碗上。✖叩き箸（はたきばし）——用筷子敲碗催促他人（这样真的很招人烦）。✖指さし箸（ゆびさしばし）——用筷子指人（用手指人也是很不好的）。✖直箸（じかばし）——有公筷不用，直接使用自己的筷子在盘内取食。✖立箸——把筷子插在米饭碗里。✖そろえ箸——用舌头、嘴唇或者其他平面整理、理顺两根筷子（为什么不用手，这样多累啊）。✖探り箸（さぐりばし）——用筷子在盘子里搅拌、寻找食物（瞄准一个直接吃得了，在那ba la啥）。✖せせり箸——把筷子当牙签使（小花儿表示：她的牙缝没这么大）。✖かみ箸——用牙齿咬筷子。✖振り箸（ふりばし）——甩手抖落筷子上的汤汁（轻微洁癖真的有点接受不了）。✖洗い箸（あらい）——在碗盘汤中涮洗筷子。✖箸渡し（はしわたし）——用筷子向他人的筷子递送食品。✖そら箸——筷子靠近了盘子，却又不取食品。以上是25条使用筷子的禁忌。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 日语 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS 并发概念浅析]]></title>
      <url>/blog/ios-simultaneously/</url>
      <content type="text"><![CDATA[并发（concurrency）是一个常用且较好的解决APP的流畅度方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。本文主要分享对一些易混淆概念的理解。前言在进行iOS开发过程中，我们常会遇到网络请求、复杂计算、数据存取等比较耗时的操作，如果处理不合理，将对APP的流畅度产生较大影响。除了优化APP架构，并发（concurrency）是一个常用且较好的解决方法，但并发涉及串行、并发、并行、同步、异步、多线程、GCD、NSOperation和NSOperationQueue等诸多容易混淆的概念。接下来，主要分享对一些易混淆概念的理解。一、线程和任务线程（thread） 和任务（task）是其他并发概念的基础，因此也是首要需理清的概念，以下是其要点，详细可参考Thread (computing)和Task (computing)。1）任务（task）a）任务（task）是从程序中划分出来，可以独立执行的代码片段；b）任务间可以添加依赖关系，如B任务依赖A任务，taskB.addDependency(taskA)，这意味着B任务的执行以A任务完成为前提。需要注意的是一个任务是否可以添加依赖，完全取决于任务封装类和其相关管理类的具体实现，GCD不支持任务依赖，NSOperationQueue就支持任务依赖。下面的代码是对一个任务的简单封装，并支持任务间的依赖。//Task是一个任务的简单封装类class Task {    let taskBlock: () -&gt; ()    var dependencies = [Task]()     init(block: () -&gt; ()) {        taskBlock = block    }     func addDependency(task: Task) {        dependencies.append(task)    }}//初始化两个自定义任务var taskA = Task(){    //自定义任务A，自定义需要执行的代码    //...}var taskB = Task(){    //自定义任务B，自定义需要执行的代码    //...}//添加依赖关系taskB.addDependency(taskA)2）线程（thread）a）线程（thread）是代码执行的独立路径，一条线程只能同时执行一行代码（一行代码，其实就是一条处理器命令）。b）线程中代码管理是以任务（task）为单位，一条线程逐行执行一个任务中的代码（任务可以取消），完成后再逐行执行下一个任务中的代码。c）一条线程跳出一个任务的执行，即意味着这个任务的完成。因此，一条线程不能执行taskA一段时间后，还未完成就开始执行taskB，然后又返回执行taskA（这其实是单线程内的并发，与单核处理器的并发概念相同，具体实践中不存在线程内并发）。二、概念释疑1）并行（parallelism）和并发（concurrency）并发和并行都是指多个任务可以同时执行，都属于多线程编程概念，因此二者必然十分相近，容易混淆。二者区别只有一点，即是否多任务执行于严格的同一时刻。并发不是，而并行是。单核处理器时代（一个处理器同一时刻只能执行一条命令），为了实现多任务的同时执行，系统利用时间分片（time-slicing）技术，将处理器的执行时间切分为多个小片段，一会执行threadA，一会执行threadB，一会再执行threadA，即在多个线程（任务是在线程上执行的）之间来回跳动执行。虽不是真的多线程多任务同时执行，但由于处理器的处理速度非常快，在用户看来，仍然是同时执行的。这种伪多线程就是并发。多核处理器时代（不同处理器相互独立，可以同时执行各自的命令），多条线程完全可以严格同一时刻执行，这种真多线程就是并行。//三个线程的并发thread1 -&gt; |---A---|             -&gt;|---A---|thread2 ------&gt;    -&gt;|------B----|thread3 ------------------------------------&gt; |------C------|上述代码是三个线程的并发执行，可以看出thread1、thread2和thread3不可能严格同一时刻执行，但也都获得了处理器的一小段执行时间。//三个线程的并行thread1 -&gt; |-----A-----|thread2 -&gt;       |------B----|thread3 -&gt;     |------C------|上述代码是三个线程的并行执行，可以看出thread1、thread2和thread3有一段时间同时执行。现在的终端设备无论是手机还是PC的处理器，大多都已是多核处理器，可以实现并行计算，但为了最大化的利用处理器的性能，现代处理器还是融合了time-slicing技术和多核技术，因此实际运行中，有时并发，有时并行。但相对来说，并发是个更广泛的概念，因此Apple的多线程编程叫做concurrency programming并发编程。汉语中，并发和并行的区别其实没那么清晰，可以互用，而且有时用并行更加明确，如串并行比串行、并发针对性更强。（为概念清晰起见，下文中有时会用并行，其实即是并发。）2）串并行与线程串行（serial）和并行串行和并行主要区别在于一个任务的执行是否以上一个任务的完成为前提。串行中，一个任务的执行必须以上一个任务执行结束为前提；并行中，一个任务的执行与上一个任务的执行状态无关。以排队买票为例，串行像单个买票队伍，单个卖票窗口，必须一个一个来；串行像单个买票队伍，多个卖票窗口，多个人可以同时买票。//三个串行任务|-----A-----||------B--------||----C--|上文为三个串行任务，任务A完成后，才执行任务B，B结束后，才最后执行任务C。//三个并发任务|-----A-----|      |------B----|   |--C---|上文为三个并行任务，任务A早于任务C开始，却晚于任务C结束。串并行与线程串并行主要关注多个任务之间的相互依赖关系，与线程无关。但实际中，任务是在线程中执行的，是否串行一定在单线程上执行，并行一定在多个线程中执行呢？并非如此。单线程既可以实现串行，也可以实现并行。//单线程串行1 thread -&gt;   |----A-----||-----B-----------||-------C------|//单线程并行（理论上，实际中不可行）         A-Start ---------------------------------------- A-End             | B-Start ----------------------------------------|--- B-End             |   |     C-Start -------------------- C-End      |     |             V   V       V                           V         V     V      1 thread-&gt; |-A-|---B---|-C-|-A-|-C-|--A--|-B-|--C--|---A-----|--B--|需要指出的是单线程内的并行已经类似单核处理器，并不是本文提及的常规线程，现实中也不常见。多线程既可以实现串行，也可以实现并行，实际上，多线程串行和并行都很常见。//多线程串行thread1 -&gt; |----A-----|                         \  thread2 ---------------&gt;|-----B-----------|                                             \  thread3 -----------------------------------&gt;|-------C------|//多线程并发thread1 -&gt;     |----A-----|thread2 -----&gt;     |-----B-----------|thread3 ---------&gt;     |-------C----------|3）同步（synchronize）、异步（asynchronous）与线程同步和异步是站在当前线程的角度，考察添加任务到新线程后，何时返回到当前线程执行下面的代码的问题，也即新添加的线程阻不阻塞当前线程。  同步override viewDidLoad() {    super.viewDidLoad()    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)    dispatch_sync(queue) {        //block1        print("-----1-----") //1        return    }    print("-----2-----") //2}block1是添加到系统全局队列中的新任务，由于是同步的，因此block1执行返回后，才会回到当前主线程，执行//2及以后的代码。输出结果为：-----1----------2-----  异步//viewDidLoad()在主线程中执行，因此当前线程为主线程override viewDidLoad() {    super.viewDidLoad()    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)    dispatch_async(queue) {        //block1        print("-----1-----") //1        return    }    print("-----2-----") //2}block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就会返回到当前主线程，执行//2及以后的代码，所以输出结果可能为 21 12。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此很可能的输出结果是：-----2----------1-----  同异步结合的情形如果同异步结合://viewDidLoad()在主线程中执行，因此当前线程为主线程override viewDidLoad() {    super.viewDidLoad()    let queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)    dispatch_async(queue) {        //block1        print("-----A-----") //1        dispatch_async(dispatch_get_main_queue()) {            //block2            print("-----B-----") //2        }        print("-----C-----") //3        return    }    print("-----D-----") //4    while(true) { } //5    print("-----E-----") //6}block1是添加到系统全局队列中的新任务，由于是异步的，因此block1添加全局队列后（会在另外一个线程上执行），不等到执行完成，就返回到当前主线程，执行//4及以后的代码，结果是block1所在的线程与主线程同时执行，因此理论上，D和A谁先输出不一定。但由于block1和主线程中的任务都是不耗时的简单任务，而创建新的线程是要消耗一定时间的（主线程一直存在，不用新创建），因此一般输出结果为DA。block1所在线程输出完A后，将block2添加到主调度队列中，由于是异步的，因此block2添加主调度队列后（会在主线程上执行），不等到执行完成，就返回到block2所在的线程，继续执行，因此A和C一定会输出，且C一定在A之后输出。但block2却不一定能执行，因为block1在执行时，主线程也在执行（主线程是串行单线程，任务按顺序一个一个执行），如果此时主线程执行到//5对应的死循环，则block2一定不能被执行，B一定不能被输出，如果此时主线程尚未执行到//5对应的死循环，block2已经添加到主线程中，则block2会被执行，B能被输出。但由于主线程无需另外创建，block1（所对应的线程需另外创建）执行到添加block2到主调度队列时，主线程很可能已经执行到//5对应的死循环，因此block2很可能不被执行。//6前有个死循环，因此E一定不会被输出。因此可能的输出结果是；DAC ADC ADCB DACB ACDB ACBD ABDC ABCD但很可能的输出结果为：-----D----------A----------C-----4）同异步与串并行串行和同步，并行和异步似是完全不同的概念，一个关注任务的独立关系，一个看中的是返回的时机。但事实上，串行和同步近似，并发和异步相同，他们指代的事情几乎完全相同。就同步和串行而言，需要任务执行结束后才能返回，其实就是一个任务执行完成后，才能执行其他的任务，反应的就是串行依赖关系。而异步和并行就更相同了，不等任务执行完成，就直接返回，反应的就是并发任务之间的独立性。当然，同异步所暗含的串行和并行是当前线程的任务与新线程的任务之间的相互关系。三、GCD与NSOperationQueueGCD(grand central dispatch)和NSOperationQueue二者均是系统级的多线程封装，在使用时，我们只需创建任务队列即可，其他的如线程创立、任务分配等，均由系统自动处理。不得不说，这让多线程编程变得更高效，更简单，当然并不是没有坑。需要强调的是，GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue），暂时可以忘了线程（thread）这烦人的概念。关于GCD和NSOperationQueue网上已经有不少高质量的文章对其详细介绍，推荐《iOS并行开发：从NSOperation和调度队列开始》，其对基本概念、使用方法等的介绍非常清晰详尽，这里就不再赘述，只写一些个人认为容易忽略却影响认知深度的小知识点。当然如果你英语过硬，去直接看官方文档《ConcurrencyProgrammingGuide》是最好的。1）GCDGCD是基于C的API，因此比较底层。GCD所管理的调度队列（dispatch queue）主要有三类：串行队列（private dispatch queue）、并发队列 （global dispatch queue，又称全局调度队列）和主队列（main dispatch queue）。我们常用的 dispatch_get_global_queue(_: _:)所获得的dispatch queue就是全局调度队列(global dispatch queue)，并发，而且全局调度队列是全局共用的，每一个优先级的全局调度队列只有一个实体。四种不同优先级的全局调度队列对应的四种优先级的线程，同一个优先级的全局调度队列可以同时拥有多条相应优先级的线程。dispatch_get_main_queue()所获得的dispatch queue是主调度队列，主调度队列是串行队列。2）NSOperationQueueNSOperationQueue是对GCD的Objective-C封装，相对于GCD具有更多先进的特性，如可以添加NSOperation依赖，取消NSOperation等。NSOperationQueue是并发队列，且不遵循先进先出（FIFO）排序原则。四、总结与感悟1）串并行、同异步与线程无关，单线程、多线程都可以实现串并行和同异步。2）串行和同步相同，异步和并行相同，他们只是看待同一件事物的角度不同。3）GCD和NSOperationQueue的使用核心是任务（task）和任务队列（task queue）。4）全局调度队列(global dispatch queue)是全局共用的，系统有时也会向这些调度队列添加系统任务。5) App的主调度队列是串行单线程队列。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 线程 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[GitHub 使用]]></title>
      <url>/blog/github-using/</url>
      <content type="text"><![CDATA[GitHub就是程序员的facebook，在这个开源、大神云集的地方，小菜是可以学到，找到很多很棒的资源的。那么，如何进入这个圈子呢？我们从使用开始。这篇文章主要讲解如何使用GitHub托管自己的代码，注意，托管是公开的喔，私有的要付费的。下载github客户端软件  官网下载  Google搜索，一般用于windows7以前的系统安装github软件根据软件安装指导，按步骤安装即可。使用git命令提交git config安装Git后首先要做的事情是设置用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：	git config --global user.name "Chars Davy"	git config --global user.email chars_d@example.com重申一遍，只需要做一次这个设置。如果传递了 --global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要--global选项。注意：默认git对大小写是不敏感的，可以通过命令关掉其配置：git config core.ignorecase falsegit clone这是一种较为简单的初始化方式，当你已经有一个远程的Git版本库，只需要在本地克隆一份:git  clone  git://github.com/someone/some_project.git   some_project 上面的命令就是将git://github.com/someone/some_project.git这个URL地址的远程版本库，完全克隆到本地some_project目录下。git init 和 git remote这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录，使用git init命令进行初始化；Git以后就会对该目录下的文件进行版本控制，这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把可访问的URL记录下来，此时你就可以利用git remote add命令来增加一个远程服务器端，git  remote  add  origin  git://github.com/someone/another_project.git上面的命令就会增加URL地址为git: //github.com/someone/another_project.git，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可。git add将当前更改或者新增的文件加入到Git的索引中，加入到Git的索引中就表示记入了版本历史中，这也是提交之前所需要执行的一步，git add app/model/user.rb就会增加app/model/user.rb文件到Git的索引中，该功能类似于SVN的add，git add .上面的命令会将所有改动过的文件及文件夹迭代全部添加进本地代码仓库。git commit提交当前工作空间的修改内容，类似于SVN的commit命令，git commit -m story #3, add user model提交的时候必须用-m来输入一条提交信息，该功能类似于SVN的commit，git commit –m beta上面的命令会将beta作为log显示在代码提交记录中。git push将本地commit的代码更新到远程版本库中，git push origin上面的命令就会将本地的代码更新到名为orgin的远程版本库中。git代码提交中可能遇到的问题问题1：You can't push to git://github.com/example/example_pro.gitUse https://github.com/ example/example_pro.git解决办法：git remote remove origingit remote add origin git@github.com:user_name/user_repo.gitgit push origin原因：如果在git clone的时候用的是git://github.com:xx/xxx.git 的形式, 那么就会出现这个问题，因为这个protocol是不支持push的，而使用git clone git@github.com:lujinjianst/myNCCL.git就可以用git push。问题2：Permission denied(publickey).fatal:Could not read from remote repository.解决办法：在终端输入:ssh-keygen -t rsa -C "chars"//注意,chars为用户名如果执行成功。返回:Generating public/private rsa key pair. Enter file in which to save the key (/home/forwhat.cn/.ssh/id_rsa): 在这里就是设置存储地址了.反正我是直接按的回车,然后还会返回:Enter passphrase (empty for no passphrase):再次直接回车。Enter same passphrase again:再次回车。Your identification has been saved in /home/forwhat.cn/.ssh/id_rsa. Your public key has been saved in /home/forwhat.cn/.ssh/id_rsa.pub. The key fingerprint is:The key's randomart image is: +--[ RSA 2048]----+ |                 | |                 | |                 | |    o            | |   + .  S        | |  . = .  o       | |   o + +o.o      | |E o . o.=+.      | |.+   ==+ooo.     | +-----------------+ 这样SSH key就生成了。直接cat一下就好了。:~/a$ cat /home/forwhat.cn/.ssh/id_rsa.pub 把显示出来的直接添加到github账户设置里边的SSH keys。回来再git pull就开始远程拷贝代码了。原因：没有在github账号添加SSH key。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> git </tag>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[flappy bird 游戏实现]]></title>
      <url>/blog/flappy-bird-game/</url>
      <content type="text"><![CDATA[在博主还是学生的时候，flappyBird这款游戏非常火爆，最后等到Android版的出来之后，也是很痴迷的玩了一把。可是，博主游戏天赋一直平平，几度玩得想摔手机。本文主要介绍如何开发iOS平台的flappyBird，游戏中使用了原本软件的图片资源，仅作学习交流使用。博主实现的flappyBird游戏包含游戏等级设定，排行榜，音效等功能。技术点flappyBird是单机游戏，主要涉及界面逻辑、图片资源、游戏动画、得分排行。为了实现这几个功能，需要使用以下几个技术框架：  AVFoundation  归档  模态视图  NSTimer  视图控件，包括UIImageView、UILabel、UITableView等实现过程1、创建工程1）打开Xcode，点击新建工程，选择Single View Application模板 2）填写工程信息2、移除Main.storyboard文件上图是flappyBird的文件目录，因为Xcode6使用模板创建工程时会自动生成Main.storyboard文件，而工程中本人使用代码布局，所以可以移除Main.storyboard文件。具体操作方法可以参看本人另一篇文章：《iOS学习之移除Main.storyboard》3、游戏界面布局整体效果图如下需要说明的是，Game Over这个界面，首先需要隐藏或者等到游戏结束才创建。本人是选择在游戏判定结束时才创建并显示。4、游戏运行这款游戏的两个关键点：  使用定时器驱动游戏界面运行，即游戏界面中的柱子高低变化与柱子的消失与产生。  游戏结束的判定，这里涉及两个问题，一是碰撞检测，二是计分统计。具体实现部分代码1、计分统计-(void)columnLabelClick {        if (topPipeFrame.origin.x == (100 + 30 - 70)) {        columnNumber++;        columnLabel.text = [NSString stringWithFormat:@"%zi",columnNumber];    }}2、绘制柱子-(void)pipe {    //通道高度    NSInteger tunnelHeight = 0;    //根据游戏难度设定通道高度    if([[DataTool stringForKey:kRateKey] isEqualToString:@"ordinary"]) {        tunnelHeight = 100;    }else if([[DataTool stringForKey:kRateKey] isEqualToString:@"general"]) {        tunnelHeight = 90;    }else if([[DataTool stringForKey:kRateKey] isEqualToString:@"difficult"]) {        tunnelHeight = 80;    }else if([[DataTool stringForKey:kRateKey] isEqualToString:@"hard"]) {        tunnelHeight = 75;    } else if([[DataTool stringForKey:kRateKey] isEqualToString:@"crazy"]) {        tunnelHeight = 70;    }        //柱子图像    NSInteger tall = arc4random() % 200 + 40;        topPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, -20, 70, tall)];    topPipe.image = [UIImage imageNamed:@"pipe"];    [self.view addSubview:topPipe];    bottomPipe = [[UIImageView alloc]initWithFrame:CGRectMake(320, tall + tunnelHeight, 70, 400)];    bottomPipe.image = [UIImage imageNamed:@"pipe"];    [self.view addSubview:bottomPipe];    //把底部图片视图放在柱子视图上面        [self.view insertSubview:roadView aboveSubview:bottomPipe];}3、使用定时器，驱动游戏界面运行，并进行碰撞检测//添加定时器timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(onTimer) userInfo:nil repeats:YES];//定时器操作-(void)onTimer {    //底部动画移动    CGRect frame = roadView.frame;    if (frame.origin.x == -15) {        frame.origin.x = 0;    }    frame.origin.x--;    roadView.frame = frame;        //上升    if (isTap == NO) {        CGRect frame = birdsView.frame;        frame.origin.y -= 3;        number += 3;        birdsView.frame = frame;        if (number &gt;= 60) {            isTap = YES;        }    }        //下降    if(isTap == YES &amp;&amp; birdsView.frame.origin.y &lt; 370){        CGRect frame = birdsView.frame;        frame.origin.y++;        number -= 2;        birdsView.frame = frame;        number = 0;    }        //柱子移动    topPipeFrame = topPipe.frame;    CGRect bottomPipeFrame = bottomPipe.frame;    topPipeFrame.origin.x--;    bottomPipeFrame.origin.x--;    topPipe.frame = topPipeFrame;    bottomPipe.frame = bottomPipeFrame;    if (topPipeFrame.origin.x &lt; -70) {        [self pipe];    }        //碰撞检测（交集）    bool topRet = CGRectIntersectsRect(birdsView.frame, topPipe.frame);    bool bottomRet = CGRectIntersectsRect(birdsView.frame, bottomPipe.frame);    if (topRet == true || bottomRet == true) {        [self.soundTool playSoundByFileName:@"punch"];        [self onStop];    }    if (topPipeFrame.origin.x == (100 + 30 - 70)) {        [self.soundTool playSoundByFileName:@"pipe"];        [self columnLabelClick];    }}4、更新分数，更新最佳分数与排行榜分数，并使用归档将数据持久化-(void)updateScore {    //更新最佳成绩    if (columnNumber &gt; [DataTool integerForKey:kBestScoreKey]) {        [DataTool setInteger:columnNumber forKey:kBestScoreKey];    }    //更新本局分数        [DataTool setInteger:columnNumber forKey:kCurrentScoreKey];    //更新排行榜    NSArray *ranks = (NSArray *)[DataTool objectForKey:kRankKey];    NSMutableArray *newRanksM = [NSMutableArray array];    NSInteger count = ranks.count;    BOOL isUpdate = NO;    for (NSInteger i = 0; i &lt; count; i++) {        NSString *scoreStr = ranks[i];        NSInteger score = [scoreStr integerValue];        if (score &lt; columnNumber &amp;&amp; isUpdate == NO) {            scoreStr = [NSString stringWithFormat:@"%zi", columnNumber];            [newRanksM addObject:scoreStr];            isUpdate = YES;            i--;        } else {            scoreStr = [NSString stringWithFormat:@"%zi", score];            [newRanksM addObject:scoreStr];        }    }    if (newRanksM.count &gt; count) {        [newRanksM removeLastObject];    }    [DataTool setObject:newRanksM forKey:kRankKey];}5、绘制GameOver提示显示-(void)pullGameOver {    //游戏结束操作界面    gameOver = [[GameOverView alloc] initWithFrame:CGRectMake(20, 160, 280, 300)];    gameOver.delegate = self;    [self.view addSubview:gameOver];}6、游戏停止操作-(void)onStop {    //更新分数        [self updateScore];    //停止定时器        [timer setFireDate:[NSDate distantFuture]];    //弹出游戏结束操作界面        [self pullGameOver];}小结这款游戏的实现还是很简单的，主要使用UIImageView自带的动画实现方式，即可实现bird的动画效果。使用NSTimer即可实现游戏场景的柱子移动，至于柱子的高度，则可以使用随机数方式在一定范围内实现高低变化。最后可以使用CGRectIntersectsRect来实现边界碰撞检测来判定游戏是否结束。以上是博主开发iOS版flappyBird的简要过程介绍，其中只包含了关键点的代码实现，具体完整游戏源代码地址：https://github.com/CharsDavy/flappyBird]]></content>
      <categories>
        
          <category> project </category>
        
      </categories>
      <tags>
        
          <tag> application </tag>
        
          <tag> ios </tag>
        
          <tag> game </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[均匀分布随机函数的实现]]></title>
      <url>/blog/uniform-random/</url>
      <content type="text"><![CDATA[随机函数可以说是用途很广。可是，系统提供的random函数，一般符合正态分布，所以说，这是伪随机函数。甚至在一些场合是非随机函数。为了满足项目需要，必须实现均匀分布。在此，分享博主实现均匀随机函数的实现过程与方法。前言随机函数就是产生数的函数，C语言里使用rand(),srand()等随机函数实现随机数生成。 函数简介int rand( void );返回的是一个界于0～32767（0x7FFF）之间的伪随机数，包括0和32767。C预先生成一组随机数，每次调用随机函数时从指针所指向的位置开始取值，因此使用rand()重复运行程序产生的随机数都是相同的，可以通过srand()函数来改变指针位置。srand()会设置供rand()使用的随机数种子。如果在第一次使用rand()之前没有调用srand()，那么系统会自动调用srand()。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。void srand( unsigned int seed );改变随机数表的指针位置（用seed变量控制）。使用系统定时/计数器的值作为随机种子。每个种子对应一组根据算法预先生成的随机数，所以，在相同的平台环境下，不同时间产生的随机数会是不同的，相应的，若将srand（unsigned）time(NULL)改为srand(TP)（TP为任一常量），则无论何时运行、运行多少次得到的“随机数”都会是一组固定的序列，因此srand生成的随机数是伪随机数。一般配合time(NULL)使用，因为时间每时每刻都在改变，产生的seed值都不同。 场景使用rand函数生成的随机数严格满足正态分布。而在很多时候，我们希望随机数的生成不要满足正态分布，特别是在处理网络通信报文的时候。例如，我们需要在交换机处理到海量报文时，能够使远端的从设备尽可能的分段同时向局端回应报文，以减轻局~~部~~端报文处理压力。 均匀分布随机函数实现开发环境实现步骤1）打开Qt Creater，创建GUI工程2）在mainwindow.h中添加函数声明void paintEvent(QPaintEvent *);3）在mainwindow.cpp中添加函数实现导入头文件#include &lt;QPainter&gt; 实现void paintEvent(QPaintEvent *)函数/* *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。 *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。*/void MainWindow::paintEvent(QPaintEvent *){    QPainter painter(this);    QPen pen; //画笔    pen.setColor(QColor(255,0,0)); //设置画笔颜色    painter.setPen(pen); //添加画笔    long int r[kSum] = {0};    int i = 0;    int j = 0;    do{        r[i] = Uniform(0, 300);        i++;    }while(i &lt; kSum);    while((j + 30) &lt; (kSum + 30)){        painter.drawPoint(j, r[j]);        j++;    }} 4）添加随机函数实现代码#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define kSum 1000//算法一/* *均匀分布随机函数均匀化*/double _uniform(double min, double max, long int *seed) {    double t = 0;    *seed = 2045 * (*seed) + 1;    *seed = *seed - (*seed / 1048576) * 1048576;    t = (*seed) / 1048576.0;    t = min + (max - min) * t;    return t;}/* *均匀分布随机函数产生随机数*/long int Uniform(double min, double max) {    long int s = 0;    double r = 0;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/    s = rand();    r = _uniform(min, max, &amp;s);    return ((long int)r);}//算法二double AverageRandom(double min, double max) {    int minInteger = (int)(min * 10000);    int maxInteger = (int)(max * 10000);    int randInteger = rand() * rand();    int diffInteger = maxInteger - minInteger;    int resultInteger = randInteger % diffInteger + minInteger;    return (resultInteger/10000.0);} 实现效果 小结从图中可以看出，使用上述函数生成的随机数符合均匀分布。本案例主要使用了Qt的绘图功能，用来直观展示生成随机数的效果。检验随机函数生成随机数的效果。 附录最后附上该算法实现的全部代码：//mainwindow.h#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;namespace Ui {class MainWindow;}class MainWindow : public QMainWindow{    Q_OBJECTpublic:    explicit MainWindow(QWidget *parent = 0);    ~MainWindow();    void paintEvent(QPaintEvent *);private:    Ui::MainWindow *ui;};#endif // MAINWINDOW_H//mainwindow.cpp#include "mainwindow.h"#include "ui_mainwindow.h"#include &lt;QPainter&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define kSum 1000MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow){    ui-&gt;setupUi(this);}MainWindow::~MainWindow(){    delete ui;}/* *均匀分布随机函数均匀化*/double _uniform(double min, double max, long int *seed) {    double t = 0;    *seed = 2045 * (*seed) + 1;    *seed = *seed - (*seed / 1048576) * 1048576;    t = (*seed) / 1048576.0;    t = min + (max - min) * t;    return t;}/* *均匀分布随机函数产生随机数*/long int Uniform(double min, double max) {    long int s = 0;    double r = 0;    //srand((unsigned int)time(NULL)); /*同一个时间种子可能会从产生相同的随机数列*/    s = rand();    r = _uniform(min, max, &amp;s);    return ((long int)r);}/* *Qt中函数paintEvent(QPaintEvent*)是被系统自动调用。 *paintEvent(QPaintEvent *)函数是QWidget类中的虚函数，用于ui的绘制，会在多种情况下被其他函数自动调用。*/void MainWindow::paintEvent(QPaintEvent *){    QPainter painter(this);    QPen pen; //画笔    pen.setColor(QColor(255,0,0)); //设置画笔颜色    painter.setPen(pen); //添加画笔    long int r[kSum] = {0};    int i = 0;    int j = 0;    do{        r[i] = Uniform(0, 300);        i++;    }while(i &lt; kSum);    while((j + 30) &lt; (kSum + 30)){        painter.drawPoint(j, r[j]);        j++;    }}//main.cpp#include "mainwindow.h"#include &lt;QApplication&gt;int main(int argc, char *argv[]){    QApplication a(argc, argv);    MainWindow w;    w.show();    return a.exec();}写在最后欢迎大家加入算法交流Q群交流讨论，Q群号：855454453]]></content>
      <categories>
        
          <category> algorithm </category>
        
      </categories>
      <tags>
        
          <tag> c </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[VFL 语言简介]]></title>
      <url>/blog/VFL-introduction/</url>
      <content type="text"><![CDATA[VFL（Visual Format Language），“可视化格式语言”。VFL是苹果公司为了简化autolayout的编码而推出的抽象语言。本文分享VFL的基本使用方法。什么是VFL语言VFL（Visual Format Language），“可视化格式语言”。VFL 是苹果公司为了简化autolayout的编码而推出的抽象语言。语法说明H:[cancelButton(72)]-12-[acceptButton(50)]cancelButton宽72，acceptButton宽50，它们之间间距12 H:[wideView(&gt;=60@700)]wideView宽度大于等于60point，该约束条件优先级为700（优先级最大值为1000，优先级越高的约束条件越先被满足）  V:[redBox][yellowBox(==redBox)]垂直方向上，先有一个redBox，其下方紧接一个高度等于redBox高度的yellowBox  H:|-10-[Find]-[FindNext]-[FindField(&gt;=20)]-|水平方向上，Find距离父view左边缘间隔10，之后是FindNext距离Find间隔默认宽度；再之后是宽度不小于20的FindField，它和FindNext以及父view右边边缘的间距都是默认宽度。（竖线“|”表示superview的边缘）。使用方法使用VFL来创建约束数组+(NSArray *)constraintsWithVisualFormat:(NSString *)format options:(NSLayoutFormatOptions)opts metrics:(NSDictionary *)metrics views:(NSDictionary *)views;  format：VFL语句opts：约束类型metrics：VFL语句中用到的具体数值views：VFL语句中用到的控件  创建一个字典（内部包含VFL语句中用到的控件）的快捷宏定义NSDictionaryOfVariableBindings(...)实例展示效果图如下： 实现代码-(void)horizontalLayout{    //1.添加两个控件    UIView *blueView = [[UIView alloc] init];    blueView.backgroundColor = [UIColor blueColor];        blueView.translatesAutoresizingMaskIntoConstraints = NO;    [self.view addSubview:blueView];        UIView *redView = [[UIView alloc] init];    redView.backgroundColor = [UIColor redColor];    redView.translatesAutoresizingMaskIntoConstraints = NO;    [self.view addSubview:redView];        //2.添加约束    //2.1水平方向的约束    NSString *hVFL = @"H:|-30-[blueView]-30-[redView(==blueView)]-30-|";    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:NSLayoutFormatAlignAllBottom | NSLayoutFormatAlignAllTop metrics:nil views:@{@"blueView":blueView, @"redView":redView}];    [self.view addConstraints:hCons];        //2.2垂直方向的约束    NSString *vVFL = @"V:[blueView(50)]-30-|";    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:0 metrics:nil views:@{@"blueView":blueView}];    [self.view addConstraints:vCons];}-(void)verticalLayout{    //1.添加两个控件    UIView *blueView = [[UIView alloc] init];    blueView.backgroundColor = [UIColor blueColor];    blueView.translatesAutoresizingMaskIntoConstraints = NO;    [self.view addSubview:blueView];    UIView *redView = [[UIView alloc] init];    redView.backgroundColor = [UIColor redColor];    redView.translatesAutoresizingMaskIntoConstraints = NO;    [self.view addSubview:redView];    //2.添加约束    //2.1水平方向的约束    NSString *hVFL = @"H:|-30-[blueView]-30-|";    NSArray *hCons = [NSLayoutConstraint constraintsWithVisualFormat:hVFL options:0 metrics:nil views:@{@"blueView":blueView}];    [self.view addConstraints:hCons];    //2.2垂直方向的约束    NSString *vVFL = @"V:|-30-[blueView(50)]-30-[redView(==blueView)]";    NSArray *vCons = [NSLayoutConstraint constraintsWithVisualFormat:vVFL options:NSLayoutFormatAlignAllRight metrics:nil views:@{@"blueView":blueView, @"redView":redView}];    [self.view addConstraints:vCons];    NSLayoutConstraint *redLeftCon = [NSLayoutConstraint constraintWithItem:redView attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:blueView attribute:NSLayoutAttributeCenterX multiplier:1.0 constant:0];    [self.view addConstraint:redLeftCon];}小结最后对格式的字符串作一个总结介绍：            功能      表达式                  水平方向      H:              垂直方向      V:              Views      [view]              SuperView      竖线符号              关系      &gt;=,==,&lt;=              空间，间隙      -              优先级      @value      ]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[GCD（Grand Central Dispatch）]]></title>
      <url>/blog/grand-central-dispatch/</url>
      <content type="text"><![CDATA[GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。文章分享关于GCD的种种概念以及使用。前言GCD（Grand Central Dispatch），是 Apple 开发的一个多核编程的解决方法。该方法在 Mac OS X 10.6 雪豹中首次推出，并随后被引入到了 iOS4.0 中。GCD 是一个替代诸如NSThread,NSOperationQueue, NSInvocationOperation 等技术的很高效和强大的技术。GCD 和 block 的配合使用，可以方便地进行多线程编程。优势1）  苹果官方为多核的并行运算提出的解决方案。2）  会自动利用更多的CPU内核。3）  会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。 核心概念1）  任务：执行什么操作。block2）  队列：用来存放任务。串行队列：顺序，一个一个执行。一个任务执行完毕后才执行下一个任务。并发队列：同时，同时执行很多个任务。自动开启多个线程同时执行任务。并发功能只有在异步函数下才生效。 使用步骤：1）  定制任务确定想要做的事情。2）  将任务添加到队列中GCD会自动将队列中的任务取出，放到对应的线程中执行。任务的取出原则遵循队列的原则：先进先出，后进后出。 执行任务的函数1）同步方式　　dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);queue:队列block:任务2）异步方式dispatch_async(dispatch_queue_t queue, dispatch_block_t block);queue:队列block:任务同步和异步的区别：同步：在当前线程中执行。异步：在另一条线程中执行。同步任务的作用：1）  用户登录2）  下载任务13）  下载任务2 术语1）  同步和异步决定了是否要开辟新线程。同步：在当前线程中执行任务，不具备开启新线程的能力。异步：在新的线程中执行任务，具备开启新线程的能力。2）  并发和串行决定了任务执行的方式。并发：多个任务同时执行。串行：一个任务执行完毕后，再执行下一个任务。 代码使用　/*串行队列*//*创建队列参数：1.队列标签。 2.队列属性。*/dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_SERIAL);/*同步执行任务，不会开辟新线程，在当前线程中顺序执行。一般只要使用“同步”执行，串行队列对添加的同步任务，立马执行*/dispatch_sync(queue, ^{    NSLog(@”%@”, [NSThread currentThread]);});/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量与队列模式有关。串行队列中异步执行只会开启一个新线程。*/for(int I = 0; I &lt; 10; I++){    dispatch_async(queue, ^{        NSLog(@”%@”, [NSThread currentThread]);    });}　　/*并发队列：需要程序员释放。*//*创建队列参数：1.队列标签。 2.队列属性。*/dispatch_queue_t queue = dispatch_queue_create(”dengw”,DISPATCH_QUEUE_CONCURRENT);/*异步执行任务，开辟新线程，在新线程中执行。开辟新线程的数量程序员无法控制。*/for(int I = 0; I &lt; 10; I++){    dispatch_async(queue, ^{        NSLog(@”%@”, [NSThread currentThread]);    });}/*同步执行任务，不开辟新线程，顺序执行*/for(int I = 0; I &lt; 10; I++){    dispatch_sync(queue, ^{        NSLog(@”%@”, [NSThread currentThread]);    });}/*主队列，专门负责在主线程上调度任务。程序启动以后至少有一个主线程，则会创建主队列。*//*主队列不允许开辟新线程。不会在子线程调度任务。*//*获得主队列*/dispatch_queue_t queue = dispatch_get_main_queue();/*异步执行任务，在主队列中，只能顺序执行。*/for(int I = 0; I &lt; 10; I++){/*异步：把任务放到主队列中，但不需要马上执行。*/    dispatch_async(queue, ^{        NSLog(@”%@”, [NSThread currentThread]);    });}/*同步执行任务*/for(int I = 0; I &lt; 10; I++){/*同步：把任务放到主队列中，需要马上执行。*//*阻塞*/    dispatch_sync(queue, ^{        NSLog(@”%@”, [NSThread currentThread]);    });}/*全局队列：本质是并发队列。与并发队列的区别：1）全局队列没有名字，而并发队列有名字。2）全局队列，是供所有的应用程序使用。3）在MRC中，全局队列不需要释放，并发队列需要释放。*//*获得全局队列参数：参数1iOS7中DISPATCH_QUEUE_PRIORITY_HEGH    2 高优先级DISPATCH_QUEUE_PRIORITY_DEFAULT  0 默认优先级DISPATCH_QUEUE_PRIORITY_LOW   (-2) 低优先级DISPATCH_QUEUE_PRIORITY_BACKGROUND    INT16_MIN 后台优先级（最低）iOS8中DISPATCH_QUEUE_PRIORITY_HEGH:QOS_CLASS_USER_INITIATEDDISPATCH_QUEUE_PRIORITY_DEFAULT:QOS_CLASS_USER_DEFAULTDISPATCH_QUEUE_PRIORITY_LOW:QOS_CLASS_USER_UTILITYDISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_USER_BACKGROUND参数2保留参数。*/dispatch_queue_t queue = dispatch_get_global_queue(QOS_CLASS_USER_DEFAULT,0);/*异步执行任务*/for(int I = 0; I &lt; 10; I++){    dispatch_async(queue, ^{        NSLog(@”%@”, [NSThread currentThread]);    });}各队列的执行效果 | | 全局并行队列 | 手动创建串行队列 | 主队列 || — | — | — || 同步（sync） | 没有开启新线程。串行执行任务。| 没有开启新线程。串行执行任务。 | 会死锁 || 异步（async）| 有开启新线程。并行执行任务。| 有开启新线程。串行执行任务。| 没有开启新线程。串行执行任务。| 队列的选择1）串行队列异步执行开一条线程，顺序执行。效率不高，执行比较慢，资源占用小，省电。应用场景：一般3G网络，对性能要求不高。2）并发队列异步执行开启多条线程，并发执行。效率高，执行快，资源消耗大，费电。应用场景：WIFI网络，或需要快速响应，用户体验要求高，对任务执行顺序没有要求。3）  同步任务一般只会在并发队列，需要阻塞后续任务，必须等待同步任务执行完毕，再去执行其他任务。“依赖关系”  线程间通信/*从子线程回到主线程*/dispatch_async(    dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{    //执行耗时的异步操作…    dispatch_async(dispatch_get_main_queue(), ^{    //回到主线程，执行UI刷新操作    });}); 延时操作1）方式一，调用NSObject的方法//2秒后再调用run方法[self performSelector:@selector(run) withObject:nil afterDelay:2.0];2）方式二，使用GCD函数dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)),dispatch_get_main_queue(), ^{        //2秒后再异步执行这里的代码}); 调度组（分组）应用场景：开发的时候，有的时候出现多个网络请求（每一个网络请求时间长短不一），都完成以后统一更新UI或通知用户。/*实例化一个调度组*/dispatch_group_t group = dispatch_group_create();//队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);//将任务添加到队列dispatch_group_async(group, queue, ^{    NSLog(@”A %@”, [NSThread currentThread]);});dispatch_group_async(group, queue, ^{    NSLog(@”B %@”, [NSThread currentThread]);});//获得所有调度组里面的异步任务完成的通知/*在调度组完成通知里，可以跨队列通信*/dispatch_group_notifity(group, queue, ^{    //异步的    NSLog(@”finished”);}); 一次性执行常见于单例模型中代码使用。static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{    //只执行一次    NSLog(@”hi”);});]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> 线程 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ruby 正则表达式]]></title>
      <url>/blog/ruby-regular-expression/</url>
      <content type="text"><![CDATA[正则表达式是一种特殊序列的字符，它通过使用有专门语法的模式来匹配或查找字符串集合。正则表达式用事先定义好的一些特定字符、及这些特定字符的组合，组成一个”规则字符串”，这个”规则字符串”用来表达对字符串的一种过滤逻辑。文章分享关于Ruby中的正则表达式的相关知识与使用。语法正则表达式从字面上看是一种介于斜杠之间或介于跟在 %r 后的任意分隔符之间的模式，如下所示：/pattern//pattern/im    # 可以指定选项%r!/usr/local! # 使用分隔符的正则表达式实例#!/usr/bin/rubyline1 = "Cats are smarter than dogs";line2 = "Dogs also like meat";if ( line1 =~ /Cats(.*)/ )  puts "Line1 contains Cats"endif ( line2 =~ /Cats(.*)/ )  puts "Line2 contains  Dogs"end实例运行输出结果为：Line1 contains Cats正则表达式修饰符正则表达式从字面上看可能包含一个可选的修饰符，用于控制各方面的匹配。修饰符在第二个斜杠字符后指定，如上面实例所示。下标列出了 可能的修饰符：            修饰符      描述                  i      当匹配文本时忽略大小写。              o      只执行一次 #{} 插值，正则表达式在第一次时就进行判断。              x      忽略空格，允许在整个表达式中放入空白符和注释。              m      匹配多行，把换行字符识别为正常字符。              u,e,s,n      把正则表达式解释为 Unicode（UTF-8）、EUC、SJIS 或 ASCII。如果没有指定修饰符，则认为正则表达式使用的是源编码。      就像字符串通过 %Q 进行分隔一样，Ruby 允许您以 %r 作为正则表达式的开头，后面跟着任意分隔符。这在描述包含大量您不想转义的斜杠字符时非常有用。# 下面匹配单个斜杠字符，不转义%r|/|# Flag 字符可通过下面的语法进行匹配%r[&lt;/(.*)&gt;]i正则表达式模式除了控制字符，(+ ? . * ^ $ ( ) [ ] { } | )，其他所有字符都匹配本身。您可以通过在控制字符前放置一个反斜杠来对控制字符进行转义。下表列出了 Ruby 中可用的正则表达式语法。            模式      描述                  ^      匹配行的开头。              $      匹配行的结尾。              .      匹配除了换行符以外的任意单字符。使用 m 选项时，它也可以匹配换行符。              […]      匹配在方括号中的任意单字符。              [^…]      匹配不在方括号中的任意单字符。              re*      匹配前面的子表达式零次或多次。              re+      匹配前面的子表达式一次或多次。              re?      匹配前面的子表达式零次或一次。              re{ n}      匹配前面的子表达式 n 次。              re{ n,}      匹配前面的子表达式 n 次或 n 次以上。              re{ n, m}      匹配前面的子表达式至少 n 次至多 m 次。              (re)      对正则表达式进行分组，并记住匹配文本。              (?imx)      暂时打开正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。              (?-imx)      暂时关闭正则表达式内的 i、 m 或 x 选项。如果在圆括号中，则只影响圆括号内的部分。              (?: re)      对正则表达式进行分组，但不记住匹配文本。              (?imx: re)      暂时打开圆括号内的 i、 m 或 x 选项。              (?-imx: re)      暂时关闭圆括号内的 i、 m 或 x 选项。              (?#…)      注释。              (?= re)      使用模式指定位置。没有范围。              (?! re)      使用模式的否定指定位置。没有范围。              (?&gt; re)      匹配无回溯的独立模式。              \w      匹配单词字符。              \W      匹配非单词字符。              \s      匹配空白字符。等价于 [\t\n\r\f]。              \S      匹配非空白字符。              \d      匹配数字。等价于 [0-9]。              \D      匹配非数字。              \A      匹配字符串的开头。              \Z      匹配字符串的结尾。如果存在换行符，则只匹配到换行符之前。              \z      匹配字符串的结尾。              \G      匹配最后一个匹配完成的点。              \b      当在括号外时匹配单词边界，当在括号内时匹配退格键（0x08）。              \B      匹配非单词边界。              \n, \t, etc.      匹配换行符、回车符、制表符，等等。              \1…\9      匹配第 n 个分组子表达式。              \10      如果已匹配过，则匹配第 n 个分组子表达式。否则指向字符编码的八进制表示。      补充： a|b ：匹配 a 或 b。正则表达式实例字符            实例      描述                  /ruby/      匹配 “ruby”              ¥      匹配 Yen 符号。Ruby 1.9 和 Ruby 1.8 支持多个字符。      字符类            实例      描述                  /[Rr]uby/      匹配 “Ruby” 或 “ruby”              /rub[ye]/      匹配 “ruby” 或 “rube”              /[aeiou]/      匹配任何一个小写元音字母              /[0-9]/      匹配任何一个数字，与 /[0123456789]/ 相同              /[a-z]/      匹配任何一个小写 ASCII 字母              /[A-Z]/      匹配任何一个大写 ASCII 字母              /[a-zA-Z0-9]/      匹配任何一个括号内的字符              /[^aeiou]/      匹配任何一个非小写元音字母的字符              /[^0-9]/      匹配任何一个非数字字符      特殊字符类            实例      描述                  /./      匹配除了换行符以外的其他任意字符              /./m      在多行模式下，也能匹配换行符              /\d/      匹配一个数字，等同于 /[0-9]/              /\D/      匹配一个非数字，等同于 /[^0-9]/              /\s/      匹配一个空白字符，等同于 /[ \t\r\n\f]/              /\S/      匹配一个非空白字符，等同于 /[^ \t\r\n\f]/              /\w/      匹配一个单词字符，等同于 /[A-Za-z0-9_]/              /\W/      匹配一个非单词字符，等同于 /[^A-Za-z0-9_]/      重复            实例      描述                  /ruby?/      匹配 “rub” 或 “ruby”。其中，y 是可有可无的。              /ruby*/      匹配 “rub” 加上 0 个或多个的 y。              /ruby+/      匹配 “rub” 加上 1 个或多个的 y。              /\d{3}/      刚好匹配 3 个数字。              /\d{3,}/      匹配 3 个或多个数字。              /\d{3,5}/      匹配 3 个、4 个或 5 个数字。      非贪婪重复这会匹配最小次数的重复。            实例      描述                  /&lt;.*&gt;/      贪婪重复：匹配 “perl&gt;”              /&lt;.*?&gt;/      非贪婪重复：匹配 “perl&gt;” 中的 “”      通过圆括号进行分组            实例      描述                  /\D\d+/      无分组： + 重复 \d              /(\D\d)+/      分组： + 重复 \D\d 对              /([Rr]uby(, )?)+/      匹配 “Ruby”、”Ruby, ruby, ruby”，等等      反向引用这会再次匹配之前匹配过的分组。            实例      描述                  /([Rr])uby&amp;\1ails/      匹配 ruby&amp;rails 或 Ruby&amp;Rails              /([’”])(?:(?!\1).)*\1/      单引号或双引号字符串。\1 匹配第一个分组所匹配的字符，\2 匹配第二个分组所匹配的字符，依此类推。      替换            实例      描述                         /ruby      rube/      匹配 “ruby” 或 “rube”              /rub(y      le))/      匹配 “ruby” 或 “ruble”              /ruby(!+      \?)/      “ruby” 后跟一个或多个 ! 或者跟一个 ?      锚这需要指定匹配位置。            实例      描述                  /^Ruby/      匹配以 “Ruby” 开头的字符串或行              /Ruby$/      匹配以 “Ruby” 结尾的字符串或行              /\ARuby/      匹配以 “Ruby” 开头的字符串              /Ruby\Z/      匹配以 “Ruby” 结尾的字符串              /\bRuby\b/      匹配单词边界的 “Ruby”              /\brub\B/      \B 是非单词边界：匹配 “rube” 和 “ruby” 中的 “rub”，但不匹配单独的 “rub”              /Ruby(?=!)/      如果 “Ruby” 后跟着一个感叹号，则匹配 “Ruby”              /Ruby(?!!)/      如果 “Ruby” 后没有跟着一个感叹号，则匹配 “Ruby”      圆括号的特殊语法            实例      描述                  /R(?#comment)/      匹配 “R”。所有剩余的字符都是注释。              /R(?i)uby/      当匹配 “uby” 时不区分大小写。              /R(?i:uby)/      与上面相同。      补充 /rub(?:y|le))/ ：只分组，不进行 \1 反向引用搜索和替换sub 和 gsub 及它们的替代变量 sub! 和 gsub! 是使用正则表达式时重要的字符串方法。所有这些方法都是使用正则表达式模式执行搜索与替换操作。sub 和 sub! 替换模式的第一次出现，gsub 和 gsub! 替换模式的所有出现。sub 和 gsub 返回一个新的字符串，保持原始的字符串不被修改，而 sub! 和 gsub! 则会修改它们调用的字符串。下面是一个实例：#!/usr/bin/ruby# -*- coding: UTF-8 -*-phone = "138-3453-1111 #这是一个电话号码"# 删除 Ruby 的注释phone = phone.sub!(/#.*$/, "")      puts "电话号码 : #{phone}"# 移除数字以外的其他字符phone = phone.gsub!(/\D/, "")        puts "电话号码 : #{phone}"以上实例运行结果：电话号码 : 138-3453-1111 电话号码 : 13834531111下面是另一个实例：#!/usr/bin/ruby# -*- coding: UTF-8 -*-text = "rails 是 rails,  Ruby on Rails 非常好的 Ruby 框架"# 把所有的 "rails" 改为 "Rails"text.gsub!("rails", "Rails")# 把所有的单词 "Rails" 都改成首字母大写text.gsub!(/\brails\b/, "Rails")puts "#{text}"以上实例运行结果：Rails 是 Rails,  Ruby on Rails 非常好的 Ruby 框架]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> 正则表达式 </tag>
        
          <tag> ruby </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[单例模式]]></title>
      <url>/blog/singleton-pattern/</url>
      <content type="text"><![CDATA[单例模式的作用是解决“应用中只有一个实例”的一类问题。本文主要介绍单例模式所谓何物，以及如何实现。问题的提出　在一个iOS 应用的生命周期中，有时候我们只需要某个类的一个实例。例如，iOS 设备都有一个重力加速计硬件设备，要访问设备在x轴、y轴和z轴上的重力加速度，就必然要有一个类能够与硬件设备沟通来实时获得这些数据，这个类就是UIAccelerometer 。除了实时地获得数据，该类还能够保持x 轴、y轴和z 轴的状态。但是这个类只需要一个实例就够了，如果有多个实例，就会占用过多的内存。 再有，当应用程序启动时，应用的状态由UIApplication 类的一个实例维护，这个实例代表了整个“应用程序对象”，它只能是一个实例，其作用是实现应用程序中一些共享资源的访问和状态的保持等。实现原理单例模式一般会封装一个静态属性，并提供静态实例的创建方法，其UML类图如图所示:示例代码：//Singleton.h//@interface Singleton : NSObject+ (Singleton*)sharedManager;@property (nonatomic ,strong) NSString* singletonData;@end   //Singleton.m //#import "Singleton.h"@implementation Singleton@synthesize singletonData = _singletonData;static Singleton *sharedManager = nil;+ (Singleton*)sharedManager{    static dispatch_once_t once;    dispatch_once(&amp;once, ^{        sharedManager = [[self alloc] init];    });    return sharedManager;}@end其中static Singleton *sharedManager 为静态变量，类方法为+ (Singleton*)sharedManager。sharedManager 方法采用了GCD（Grand Central Dispatch）技术，这是一种基于C语言的多线程访问技术。在上述代码中，dispatch_once 函数就是由GCD提供的，它的作用是在整个应用程序生命周期中只执行一次代码块（^{…}）。 dispatch_once_t 是GCD提供的结构体，使用时需要将GCD地址传给dispatch_once 函数。dispatch_once 函数能够记录该代码块是否被调用过。dispatch_once函数不仅意味着代码仅会被运行一次，而且还意味着此运行还是线程同步的。也就是说，当我们使用了dispatch_once函数时，就不再需要使用诸如@synchronized之类的语句。将以上单例实现代码，抽成宏，代码如下：// @interface#define singleton_interface(className) \+ (className *)shared##className; // @implementation#define singleton_implementation(className) \static className *_instance; \+ (id)allocWithZone:(NSZone *)zone \{ \    static dispatch_once_t onceToken; \    dispatch_once(&amp;onceToken, ^{ \        _instance = [super allocWithZone:zone]; \    }); \    return _instance; \} \+ (className *)shared##className \{ \    static dispatch_once_t onceToken; \    dispatch_once(&amp;onceToken, ^{ \        _instance = [[self alloc] init]; \    }); \    return _instance; \}应用案例在Cocoa Touch框架中，有UIApplication、UIAccelerometer 、NSUserDefaults和NSNotificationCenter等单例类。另外，NSFileManager 和NSBundle 类虽然属于Cocoa框架的内容，但也可以在Cocoa Touch框架中使用（Cocoa框架中的单例类有NSFileManager 、NSBundle 、NSWorkspace和NSApplication 等）。 1. UIApplicationUIApplication 类的实例提供了应用程序的集中控制点来保持应用的状态。UIApplication 实例总是分配给应用程序委托对象（UIApplicationDelegate ），通过应用程序委托对象来响应低内存、应用启动、后台运行和应用终止等事件。在HelloWorld 案例中，AppDelegate 就是这个应用程序的委托对象，它实现了UIApplicationDelegate协议。UIApplication 类有很多方法和属性，下面我们重点介绍其中几个：+ sharedApplication 方法。创建和获得UIApplication 实例的方法。idleTimerDisabled属性。设定和获得“空闲时间禁止”的状态。idleTimerDisabled属性的默认值是NO，即默认情况下系统会锁定屏幕。当idleTimerDisabled = YES 时，则不会开启“空闲时间禁止”状态，系统不会锁定屏幕。开启这项设定需要谨慎，它会使你的应用比较耗电。- openURL: 方法。可以打开一些内置的iOS 应用，其中包括打开浏览器、打开Google 地图、拨打电话、发送短信和发送E-mail 等。打开浏览器的示例代码如下：NSURL *url = [NSURL URLWithString:@"http://www.cnblogs.com/chars"];[[UIApplication sharedApplication] openURL:url];打开Google 地图时，实际上是通过内置浏览器来打开，示例代码如下：NSString* searchQuery = @"清华大学";searchQuery = [searchQuery stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding];NSString* urlString = [NSString stringWithFormat: @"http://maps.google.com/maps?q=%@", searchQuery];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:urlString]];其中NSString 的stringByAddingPercentEscapesUsingEncoding方法将字符串转换为URL编码，例如 “%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6 ”是“清华大学”的 URL 编码。 拨打电话时，苹果官方要求使用该方法调用内置拨号程序，示例代码如下：[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"tel://10010"]];发送短信时，苹果官方要求使用该方法调用内置发送短信程序，示例代码如下：[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"sms:10010"]];发送E-mail 时，这种方式可以发送简单的不带附件的E-mail ，示例代码如下：[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"mailto://eorient@sina.com"]];2.   UIAccelerometer单例类UIAccelerometer 前面也讲过，它可以访问重力加速计硬件设备，实时获得设备在x 轴、y轴和z 轴方向上的重力加速度。+ sharedAccelerometer方法是创建和获得UIAccelerometer实例的共享方法。与UIApplication类似，UIAccelerometer也有对应的委托对象，其委托对象为UIAccelerometerDelegate。UIAccelerometer 将实例分配给委托对象UIAccelerometerDelegate ，然后由委托对象响应重力加速计事件。3.   NSUserDefaults单例类NSUserDefaults可以很方便地读取应用设置项目。+ standardUserDefaults方法是创建和获得NSUserDefaults实例的静态方法。4.   NSNotificationCenter 单例类NSNotificationCenter提供信息广播通知，它采用观察者模式的通知机制。+ defaultCenter 方法是创建和获得NSNotificationCenter实例的共享方法。5.   NSFileManager NSFileManager 提供了访问文件系统的通用操作，可以定位、创建、复制文件和文件夹。在iOS 5和Mac OS X v10.7之后，它还可以管理存储在iCloud 上的数据。+ defaultManager 方法是创建和获得NSFileManager 实例的方法。除了该方法外，创建NSFileMa nager对象时还可以使用实例构造方法– init。这两种方法有着比较大的差别，+ defaultManager方法总是返回相同的NSFileManager 对象，但如果要使用委托（NSFileManagerDelegate）完成基于文件的操作并接收通知，应该使用– init 方法创建一个新的实例，而不是使用共享的对象。6.   NSBundle NSBundle 提供了动态加载（或卸载）可执行代码、定位资源文件以及资源本地化、访问文件系统等功能。+ mainBundle方法是创建和获得NSBundle 实例的共享方法。 尾声单例模式无疑是Cocoa框架下最重要的设计模式之一。灵活而有机地运用设计模式，意味着编程工作的高效性和产品健壮性、安全性的提高。因此，我们应该要善于使用设计模式，将自己的开发经验与代码、设计模式完美融合起来，提高软件代码质量。 ]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> objc </tag>
        
          <tag> 设计模式 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[设计模式 - 概述]]></title>
      <url>/blog/design-pattern-introduction/</url>
      <content type="text"><![CDATA[设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。什么是 GOF（四人帮，全拼 Gang of Four）？在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。  对接口编程而不是对实现编程。  优先使用对象组合而不是继承。设计模式的使用设计模式在软件开发中的两个主要用途。开发人员的共同平台设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。最佳的实践设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。设计模式的类型根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。创建型模式这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。  工厂模式（Factory Pattern）  抽象工厂模式（Abstract Factory Pattern）  单例模式（Singleton Pattern）  建造者模式（Builder Pattern）  原型模式（Prototype Pattern）结构型模式这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。  适配器模式（Adapter Pattern）  桥接模式（Bridge Pattern）  过滤器模式（Filter、Criteria Pattern）  组合模式（Composite Pattern）  装饰器模式（Decorator Pattern）  外观模式（Facade Pattern）  享元模式（Flyweight Pattern）  代理模式（Proxy Pattern）行为型模式这些设计模式特别关注对象之间的通信。  责任链模式（Chain of Responsibility Pattern）  命令模式（Command Pattern）  解释器模式（Interpreter Pattern）  迭代器模式（Iterator Pattern）  中介者模式（Mediator Pattern）  备忘录模式（Memento Pattern）  观察者模式（Observer Pattern）  状态模式（State Pattern）  空对象模式（Null Object Pattern）  策略模式（Strategy Pattern）  模板模式（Template Pattern）  访问者模式（Visitor Pattern）J2EE 模式这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。  MVC 模式（MVC Pattern）  业务代表模式（Business Delegate Pattern）  组合实体模式（Composite Entity Pattern）  数据访问对象模式（Data Access Object Pattern）  前端控制器模式（Front Controller Pattern）  拦截过滤器模式（Intercepting Filter Pattern）  服务定位器模式（Service Locator Pattern）  传输对象模式（Transfer Object Pattern）下面用一个图片来整体描述一下设计模式之间的关系：设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。2、里氏代换原则（Liskov Substitution Principle）里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。3、依赖倒转原则（Dependence Inversion Principle）这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。5、迪米特法则，又称最少知道原则（Demeter Principle）最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。6、合成复用原则（Composite Reuse Principle）合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
          <tag> 设计模式 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[list.h文件分析]]></title>
      <url>/blog/list-code-reading/</url>
      <content type="text"><![CDATA[structlist_head {       struct list_head *next, *prev; };一上来就放这么一个数据结构，那么，这个到底要做什么呢？没错，就如上面代码所示，本文的主角就是它，由它衍生而来的一些问题。首先自我介绍，它，来自Linux系统中的链表。就是个链表的头！是不觉得很奇怪？怎么只有两个指针域，没有数据域呢？其实笔者现在也纠结这这个问题着呢！没事，咱们先往下看。说不定什么时候，咱就明白了这是怎么一回事情呢。#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }#defineLIST_HEAD(name) \       struct list_head name = LIST_HEAD_INIT(name)这俩是宏没错吧！来看看这个俩到底是个什么意思。先来看看这个LIST_HEAD_INIT(name)，当程序当中出现了这个东西的时候，它立马就会替换成后面的东西，例如出现了：LIST_HEAD_INIT(headnode)；它立马就会替换成{&amp;(headnode),&amp;(headnode)}.假设有这么一段C代码 struct list_head headnode ;//定义了一个headnode节点 headnode = LIST_HEAD_INIT(headnode);那么它是不应该再编译阶段就立马的被替换成这样呢？ struct list_head headnode ;//定义了一个headnode节点 headnode = { &amp;(headnode), &amp;(headnode) };注意：这里面对标准的C进行了拓展叫：GNU C，这个意思呢就是说，对headnode的两个成员赋值。这赋值之后成了什么样子了呢？看下图：是不是自己指向了自己？至于为什么可以这么赋值，不是本文讨论的重点，详细的可以Google.其实这里的LIST_HEAD_INIT(name)宏是用来初始化的；而LIST_HEAD(name)宏则是用来定义+初始化。你看LIST_HEAD(name)宏是不比LIST_HEAD_INIT(name)宏多了这句 struct list_head name ？记住：LIST_HEAD_INIT(name)宏是用来初始化的；LIST_HEAD(name)宏则是用来定义+初始化。OK，我们接着往下看：static inline void INIT_LIST_HEAD(struct list_head *list){       list-&gt;next = list;       list-&gt;prev = list;}奇怪这里怎么好像又是在初始化，而且还和上面的功能一样。笔者觉得，他们这样做有如下考虑：有些人习惯于调用函数进行初始化，而有的人喜欢代码简洁而直接使用宏来进行初始化，但是不论是那种方式，都达到了一样的功能,即初始化。往下看，有关链表添加的#ifndef CONFIG_DEBUG_LISTstatic inline void __list_add(struct list_head *new,  struct list_head *prev,  struct list_head *next){       next-&gt;prev = new;       new-&gt;next = next;       new-&gt;prev = prev;       prev-&gt;next = new;}#elseextern void __list_add(struct list_head *new,  struct list_head *prev,  struct list_head *next);#endif注意 __list_add前面可是两个下划线；这个就是说，这个函数是linux内核的东西，使用的时候，就得注意了。一看名字就知道是增加链表节点；其实我们学习双向链表的时候，那么多的指针操作，能把人绕死，而且到最后也搞得不清楚，看看人家linux源代码是咋实现的：是不觉得有差距？往下看：static inline void list_add(struct list_head *new, struct list_head *head){       __list_add(new, head, head-&gt;next);}刚才不说了么，前头俩下划线的让谨慎的使用么，这不？又弄了一个函数，可以调用这个函数来进行链表的添加。实际上，还是调用的是刚才的那个有两个下划线的函数。这里体现了两个思想：1、封装，其实这个概念是C++等一类程序设计语言的OOP思想，用在了这里。2、重用，很多时候，代码其实都是可以不用自己写的，有一些现成的东西你可以去调用，这样可以很好的提高生产效率，而且linux源代码使用的是GPL许可证，没有什么版权啊乱七八糟的东西，有这么好的东西干嘛不用呢？其实下来的这个你会体会的更深：static inline void list_add_tail(struct list_head *new, struct list_head*head){       __list_add(new, head-&gt;prev, head);}看名字，看看list_add_tail这个名字。是不是“尾插法”？还是调用了前头的那个有两个下划线的函数吧？而且，仅仅只是调换了一下参数的次序。高明吧！好！再接着往下看：static inline void __list_del(struct list_head * prev, struct list_head * next){       next-&gt;prev = prev;       prev-&gt;next = next;} #ifndef CONFIG_DEBUG_LISTstatic inline void list_del(struct list_head *entry){       __list_del(entry-&gt;prev, entry-&gt;next);       entry-&gt;next = LIST_POISON1;       entry-&gt;prev = LIST_POISON2;}#elseextern void list_del(struct list_head *entry);#endif这里是删除一节点，这里再一次的体现了封装和重用的思想。不过这里注意：在将entry这个节点删除之后你得将它指向一个正确的错误区域！什么意思呢，就是说，你的将它放在一个大家公认的错误的地方，因为所有的人都不会去碰那个错误的地方，所以，你这个entry就不会引起各种不必要的麻烦。其实这里有一个问题：你free了某个节点之后，其实，我们还是可以使用这个节点的，这个在一篇博文里讲述的很清楚：http://blog.sina.com.cn/s/blog_6e9342530100yaef.html其实这里，LIST_POISON1= 0x00100100. LIST_POISON2=0x00200200。为什么，笔者不知道。下来接着看这个替换函数。将链表当中某个节点用新的节点替换掉。static inline void list_replace(struct list_head *old, struct list_head *new){       new-&gt;next = old-&gt;next;       new-&gt;next-&gt;prev = new;       new-&gt;prev = old-&gt;prev;       new-&gt;prev-&gt;next = new;}下面在给出图例：大家可以根据图例来理解。下来这个函数就是将某个链表里头的节点删除，然后添加到另外一个链表当中。你会发现代码很简单static inline void list_move(struct list_head *list, struct list_head *head){       __list_del(list-&gt;prev, list-&gt;next);       list_add(list, head);}下面这两个函数，一个用来判断是否为链表的最后一个节点，一个用来判断该链表是否为空。static inline int list_is_last(const struct list_head *list, const struct list_head *head){       return list-&gt;next == head;} static inline int list_empty(const struct list_head *head){       return head-&gt;next == head;}详细情况如下图：然而实际上，我们用这种方式来判断链表是否为空是不太精确的。它同时判断头指针的next和prev，仅当两者都指向自己时才返回真。这主要是为了应付另一个cpu正在处理同一个链表而造成next、prev不一致的情况。但代码注释也承认，这一安全保障能力有限：除非其他cpu的链表操作只有list_del_init()，否则仍然不能保证安全，也就是说，还是需要加锁保护。两个链表合并：static inline void __list_splice(const struct list_head *list, struct list_head *prev,  struct list_head *next){       struct list_head *first = list-&gt;next;       struct list_head *last = list-&gt;prev;        first-&gt;prev = prev;       prev-&gt;next = first;        last-&gt;next = next;       next-&gt;prev = last;} static inline void list_splice(const struct list_head *list, struct list_head *head){       if (!list_empty(list))              __list_splice(list, head, head-&gt;next);}假设当前有两个链表，表头分别是list1和list2（都是struct list_head变量），当调用list_splice(&amp;list1,&amp;list2)时，只要list1非空，list1链表的内容将被挂接在list2链表上，位于list2和list2.next（原list2表的第一个节点）之间。新list2链表将以原list1表的第一个节点为首节点，而尾节点不变。如图（虚箭头为next指针）：由于篇幅限制，当中其实，还有一些很有用的函数：比如切割啊，判断是否为单链表啊等等，其实当你再了解了这些函数之后，后面的都是大同小异。可以自己在做研究，下面将重点放在list.h当中的几个很重要的宏当中。还是顺着list.h往下看，你会看到第一宏：#define list_entry(ptr, type, member) \   container_of(ptr, type, member)看到上面的那英文注释：获得结构体入口！ptr：这个参数是指向list_head 类型的指针（注意这里，很容易再代码当中用错）。type：看到那英文解释了么？这个type可不是list_head！他是list_head嵌入的那个结构体类型。详细会给出一断源代码，帮助大家理解。member：这个看到名字就知道这个是结构体的一个成员。list_entry(ptr,type,member)这个宏到底是干嘛的，是不应该看container_of这个宏是干嘛的呢？用Sorce Insight 查看，会发现它在很多文件里头都存在，它们都是一样的，这里选取/include/linux/kernel.h当中的container_of宏来说明。#define container_of(ptr, type, member) ({        \   const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \   (type *)( (char *)__mptr - offsetof(type,member) );})这个宏的作用是：计算结构体成员member再结构体当中的相对位置（相对地址）。现在想想，开头的时候，是不是看到了这个链表的结构体定义只有指针域而没有数据域？现在就是要计算出嵌入了list_head结构的结构体的数据域的地址。struct stu{   int id；   struct list_head *next，*prev；}；就是要根据list_head类型的结构体计算出struct stu结构体当中成员id的地址。现在假设有如下定义:struct stu *p；struct list_head *r;r = p-&gt;next;现在我们肯定是可以直接通过p来访问struct  stu结构体当中的id的。但是这样做旧失去了其通用性，要知道内核当中链表的组织形式可是list_head。现在要如何才能够通过r访问的id呢？我们将宏container_of分开成两部分来看。const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);这里的typeof也是GNU C所拓展的。Typeof(x) 就是返回x的数据类型。我们先从最里面的括号开始看起吧，(type *)0先将0转化成type 类型的指针，此时地址为0x0。然后再引用member成员，即就是:((type *)0)-&gt;member 然后再加上typeof() 不就是返回member的数据类型么。再加上前面的const 后面的 * __mptr 。这是个什么意思？我们来个一个假设。假设member返回的数据类型是int。那么是不是就成了const int * __mptr = (ptr)?现在是不是明白了？typeof( ((type *)0)-&gt;member ) 这个东西，就是为了要得到member的数据类型。总结一下：这个就是为了定义一个member类型的指针，并且指向ptr(list_head类型)(type *)( (char *)__mptr - offsetof(type,member) );（char *）__mptr 将__mptr强制转化成char *类型，为什么转化成char* ，就是要获得__mptr指针的地址。而不是其他的类型呢？先来看offsetof这个宏吧。它被定义在/include/linux/stddef.h当中。#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)不着急，还是先从最里面的括号开始看起。(TYPE *)0)-&gt;MEMBER 这不是为了获取member么。在加个&amp; 获得他的地址、在加上(size_t) 强制转化成size_t 类型(其实也就是 unsigned int)。现在该注意了。刚才是不是说得到了type类型的指针的地址是0x0 ？ 你这里又得到了type类型指针成员member的地址。这个就是member的偏移地址吧！再将这两个合并起来看。将获得的__mptr指针的地址 ，减去member成员在其中的偏移量。就是member的地址了吧！！O(∩_∩)O~还有一个重要的问题？就是为什么要转化成char*，而不是其他的*？char类型的数据不论在什么类型的机器上，存储方式应该只是占了一个字节？因为它的实质是ascii码。这样的话，就好理解了，对char*减一 那就是实实在在的减一个字节；但是你要是对int*减一会实实在在的减多少？是不是4？（32位机器下）。这样一来，你怎么知道他的真实地址？可以根据下图来理解：下面再来看看和这个宏很类似的宏#define list_first_entry(ptr, type, member) \   list_entry((ptr)-&gt;next, type, member)和刚才唯一的区别就是ptr所代表的意思不同了，list_entry这个宏是用来获得链表的入口的。但是这里却是为了得到链表的第一个元素。详细的不再赘述。下来看看这个遍历宏：#define list_for_each(pos, head) \   for (pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \          pos = pos-&gt;next)这里prefetch其实还是一个宏，其作用是预取。作用是使得的便利更加快速、高效、安全，我们这里基本上可以不用考虑这些问题，故，使用的时候可以将该宏去掉。再来看看向前遍历的宏：#define list_for_each_prev(pos, head) \   for (pos = (head)-&gt;prev; prefetch(pos-&gt;prev), pos != (head); \          pos = pos-&gt;prev)跟上面遍历宏一样，其本质还是for循环，结束条件是遍历到了头！具体的双向循环链表就分析到这里，后面的还有一大堆的遍历宏，只不过也就是上面这几种宏的组合使用罢了；更有甚者，考虑了很多的安全性问题；比如：多线程、并发访问一链表等等，这些应该说在用户级别的程序不大会出现这类问题，我们大可不必注意；但是考虑到在OS当中，有很多是用到了链表；比如：在进程调度的时候，就绪队列、等等。在这个时候就不仅仅需要考虑链表的实现问题了，而且还得考虑安全问题。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> c </tag>
        
          <tag> 框架 </tag>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Xcode插件开发教程指南]]></title>
      <url>/blog/xcode-plugin-develop/</url>
      <content type="text"><![CDATA[对于Xcode而言，我们苹果开发者并不陌生，对于Xcode的插件，我们也不陌生。但是，有几个人做过Xcode插件呢？！Who care？显然，博主是关心的，这里分享一下博主自己开发插件的过程。在平时开发过程中我们使用了很多的Xcode插件，虽然官方对于插件制作没有提供任何支持，但是加载三方的插件，默认还是被允许的。第三方的插件，存放在 ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中，后缀名必须是.xcplugin ，其实际上是一种bundle。所以我们创建一个插件工程，直接创建bundle工程即可。然后通过修改后缀名为.xcplugin，将其放到~/Library/Application Support/Developer/Shared/Xcode/Plug-ins目录中即可。Xcode插件开发现在主要通过两种方式实现，其实也就是一种，只不过其中一种是使用别人提供的开发模板来省去很多中间步骤而已。文章会依次详细介绍两种的实现方法。准备工作方式一：通过Bundle实现1.创建Bundle工程2.工程设置插件工程和普通的bundle工程还是有区别的,所以需要进行特殊的设置。1）工程的plist文件添加三项：XCPluginHasUI = NOXC4Compatible = YESDVTPlugInCompatibilityUUIDs 这是一个数组。数组内容字符串，指示了该插件兼容的Xcode版本，只有对应版本的Xcode的UIID加入这个数组，插件才能被加载。否则，即使将插件放入Xcode的插件文件夹，插件也不会被加载。获取当前版本的Xcode的UUID方式：在terminal中输入命令：defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUIDterminal会返回一串字符串，这就是Xcode的DVTPlugInCompatibilityUUID。2）Build SettingInstallation Build Products Location 设置为 ${HOME} [显示的时候,显示的是你的用户目录]，这个是products的根目录。Installation Directory 设置为 /Library/Application Support/Developer/Shared/Xcode/Plug-ins，这个是指定你的插件安装的目录。注意，这里填入的其实是相对目录。插件的绝对目录是这样的，例如 /Users/yohunl/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin ，最后的绝对目录是 Installation Build Products Location和Installation Directory的结合，这也是为什么两者都要设置的原因。Deployment Location 设置为 YES，这个是指示该工程不使用设置里的build location，而是用Installation Directory来确定build后放置的位置。默认工程生成的相关文件位置都是 Build Locations指定的，通过Deployment Location 设置为 YES告诉工程，我们不使用这个默认的设置，而是我们自定义的。Wrapper extension 设置为 xcplugin，后缀名必须为xcplugin，否则不会被加载。方式二：通过模板实现1）下载Xcode插件开发模板地址：https://github.com/kattrali/Xcode-Plugin-Template2）将下载下来的template复制到 ~/Library/Developer/Xcode/Templates/Project Templates/Application Plug-in/Xcode Plugin.xctemplate文件夹中，如果没有对应的文件夹就自己手动创建一个。3）重启Xcode，当你新建一个工程的时候就可以在OS X中看到一个Application Plug-in的选项，里面有一个Xcode Plug-in模板。实现通过以上的两种准备方式，我们已可以创建Xcode插件工程，接下来就是如何实现插件功能。1.功能需求在当前选中文件中实现代码风格重构，目前主要实现setter方法这一风格重构。例如，[self setName:@"Davy"]; ==&gt; self.name = @"Davy";2.思路分析1）找到当前文件中符合setter方法命名风格的方法调用。2）替换找到的符合重构风格的代码，提醒用户保存。3.技术难点1）Xcode代码编辑框文件内容操作。2）正则表达式书写。3）Xcode代码编辑框提醒用户保存文件。关于最后一点，因为Xcode对于没有保存的已修改过的文件会显灰以提示用户该文件需要保存，我们可以借鉴这种方式。另外，在查找时，如果能够实现高亮并且跟随滚动，效果会更佳。4.关键代码以上这些问题，本人在“Refactor Code”插件中全部实现，现在放上关键方法。1）添加菜单-(void) setupMenuItem {    // Menu Item:    NSMenuItem *editMenuItem = [[NSApp mainMenu] itemWithTitle:@"Edit"];    if (editMenuItem) {        [[editMenuItem submenu] addItem:[NSMenuItem separatorItem]];        NSMenu *refactorCodeMenu = [[NSMenu alloc] initWithTitle:@"Refactor Code"];        NSMenuItem *menuItem;        menuItem = [[NSMenuItem alloc] initWithTitle:@"Refactor Method Style" action:@selector(refactorMethodStyleMenuAction) keyEquivalent:@""];        [menuItem setTarget:self]; [refactorCodeMenu addItem:menuItem];        NSMenuItem *refactorCodeMenuItem = [[NSMenuItem alloc] initWithTitle:@"Refactor Code" action:nil keyEquivalent:@""];        [refactorCodeMenuItem setSubmenu:refactorCodeMenu];        [[editMenuItem submenu] addItem:refactorCodeMenuItem];    }}效果图如下：2）显示操作面板- (void)refactorMethodStyleMenuAction {    [self.operateController showWindow:nil];    NSURL *url = [[NSBundle bundleForClass:[self class]] URLForResource:@"DZOperateController" withExtension:@"nib"];    if (!url) {        NSAlert *alert = [[NSAlert alloc] init];        alert.messageText = @"Refactor Method Style could not be shown because the plugin is corrupted.";        alert.informativeText = @"If you build the plugin from sources using Xcode, make sure to perform “Clean Build Folder“ in　　　　　　　　Xcode and then build the plugin again.\n\nIf you installed the plugin via Alctraz, there is a pending issue causing　　　　　　　　some files to be missing in the plugin. Prefer to install it via the plugin webpage.";        [alert addButtonWithTitle:@"Download Latest"];        [alert addButtonWithTitle:@"Cancel"];        NSModalResponse result = [alert runModal];        if (result == NSAlertFirstButtonReturn) {            [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:@"https://github.com/CharsDavy/RefactorCodePlugin-Xcode"]];        }    }}效果图如下：3）查找替换代码风格这一部分是重点部分，包括如何书写正则表达式，并且利用正则表达式生成替换字符。还包括高亮代码，具体可以参见本人源码：https://github.com/CharsDavy/RefactorCodePlugin-Xcode4）最终效果图提交插件至Alcatraz1.打开Alcatraz的插件包仓库，地址：https://github.com/supermarin/alcatraz-packages2.在简介里可以看到Alcatraz的包分为三类，分别为：插件(plugins)，配色方案(color schemes)和模板(templates)。每个包都必须包含”name”、”url”和”description”字段，还有一个可选的”screenshot”字段。3.Fork这个仓库，再克隆到本地。4.以添加”Refactor Code”插件为例，打开packages.json文件，在”plugins”数组里加入：{   "name": "Refactor Code",  "url": "https://github.com/CharsDavy/RefactorCodePlugin-Xcode.git",  "description": "Refactor code style,such as setter method.",  "screenshot": "https://github.com/CharsDavy/RefactorCodePlugin-Xcode/raw/master/Screenshots/window.png"}5.提交代码到Fork的地址，再提交一个pull request到Master即可。6.merged成功之后，即可看见以下效果图希望对大家有所帮助。]]></content>
      <categories>
        
          <category> project </category>
        
      </categories>
      <tags>
        
          <tag> application </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[聊聊 class-dump 使用]]></title>
      <url>/blog/class-dump-using/</url>
      <content type="text"><![CDATA[class-dump is a command-line utility for examining the Objective-C segment of Mach-O files. It generates declarations for the classes, categories and protocols. This is the same information provided by using ‘otool -ov’, but presented as normal Objective-C declarations.上面是class-dump的官方解释，我们用的最多就是做iOS的逆向工程。class-dump，是可以把Objective-C运行时的声明的信息导出来的工具。其实就是可以导出.h文件。用class-dump可以把未经加密的app的头文件导出来。官方网址：http://stevenygard.com/projects/class-dump/安装class-dump的下载地址：http://stevenygard.com/download/class-dump-3.5.tar.gz点击下载后解压后会有class-dump和源码文件。将class-dump 复制到/usr/bin/class-dump。如果是OS X 10.11，因为没有/usr/bin文件夹的写权限，所以将class-dump复制到/usr/local/bin/class-dump即可。同时打开Terminal，执行命令赋予其执行权限：$ sudo chmod 777 /usr/bin/class-dump使用使用class-dump导出头文件的命令格式：class-dump -H 需要导出的框架路径 -o 导出的头文件存放路径示例：导出Xcode中DVTKit框架的头文件1）找到DVTKit框架路径2）使用上述的操作命令格式$ class-dump -H /Applications/Xcode.app/Contents/SharedFrameworks/DVTKit.framework/Versions/A/DVTKit -o ~/local/DVTKit附录class-dump AppKit:class-dump /System/Library/Frameworks/AppKit.frameworkclass-dump UIKit:class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.frameworkclass-dump UIKit and all the frameworks it uses:class-dump /Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS4.3.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-ios 4.3class-dump UIKit (and all the frameworks it uses) from developer tools that have been installed in /Dev42 instead of /Developer:class-dump /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk/System/Library/Frameworks/UIKit.framework -r --sdk-root /Dev42/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
          <tag> 逆向 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[说说那些iOS笔试题]]></title>
      <url>/blog/ios-test-in-writing/</url>
      <content type="text"><![CDATA[博主之前从事嵌入式开发，本科专业软件工程。毕业后一直从事嵌入式C语言。之所以进入嵌入式行业，完全是个人兴趣。不过，在从业两年之后发现不是自己喜欢的菜。毅然决然的转型到iOS行业。然，博主并非参加培训学校出来，完全利用工作之余时间自学，现在已经在ZAKER工作，从事ZAKER客户端的iPhone版本开发。这里，博主分享一下之前找工作时，总结的笔试题。题目与答案答案仅供参考，如有异议或者错误，请指正。中文试题  #import 跟#include、@class有什么区别？#import&lt;&gt;跟 #import""又什么区别？1) #import和#include都能完整地包含某个文件的内容，#import能防止同一个文件被包含多次2) @class仅仅是声明一个类名，并不会包含类的完整声明;@class还能解决循环包含的问题3) #import &lt;&gt;用来包含系统自带的文件，#import “”用来包含自定义的文件  属性readwrite，readonly，assign，retain，copy，nonatomic各是什么作用，在那种情况下用？readwrite：同时生成get方法和set方法的声明和实现readonly：只生成get方法的声明和实现assign：set方法的实现是直接赋值，用于基本数据类型retain：set方法的实现是release旧值，retain新值，用于OC对象类型copy：set方法的实现是release旧值，copy新值，用于NSString、block等类型nonatomic：非原子性，set方法的实现不加锁（比atomic性能高）  写一个setter方法用于完成@property （nonatomic,retain）NSString *name,写一个setter方法用于完成@property（nonatomic，copy）NSString *name.@property (nonatomic, retain) NSString *name;- (void)setName:(NSString *)name{	if (_name != name) {		[_name release];		_name = [name retain];}}@property(nonatomic, copy) NSString *name;- (void)setName:(NSString *)name{	if (_name != name) {		[_name release];		_name = [name copy];}}  对于语句NSString*obj = [[NSData alloc] init]; ，编译时和运行时obj分别是什么类型？编译时是NSString类型运行时是NSData类型  常见的object-c的数据类型有那些，和C的基本数据类型有什么区别？常用OC类型：NSString、NSArray、NSDictionary、NSData、NSNumber等OC对象需要手动管理内存，C的基本数据类型不需要管理内存  id 声明的变量有什么特性？id声明的变量能指向任何OC对象  Objective-C如何对内存管理的,说说你的看法和解决方法?每个对象都有一个引用计数器，每个新对象的计数器是1，当对象的计数器减为0时，就会被销毁通过retain可以让对象的计数器+1、release可以让对象的计数器-1还可以通过autorelease pool管理内存如果用ARC，编译器会自动生成管理内存的代码  内存管理的几条原则时什么？按照默认法则.哪些方法生成的对象需要手动释放？在和property结合的时候怎样有效的避免内存泄露？只要调用了alloc、copy、new方法产生了一个新对象，都必须在最后调用一次release或者autorelease只要调用了retain，都必须在最后调用一次release或者autorelease@property如果用了copy或者retian，就需要对不再使用的属性做一次release操作如果用了ARC，另外讨论.  看下面的程序,三次NSLog会输出什么？为什么？NSMutableArray* ary = [[NSMutableArray array] retain];  NSString *str = [NSString stringWithFormat:@"test"];  // 1 [strretain];   // 2[aryaddObject:str]; // 3  NSLog(@"%d",[str retainCount]);  [strretain];  // 4[strrelease];   // 3[strrelease];   // 2NSLog(@"%d",[str retainCount]);  [aryremoveAllObjects]; // 1  NSLog(@"%d",[str retainCount]);  结果：3、2、1  OC中创建线程的方法是什么？如果指定在主线程中执行代码？如何延时执行代码？创建线程的方法NSThreadNSOperationQueue和NSOperationGCD主线程中执行代码[self performSelectorOnMainThread: withObject: waitUntilDone:];[self performSelector: onThread:[NSThreadmainThread] withObject: waitUntilDone:];dispatch_async(dispatch_get_main_queue(), ^{});延时执行double delayInSeconds = 2.0;dispatch_time_tpopTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));dispatch_after(popTime, dispatch_get_main_queue(), ^(void){        });[self performSelector: withObject: afterDelay:];[NSTimer scheduledTimerWithTimeInterval: target: selector: userInfo: repeats:];英文试题提示： 一定要把英文题目过一遍，有些公司的题目故意弄成英文的。  Difference between shallow copy and deep copy?浅拷贝：指针（地址）拷贝，不会产生新对象深拷贝：内容拷贝，会产生新对象  What is advantage of categories? What is difference between implementing a category and inheritance?分类可以在不修改原来类模型的基础上拓充方法分类只能扩充方法、不能扩充成员变量；继承可以扩充方法和成员变量继承会产生新的类  Difference between categories and extensions?分类是有名称的，类扩展没有名称分类只能扩充方法、不能扩充成员变量；类扩展可以扩充方法和成员变量类扩展一般就写在.m文件中，用来扩充私有的方法和成员变量（属性）  Difference between protocol in objective c and interfaces in java?Java的接口中声明的方法必须都实现Oc的protocol中声明的方法并不一定要实现  What are KVO and KVC?KVC是键值编码，可以通过一个字符串的key（属性名）修改对象的属性值KVO是键值监听，可以监听一个对象属性值的改变  What is purpose of delegates?两个对象之间传递数据和消息解耦，拆分业务逻辑  What are mutable and immutable types in Objective C?mutable是可变类型，比如NSMutableArray，可以动态往里面添加元素immutable是不可变类型，比如NSArray，固定的存储空间，不能添加元素  When we call objective c is runtime language what does it mean?动态绑定：对象类型在运行时才真正确定多态性消息机制  what is difference between NSNotification and protocol?通过NSNotification可以给多个对象传递数据和消息通过protocol（代理模式）只能给一个对象传递数据和消息  What is push notification?本地推送：程序内部弹出通知到用户设备远程推送：由推送服务器推送通知到用户设备  What is Polymorphism？多态：父类指针指向子类对象  What is Singleton?单例：保证程序运行过程中，永远只有一个对象实例目的是：全局共享一份资源、节省不必要的内存开销  What is responder chain?响应者链：UIResponder有一个nextResponder属性，通过该属性可以组成一个响应者链，事件或消息在其路径上进行传递如果UIResponder没有处理传给它的事件，会将未处理的消息转发给自己的nextResponder  Difference between frame and bounds?frame以父控件的左上角为坐标原点bounds以控件本身的左上角为坐标原点  Difference between method and selector?通过一个selector可以找到方法地址，进而调用一个方法  Is there any garbage collection mechanism in Objective C.?OC 1.0没有垃圾回收OC 2.0有垃圾回收，只能用在Mac上iOS中有ARC机制，是编译器特性，垃圾回收是运行时特性  What is NSOperation queue?用来存放NSOperation对象的队列，可以用来异步执行一些操作一般可以用在网络请求等耗时操作  Can we use one tableview with two different datasources? How you will achieve this?从对象属性上分析，tableView只有一个dataSource属性。当然，真要使用两个不同的数据源，还是有其他办法解决的  Can we use two tableview controllers on one viewcontroller?从技术角度上分析，一个控制器内部添加两个表格控制器是没有问题的  What is lazy loading?延迟加载：比如控制器的view，在第一次用到view时才会调用loadView方法进行创建  链表不具备的特点是（）A. 可随机访问任何一个元素B. 插入，删除操作不需要移动元素C. 无需事先估计存储空间大小D. 所欲存储空间可以是不连续的参考答案： （A）链表不同于数组。链表之所有叫链表，就是像一条链一样，要过到某个节点处，就得遍历着找；而数组才具备随机访问任何一个元素的能力，数组可以通过索引直接访问元素，时间复杂度为常量，效率非常高，因此在某些场合上，我们需要数组这样的数据结构。B. 链表的插入、删除都不需要移动元素，只需要修改指针的指向就可以了，因为链表上的每个节点都是动态分配的，分配在堆上，通过指针来指向每个节点的内存区，要获取某个节点的值，是需要遍历一遍才能找到对应的节点的。C. 因为链表上的每个节点是分配在堆上，需要开发人员手动申请内存空间的，因此不像数组在定义时就要指定存储空间大小。对于链表，需要增加一个节点时，直接在堆上申请。当需要删除某个节点时，可以直接将该节点的内存给释放掉。D. 因为链接中的节点都是存储在堆上的，而每个节点之间都有一个指向前一个节点和后一个节点的指针，只要知道链表头指针，就可以通过遍历查找到任何一个节点。因此，链表不同于数组，数组是要连续的内存存储空间，才能保证以常量时间复杂度快速访问任意元素；而链表不要求每个节点是连接，在堆上申请的内存空间很难得到连续的，而且空间产生内存碎片。  关于多线程和多进程编程，下面描述正确的是（）A. 多进程里，子进程可获取父进程的所有堆和栈的数据；而线程会与同进程的其他线程共享数据，拥有自己的栈空间。B. 线程因为有自己的独立栈空间且共享数据，所有执行的开销相对较大，同时不利于资源管理和保护。C. 线程的通信速度更快，切换更快，因为他们在同一地址空间内。D. 线程使用公共变量/内存时需要使用同步机制，因为他们在同一地址空间内。  设两个变量a=19;b=29;在不创建新实例的情况下使a、b的值互换？参考答案：这道题要求不创建新的实例，只有a、b两个变量，要交换这两个变量的值，通常的做法是使用临时变量来临时存储，但是现在要求不使用新的实例，那么有什么办法呢？方法就是通过位运算来操作：a = a ^ b;b = a ^ b;a = a ^ b;对于题目中的a = 19，也就是对应二进制00010011；而b=29，也就是对应二进制00011101第一步：a = 00010011 ^ 00011101 =&gt; 00001110，将a、b的值都记录下来了第二步：b = 00001110 ^ 00011101 =&gt; 00010011（值为19，也就是b得到了原来的a的值）第三步：a = 00001110 ^ 00010011 =&gt; 00011101 (值为29，也就是a得到了原来的b的值)注意，符号表示按位异或。所谓按位异或是指对应位置上的二进制数值相同为0，不同为1。  使用block时什么情况会发生引用循环，如何解决？参考答案：http://www.henishuo.com/ios-block-memory-cycle  为什么要序列化，对象序列化方式？参考答案：将对象JSON序列化：NSLog(@"%s", __FUNCTION__);NSDictionary *dict = @{@"key"  : @"value",                     @"key1" : @"value1",                     @"key2" : @"value2"};NSData *data = [NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];NSLog(@"%@", [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);将对象归档：需要遵守NSCoding协议，实现如下方法：- (void)encodeWithCoder:(NSCoder *)aCoder {  [aCoder encodeObject:self.title forKey:@"title"];}  简述如何处理UI与耗时操作的通信，有哪些方式及各自的优缺点？参考答案：1）将耗时的计算和IO操作放在子线程去处理，然后到主线程更新UI。优点是采用预加载方式，将耗时操作提前处理。优点是可让UI更流畅；缺点是内存会增多，控制加载逻辑比较复杂。2）采用延迟加载方式，将耗时操作而不立刻使用时，采用延迟加载。优点是界面可提高流畅度；缺点是在需要显示时还需要加载才能显示，需要稍稍等待。  如何优化一个TableView？参考答案：1）若高度一定，直接使用rowHeight属性而不是使用heightForRowAtIndexPath方法，以减少调用的消耗。若高度是不固定的，heightForRowAtIndexPath所计算的高度应该缓存起来，每次数据源发生变化时，比如删除、插入、更新行都会重新请求所有的高度。若有100个行，就会有调用100次，因为将高度缓存起来是应该的。同理，heightForHeaderInSection、heightForFooterInSection也应该缓存起来。2）不要在tableView:cellForRowAtIndexPath:中做太多的计算和IO操作，比如可以将需要的计算提前计算好、IO操作也提前计算好。它应该直接调用来显示就可以。3）将计算行高的时间提前到从服务器获取数据的时候，计算完了高度一并写回数据库或者通过转型为model，将高度放到模型中。但是，最好将高度缓存起来。若一个model的数据有不同的状态，比如展开与收起状态，应该也将高度都缓存起来。注意使用异步去计算，计算完成后再回到主线程显示。4）在设置显示图片时，不要直接设置UIImageView的contentMode属性自动适应，图片变形会计算transform，压缩时会乘以一个矩阵，消耗性能。对于要求性能较高的app，应该将得到的图片经过处理成UIImageView大小后再呈现。5）不要将视图的opaque属性设置为NO，默认为YES,它表示不透明度。当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果。6）layer添加圆角是比较耗时的，这样会离屏渲染，需要牺牲更多的性能。比如，图片显示有圆角时，可以通过core graphics来生成带圆角的图片等。7）手动绘制cell。绘制cell不建议使用UIView，建议使用CALayer。 UIView的绘制是建立在CoreGraphic上的，其使用的是CPU。CALayer使用的是Core Animation，CPU、GPU都可以使用且由系统自动决定使用哪一个。UIView的绘制，使用的是自下向上的一层一层的绘制，而后渲染。Layer处理的是纹理，利用GPU的 Texture Cache和独立的浮点数计算单元可以加速纹理的处理。8）重用cell。防止重复的绘制，减少渲染次数，可提高性能。9）减少subviews的数量。尽量放在同一层view上显示。10）尽量少动态给cell添加子view。用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示。更多参看：http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/简答题  假设类SomeClass中声明了一个委托属性delegate，该属性遵守自定义委托协议SomeDelegate，请写出该类和对应委托协议的定义？@protocol SomeDelegate&lt;NSObject&gt;@required //必须要实现的方法@optional //可选实现的方法@end@interface SomeClass@property (nonatomic, assign)id &lt;SomeDelegate&gt; delegate;@end  简述UITableView的重用机制，并写出实现该机制的关键代码？关键代码：UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cellId"];    if (cell == nil) {        cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cellId"];    }      简述推送实现步骤？        定义一个带参宏，返回两个参数中较小的那个？        strong和weak分别起什么作用？有什么区别？        执行下面程序后NSLog的输出结果为（  C  ）？  A.1，1    B.2，1    C.2，5    D.运行错误int a[5] = {1,2,3,4,5};int *ptr = (int *)(&amp;a+1);NSLog(@“%d,%d”, *(a+1), *(ptr-1));  执行下面程序后NSLog的输出结果为（  B  ）？A.a，a1，a1    B.a1，a1，a1    C.a1，a，a    D.a1，a1，aint main(int argc, char *argv[]){    NSArray *mArray1 = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@"a"], @"b", @"c", nil];        NSArray *mArrayCopy2 = [mArray1 copy];        NSMutableArray *mArrayMCopy1 = [mArray1 mutableCopy];        NSMutableString *testString = [mArray1 objectAtIndex:0];        [testString appendString:@"1"];        NSLog(@"%@,%@,%@", [mArray1 objectAtIndex:0],[mArrayCopy2 objectAtIndex:0],[mArrayMCopy1 objectAtIndex:0]);    return 0;}      Cocoa中所有的类都是（  NSObject和NSProxy  ）的子类。        列举几个Cocoa Touch框架？  Foundation、UIKit、Core Data  下面机型屏幕分辨率分别是多少？iPhone4、4S：960X640iPhone5、5S、5C：1136X640iPhone6：375X667iPhone6 Plus：414X736iPad mini：1024X768iPad mini 2：2048X1536iPad Air：2048X1536iPad Air 2：2048X1536  Objective-C中的线程类是（   NSThread ），常见方法有哪些（  dispatch_async  ）、（  dispatch_sync  ），处理多线程同步有哪些类（    ）。数据库现有MySQL数据库，分别对下表写出要求的SQL语句，用到实例数据请自行给出即可。表结构如下：            字段名      类型                  UserID      Integer              UserName      varchar(20)              Password      varchar(20)      创建表：CREATE  TABLE `test`.`table_a` (  `UserID` INT NOT NULL ,  `UserName` VARCHAR(20) NULL ,  `Password` VARCHAR(20) NULL ,  PRIMARY KEY (`UserID`) );增加记录：insert into `test`.`table_a` ( `UserName`, `UserID`, `Password`) values ( 'cd', '10', '123')删除记录：delete from `test`.`table_a` where `UserID`=’10'修改记录：update `test`.`table_a` set `Password`='12346' where `UserID`='10' 编程题1.请通过接口“http://someurl/somefunc”获取数据，并在UI上显示。接口入参argu是一个字符串类型的变量，返回值是字典。1）使用NSURL相关API实现网络加载类，其中：通过post方法发送请求，建立异步连接；2）报文采用JSON格式；3）多线程采用GCD或NSOperation实现；4）以左边键右边值的格式在界面上显示结果。2.传入数组*array和数组长度length，实现冒泡排序算法。int *BubbleSort(int *array, int length);int *BubbleSort(int *array, int length) {    int i = 0, j = 0, temp = 0;    if (NULL == array) {        return NULL;    }    for (i = 0; i &lt; length; i++) {        for (j = i; j &lt; length; j++) {            if (*(array + i) &gt; *(array + j)) {                temp = *(array + i);                *(array + i) = *(array + j);                *(array + j) = temp;            }        }    }    return array;}]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Objective-C中的引用计数]]></title>
      <url>/blog/objc-quote-count/</url>
      <content type="text"><![CDATA[Objective-C语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数为0，就表示没人关注此对象了，于是，就可以把它销毁。在Objective-C中称之为引用计数，本文主要分享引用计数相关知识。导言Objective-C语言使用引用计数来管理内存，也就是说，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数；用完了之后，就递减其计数。计数为0，就表示没人关注此对象了，于是，就可以把它销毁。从Mac OS X 10.8开始，“垃圾收集器”（garbage collector）已经正式废弃了，以Objective-C代码编写Mac OS X程序时不应再使用它，而iOS则从未支持过垃圾收集。因此，掌握引用计数机制对于学好Objective-C来说十分重要。Mac OS X程序已经不能再依赖垃圾收集器了，而iOS系统不支持此功能，将来也不会支持。已经用过ARC的人可能会知道：所有与引用计数有关的方法都无法编译，然而现在先暂时忘掉这件事。那些方法确实无法用在ARC中，不过本文就是要从Objective-C的角度讲解引用计数，而ARC实际上也是一种引用计数机制，所以，还是要谈谈这些在开启ARC功能时不能直接调用的方法。工作原理在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活下去。这在Objective-C中叫做“保留计数”（retain count），不过也可以叫“引用计数”（reference count）。NSObject协议声明了下面三个方法用于操作计数器，以递增或递减其值：1）retain 递增保留计数。2）release 递减保留计数。3）autorelease 待稍后清理“自动释放池”（autorelease pool）时，再递减保留计数。上图是对象创建及保留计数操作的效果图。上图对象图中，ObjectB与ObjectC都引用了ObjectA。若ObjectB与ObjectC都不再使用ObjectA，则其保留计数降为0，于是便可摧毁了。还有其他对象想令ObjectB与ObjectC继续存活，而应用程序里又有另外一些对象想令那些对象继续存活。如果按“引用树”回溯，那么最终会发现一个“根对象”（root object）。在Mac OS X应用程序中，此对象是NSApplication对象；而在iOS应用程序中，则是UIApplication对象。两者都是应用程序启动时创建的单例。下面这段代码有助于理解这些方法的用法：NSMutableArray *array = [[NSMutableArray alloc] init];NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];//do something with 'array'[array release];由于代码中直接调用了release方法，所以在ARC下无法编译。在Objective-C中，调用alloc方法所返回的对象由调用者所拥有。也就是说，调用者已通过alloc方法表达了想令该对象继续存活下去的意愿。不过，这并不是说对象此时的保留计数就是1。在alloc或“initWithInt:”方法的代码实现中，也许还有其他对象也保留了此对象。绝不能说保留计数一定是某个值，只能说你所执行的操作的递增了该计数还是递减了该计数。创建完数组后，把number对象加入其中。调用数组的“addObject:”方法时，数组也会在number上调用retain方法，以期继续保留此对象。这时，保留计数至少为2。接下来，代码不再需要number对象了，于是将其释放。现在的保留计数至少为1。这样就不能照常使用number变量了。调用release之后，已经无法保证所指的对象仍然存活。当然，根据本例中的代码，我们显然知道number对象在调用了release之后仍然存活，因为数组还在引用着它。然而绝不应该假设此对象一定存活，也就是说，不要像下面这样子编写代码：NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];NSLog(@"number = %@", number);即便上述代码在本例中可以正常执行，也仍然不是个好办法。如果调用release之后，基于某些原因，其保留计数降至为0，那么number对象所占内存也许会回收，这样的话，再调用NSLog可能就将使程序崩溃了。为什么是“可能”，因为对象所占的内存在“解除分配”（deallocated）之后，只是放回“可用内存池”（avaiable pool）。如果执行NSLog时还尚未覆写对象内存，那么该对象仍然有效，这是程序不会崩溃。故，因过早释放对象而导致的bug很难调试。为避免在不经意间使用了无效对象，一般调用完release之后都会清空指针。这就能保证不会出现可能指向无效对象的指针，这种指针通常称为“悬挂指针”（dangling pointer）。例如，可以这样编写代码来防止此情况发生：NSNumber *number = [[NSNumber alloc] initWithInt:1337];[array addObject:number];[number release];number = nil;属性存取方法中的内存管理如前所述，对象图由相互关联的对象所构成。刚才那个例子中的数组通过在其元素上调用retain方法来保留那些对象。不光数组，其他对象也可以保留别的对象，这一般通过访问“属性”来实现，而访问属性时，会用到相关实例变量的获取方法和设置方法。若属性为“strong关系”（strong relationship），则设置的属性值会保留。比方说，有个名叫foo的属性由名为_foo的实例变量所实现，那么，该属性的设置方法会是这样：-(void)setFoo:(id)foo {     [foo retain];    [_foo release];     _foo = foo;}此方法将保留新值并释放旧值，然后更新实例变量，令其指向新值。顺序很重要。假如还未保留新值就先把旧值释放了，而两个值又指向同一个对象，那么，先执行release操作就可能导致系统将此对象永久回收。而后续的retain操作则无法令这个已经彻底回收的对象复生，于是实例变量就成了悬挂指针。自动释放池在Objective-C的引用计数架构中，自动释放池是一项重要特性。调用release会立刻递减对象的保留计数（而且还可能令系统回收此对象），然而有时候可以不调用它，改为调用autorelease，此方法会在稍后递减计数，通常是在下一次“事件循环”（event loop）时递减，不过也可能执行得更早些。 此特性很有用，尤其是在方法中返回对象时更应该用它。在这种情况下，我们并总是想令方法调用者手工保留其值。比方说，有下面这个方法：-(NSString *)stringValue {     NSString *str = [[NSString alloc] initWithFormat:@"I am this: %@", self];     return str;}此时返回的str对象其保留计数比期望值要多1，因为调用者alloc会令保留计数加1，而又没有与之对应的释放操作。保留计数多1，就意味着调用者要负责处理多出来的这一次保留操作。必须设法将其抵消。这并不是说保留计数本身就一定是1，它可能大于1，不过那取决于“initWithFormat:”方法内的实现细节。你要考虑的是如何将多出来的这一次保留操作抵消掉。但是，不能在方法呢你释放str，否则还没等方法返回，系统就把该对象回收了。这里应该用autorelease，它会在稍后释放对象，从而给调用者留下了足够长的时间，使其可以在需要时先保留返回值。换句话说，此方法可以保证对象在跨越“方法调用边界”（method call boundary）后一定存活。实际上，释放操作会在清空最外层的自动释放池时执行，除非你有自己的自动释放池，否则这个时机指的就是当前线程的下一次事件循环。改写stringValue方法，使用autorelease来释放对象：-(NSString *)stringValue {     NSString *str = [[NSString alloc] initWithFormat:@"I am this: %@", self];     return [str autorelease];}修改之后，stringValue方法把NSString对象返回给调用者，此对象必然存活。所以我们能够如此使用它：NSString *str = [self stringValue];NSLog(@"The string is: %@", str);由于返回的str对象将于稍后自动释放，所以多出来的那一次保留操作时自然就会抵消，无须再执行内存管理操作。因为自动释放池中的释放操作要等到下一次事件循环时才会执行，所以NSLog语句在使用str对象前不需要手工执行保留操作。但是，假如要持有此对象的话（比如将其设置给实例变量），那就需要保留，并于稍后释放：_instanceVariable = [[self stringValue] retain];//...[_instaceVariable release];由此可见，autorelease能延长对象生命期，使其在跨越方法调用边界后依然可以存活一段时间。保留环使用引用计数机制时，经常要注意的一个问题就是“保留环”（retain cycle），也就是呈环状相互引用的多个对象。这将导致内存泄露，因为循环中的对象其保留计数不会降为0。对于循环中的每个对象来说，至少还有另外一个对象引用着它。如上图，在这个循环里，所以对象的保留计数都是1。在垃圾收集环境中，通常将这种情况认定为“孤岛”（island of isolation）。此时，垃圾收集器会把三个对象全部回收。而在Objective-C的引用计数架构中，则享受不到这一便利。通常采用“弱引用”（weak reference）来解决此问题，或是从外界命令循环中的某个对象不再保留另外一个对象。这两种办法都能打破保留环，从而避免内存泄露。 小结引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁。在对象生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[socket 通信简介]]></title>
      <url>/blog/socket-communicate-introduction/</url>
      <content type="text"><![CDATA[我们深谙信息交流的价值，那网络中进程之间如何通信，如我们每天打开浏览器浏览网页时，浏览器的进程怎么与web服务器通信的？当你用QQ聊天时，QQ进程怎么与服务器或你好友所在的QQ进程通信？这些都得靠socket？那什么是socket？socket的类型有哪些？还有socket的基本函数，这些都是本文想介绍的。1 网络中进程之间如何通信本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：  消息传递（管道、FIFO、消息队列）  同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）  共享内存（匿名的和具名的）  远程过程调用（Solaris门和Sun RPC） 但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。 2 什么是socket上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写read /write –&gt; 关闭close”模式来操作。我的理解就是socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。socket一词的起源在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。” 3 socket的基本操作既然Socket是“open—read/write—close”模式的一种实现，那么Socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。3.1 socket()函数int socket(int domain, int type, int protocol);socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：1）domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。2）type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。3）protocol：顾名思义，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。 3.2 bind()函数正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);函数的三个参数分别为：1）sockfd：即socket描述字，它是通过socket()函数创建，唯一标识一个socket。bind()函数就是给这个描述字绑定一个名字。2）addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，例如，ipv4对应的是：struct sockaddr_in {    sa_family_t    sin_family; /* address family: AF_INET */    in_port_t      sin_port;   /* port in network byte order */    struct in_addr sin_addr;   /* internet address */};/* Internet address. */struct in_addr {    uint32_t       s_addr;     /* address in network byte order */};ipv6对应的是：struct sockaddr_in6 {     sa_family_t     sin6_family;   /* AF_INET6 */     in_port_t       sin6_port;     /* port number */     uint32_t        sin6_flowinfo; /* IPv6 flow information */     struct in6_addr sin6_addr;     /* IPv6 address */     uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ };struct in6_addr {     unsigned char   s6_addr[16];   /* IPv6 address */ };Unix域对应的是：#define UNIX_PATH_MAX    108struct sockaddr_un {     sa_family_t sun_family;               /* AF_UNIX */     char        sun_path[UNIX_PATH_MAX];  /* pathname */ };3）addrlen：对应的是地址的长度。通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，由系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。 网络字节序与主机字节序主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。（所见即所得）网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义，字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。因此，在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。 3.3 listen()、connect()函数如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。int listen(int sockfd, int backlog);int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。 3.4 accept()函数TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数去接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。 注意： accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接收的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。 3.5 read()、write()等函数万事具备只欠东风，至此服务器与客户已经建立好连接。可以调用网络I/O进行读写操作了，即实现了网络中不同进程之间的通信！网络I/O操作有下面几组：read()/write()recv()/send()readv()/writev()recvmsg()/sendmsg()recvfrom()/sendto()推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count);#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);read函数是负责从fd中读取内容。当成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。write函数将buf中的nbytes字节内容写入文件描述符fd。成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有两种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。其它的就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。 3.6 close()函数在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。close一个TCP socket的缺省行为是把该socket标记为已关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。 注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。 4 socket中TCP的三次握手建立连接详解我们知道TCP建立连接要进行“三次握手”，即交换三个分组。大致流程如下：1）客户端向服务器发送一个SYN J2）服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+13）客户端再向服务器发一个确认ACK K+1这样就完成了三次握手，但是这个三次握手发生在socket的哪几个函数中呢？请看下图：从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。总结：客户端的connect在三次握手的第二次返回，而服务器端的accept在三次握手的第三次返回。 5 socket中TCP的四次挥手释放连接详解上面介绍了socket中TCP的三次握手建立过程，与涉及的socket函数。现在我们介绍socket中的四次挥手释放连接的过程，请看下图：图示过程如下：1）某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；2）另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认，返回一个ACK M+1。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；3）一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；4）接收到这个FIN的源发送端TCP对它进行确认，返回一个ACK N+1。这样每个方向上都有一个FIN和ACK。 6 一个例子说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）——服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。服务器端代码：//server#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#define MAXLINE 4096int main(int argc, char** argv){    int    listenfd, connfd;    struct sockaddr_in     servaddr;    char    buff[4096];    int     n;    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){        printf("create socket error: %s(errno: %d)\n",strerror(errno),errno);        exit(0);    }    memset(&amp;servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);    servaddr.sin_port = htons(6666);    if( bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1){        printf("bind socket error: %s(errno: %d)\n",strerror(errno),errno);        exit(0);    }    if( listen(listenfd, 10) == -1){        printf("listen socket error: %s(errno: %d)\n",strerror(errno),errno);        exit(0);    }    printf("======waiting for client's request======\n");    while(1){        if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){            printf("accept socket error: %s(errno: %d)\n",strerror(errno),errno);            continue;        }        n = recv(connfd, buff, MAXLINE, 0);        buff[n] = '/0';        printf("recv msg from client: %s\n", buff);        close(connfd);    }    close(listenfd);} 客户端代码：//client#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#define MAXLINE 4096int main(int argc, char** argv){    int    sockfd, n;    char    recvline[4096], sendline[4096];    struct sockaddr_in    servaddr;    if( argc != 2){        printf("usage: ./client &lt;ipaddress&gt;\n");        exit(0);    }    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0){        printf("create socket error: %s(errno: %d)\n", strerror(errno),errno);        exit(0);    }    memset(&amp;servaddr, 0, sizeof(servaddr));    servaddr.sin_family = AF_INET;    servaddr.sin_port = htons(6666);    if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0){        printf("inet_pton error for %s\n",argv[1]);        exit(0);    }    if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0){        printf("connect error: %s(errno: %d)\n",strerror(errno),errno);        exit(0);    }    printf("send msg to server: \n");    fgets(sendline, 4096, stdin);    if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0){        printf("send msg error: %s(errno: %d)\n", strerror(errno), errno);        exit(0);    }    close(sockfd);    exit(0);}当然上面的代码很简单，也有很多缺点，这只是简单的演示socket的基本函数使用。其实不管多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。 7 动动手留下一个问题。是否熟悉Linux下网络编程？如熟悉，编写如下程序完成如下功能：服务器端：接收地址192.168.100.2的客户端信息，如信息为“Client Query”，则打印“Receive Query”客户端：向地址192.168.100.168的服务器端顺序发送信息“Client Query test”，“Cleint Query”，“Client Query Quit”，然后退出。题目中出现的IP地址可以根据实际情况而定。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> c </tag>
        
          <tag> 网络 </tag>
        
          <tag> socket </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Objective-C中的alloc和init问题]]></title>
      <url>/blog/objc-alloc-init/</url>
      <content type="text"><![CDATA[这些都是小知识点，没有办法，博主自学过来的，关于一些知识并没有形成系统，这里也是博主自己的学习笔记。发现这个问题，拿出来和大家分享，有什么不足，还请指正。从开始学的NSString *name=[[NSString alloc] init] 起，仅知道这句话是分配内存空间，一直在用，从来没考虑过它的内部是怎么实现的。今天无意中看到了这一句代码：NSString *name = [NSString alloc];NSLog(@"%p",name);name = [name init];NSLog(@"%p",name);试着打印了一下，发现两个的内存地址不一样：alloc是开辟一个内存空间，init是初始化，为什么初始化不在原有的内存空间上初始化，而是重新开辟一个内存空间。于是开始查资料，这时又发现了一个新的迷惑：NSObject *obj = [NSObject alloc];NSLog(@"%p",obj);obj = [obj init];NSLog(@"%p",obj);打印结果：怎么地址又变一样了？再打印NSArray的试一试：NSArray *person = [NSArray alloc];NSLog(@"%p",person);person = [person init];NSLog(@"%p",person);再次打印结果：仍然是不一样的。原因是什么呢？首先看看NSStrng的init方法吧：-(id)init{   if(self = [super init]) {    // 重新赋值     //…   }}从代码中可以分析，self=[super init]如果不为nil，就重新分配内存空间，这就解释了为什么 NSString，NSArray的调用alloc]init]方法后，内存地址会不一样，但是NSObject为什么会一样呢，我们知道NSObject是一切类的基类，当[[NSString alloc]init]执行时，调用的[super init]就是 NSObject中的init方法，既然NSObject身为基类，它也就无法调用super init，所以当NSObject执行[[NSObject alloc]init]时，也就没有了init重新分配空间这一环节。至于苹果公司为什么初始化一个实例要分两步，个人认为是方便构造后初始化不同的方法，如果用 new关键字，只能调用一个init，而不能调用initWithName等方法。知识拓展：NSString alloc之后，没有init，那么这部分alloc后的内存空间可不可以用？答案是显而易见的，如果可以用，苹果公司也就没必要提供一个init方法，那么alloc后的指针称为什么呢？ ——悬挂指针。如果一个地方指针既不为空，也没有被设置为指向一个已知的对象，则这样的指针称为悬挂指针。在程序里面是很危险的事。当程序运行使用该指针时，程序不能判断指针的合法性，将会产生很严重的错误。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> objc </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS Project与OS X Project中plist使用区别]]></title>
      <url>/blog/ios-application-plist-diff/</url>
      <content type="text"><![CDATA[这篇文章来源于开源中国的一道题目，因为答题，所以coding，所以发现了原来还有这样子的区别。因此，拿出来和大家分享。之前在开源中国看到一个求源代码的问题:模拟一个动物园系统MyZoo  1、动物园里面有三种动物:Panda,Elephant,Kangaroo 2、三种动物都有一定的数量(不止一只) 3、动物有各自不同的食量(以天为单位的食量),并且每天都在消耗食物。 4、动物园里的食物有固定的储备,而且假设三种动物都吃这一种食物。 5、每个动物都有不同的生产周期,每当到了这种动物的生产周期,动物园就会出现一位新生宝宝(假设其食量和成年动物是一样的)。 6、在主循环里模拟动物园的运转情况,要求在控制台上输出如下内容:第几天、动物的数量、动物园饲料的余量,直到饲料不够吃为止。 7、动物的数量,食量,生产周期,饲料总量都应该是可以配置的(在同一个文件中统一配置) 因此创建了一个OS X Project，使用plist当做这个动物园系统的初始数据的配置，代码结构如下：在main.m文件中实现上述题目的要求：#import &lt;Foundation/Foundation.h&gt;#import "Tool.h" int main(int argc, const char * argv[]) {    @autoreleasepool {        // insert code here...        Panda *panda = [[Panda alloc] init];        Elephant *elephant = [[Elephant alloc] init];        Kangaroo *kangaroo = [[Kangaroo alloc] init];                 //读取plist        NSString *plistPath = [[NSBundle mainBundle] pathForResource:@"data" ofType:@"plist"];        NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath];        NSLog(@"%@", plistPath);                 [Tool initWithAnimalDictionary:panda andDict:data];        [Tool initWithAnimalDictionary:elephant andDict:data];        [Tool initWithAnimalDictionary:kangaroo andDict:data];                 int fooder_num = 0;        int surplus = 0;        int day = 1;                 NSDictionary *fooderDict = [data objectForKey:@"fodder"];        fooder_num = [[fooderDict objectForKey:@"count_num"] intValue];        surplus = fooder_num;                 while(surplus &gt; 0){            if(0 == (day % [panda parturitionDays])){                [panda setCount:([panda count] + 1)];            }            if(0 == (day % [elephant parturitionDays])){                [elephant setCount:([elephant count] + 1)];            }            if(0 == (day % [kangaroo parturitionDays])){                [kangaroo setCount:([kangaroo count] + 1)];            }            surplus = fooder_num - ([panda count] * [panda foodConsumption] + [elephant count] * [elephant foodConsumption] + [kangaroo count] * [kangaroo foodConsumption]);            fooder_num = surplus;                         if(surplus){                NSLog(@"第 %d 天，熊猫:%d 只，大象:%d 头，袋鼠:%d 只，饲料余量:%d 。\n", day, [panda count], [elephant count], [kangaroo count], surplus);            }            day++;        }    }    return 0;}而这个时候遇见了问题，下面这句代码：NSString *plistPath = [[NSBundle mainBundle] pathForResource:@"data" ofType:@"plist"];在执行时一直是null，无法找到文件路径。而后在iOS Application Project – Single View Application中，plistPath是正确值,这下就不知道问题是什么了。看了[NSBundle mainBundle]中对于不同文件夹使用不同的方法,确定将文件放在工程下是使用上述代码。最后尝试各种方法，找到了一种解决方案：如上图所示，在Build Phase中Compile Sources中添加data.plist文件即可。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> 存储 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Xcode 使用小记]]></title>
      <url>/blog/xcode-console-cli/</url>
      <content type="text"><![CDATA[Xcode 是iOS开发者的福利，不得不说乔帮主给爱疯开发者提供了从业便利。我们这些后继者都发自内心的膜拜。也正是乔帮主的偏执，成就了苹果的伟大。Xcode 的可视化操作便捷，可是为了更灵活地debug，我们还是需要掌握一些提供效率的debug命令，文章分享迄今为止博主所知晓的debug命令，也会保持本文的持续更新。希望对大家有所帮助。debug 命令表            命令      解释                  break NUM      在指定的行上设置断点              bt      显示所有的调用栈帧，该命令可用来显示函数的调用顺序              clear      删除设置在特定源文件、特定行上的断点，其用法为：clear FILENAME:NUM              continue      继续执行正在调试的程序，该命令用在程序由于处理信号或断点而导致停止运行时              display EXPR      每次程序停止后显示表达式的值。表达式由程序定义的变量组成              file FILE      装载指定的可执行文件进行调试              help NAME      显示指定命令的帮助信息              info break      显示当前断电清单，包括到达断点处的次数等              info files      显示被调试文件的详细信息              info func      显示所有的函数名称              info local      显示当前函数中的局部变量信息              info prog      显示被调试程序的执行状态              info var      显示所有的全局和静态变量名称              kill      终止正被调试的程序              list      显示源代码段              make      在不退出gdb的情况下运行make工具              next      在不单步执行进入其他函数的情况下，向前执行一行源代码              print EXPR      显示表达式EXPR的值              print-object      打印一个对象              print (int) name      打印一个类型              print-object [artist description]      调用一个函数              set artist - @”test”      设置变量值              help      查看帮助      快捷键  文件            按键      作用                  CMD + N      新文件              CMD + SHIFT + N      新项目              CMD + O      打开              CMD + S      保存              CMD + SHIFT + S      另存为              CMD + W      关闭窗口              CMD + SHIFT + W      关闭文件        编辑            按键      作用                  CMD + [      左缩进              CMD + ]      右缩进              CMD + CTRL + LEFT      折叠              CMD + CTRL + RIGHT      取消折叠              CMD + CTRL + TOP      折叠全部函数              CMD + CTRL + BOTTOM      取消全部函数折叠              CTRL + U      取消全部折叠              CMD + D      添加书签              CMD + /      注释或取消注释              CTRL + .      参数提示              ESC      自动提示列表        调试            按键      作用                         CMD + | 设置或取消断点                            CMD + OPT + | 允许或禁用当前断点                            CMD + OPT + B      查看全部断点                            CMD + RETURN      编译并运行（根据设置决定是否启用断点）              CMD + R      编译并运行（不触发断点）                     CMD + Y      编译并调试（触发断点）                     CMD + SHIFT + RETURN      终止运行或调试                     CMD + B      编译                     CMD + SHIFT + K      清理               窗体            按键      作用                  CMD + SHIFT + B      编译窗口              CMD + SHIFT + Y      调试代码窗口              CMD + SHIFT + R      调试控制台              CMD + SHIFT + E      主编辑窗口调整        帮助            按键      作用                  CMD + OPT + ?      开发手册              CMD + CTRL + ?      快速帮助              Command + Shift + E      扩展编辑器              Command + [      左移代码块              Command + ]      右移代码块              Tab      接受代码提示              Esc      显示代码提示菜单              Ctrl + . （句点）      循环浏览代码提示              Shift + Ctrl + . （句点）      反向循环浏览代码提示              Ctrl + /      移动到代码提示中的下一个占位符              Command + Ctrl + S      创建快照              Ctrl + F      前移光标              Ctrl + B      后移光标              Ctrl + P      移动光标到上一行              Ctrl + N      移动光标到下一行              Ctrl + A      移动光标到本行行首              Ctrl + E      移动光标到本行行尾              Ctrl + T      交换光标左右两边的字符              Ctrl + D      删除光标右边的字符              Ctrl + K      删除本行              Ctrl + L      将插入点置于窗口正中              Command + Alt + D      显示open quickly 窗口              Command + Alt + 上方向键      打开配套文件              Command + D      添加书签              Option + 双击      在文档中搜索              Command + Y      以调试方式运行程序              Command + Alt + P      继续（在调试中）              Command + Alt + 0      跳过              Command + Alt + I      跳入              Command + Alt + T      跳出      ]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OAuth2.0 协议]]></title>
      <url>/blog/oauth2-protocol/</url>
      <content type="text"><![CDATA[OAuth（Open Authorization），协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名和密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户的授权，因此，OAuth是安全的。这些解释都是官方的，本文中博主会根据自己的学习所得，整理分享对OAuth协议的理解。简介OAuth（Open Authorization），协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAuth的授权不会使第三方触及到用户的帐号信息（如用户名和密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户的授权，因此，OAuth是安全的。这些解释其实都是可以在网上搜索到的。为了解释的更加清楚，接下来博主结合实例绘图解释：整个OAuth授权过程中，三者都获得了自己的便利。用户可以不用注册帐号，可以直接使用关联帐号就可登录新的网站使用资源，且不用担心帐号失窃，因为这个授权过程是安全的。慕课网可以更加轻易的获取用户量。腾讯将海量的数据开放给第三方网站，既是为其他小企业做的贡献，也增大了自身的知名度。 版本OAuth1.0 发布于2007年末，存在严重安全漏洞。OAuth2.0 发布于2010年初，解决上一版本的安全漏洞，现被各大网站公司一直使用。 应用场景1）QQ用户授权慕课网使用其QQ帐号相关信息。2）获取授权后，在符合权限规则的情况下访问各种API。3）淘宝帐号，可在支付宝，阿里云中使用。总的来说，OAuth是某一独立系统，开放其用户资源给另一系统使用的协议。 实现过程（三个步骤）步骤一：请求OAuth登录页面Request Token URL，未授权的令牌请求服务地址。慕课网请求QQ登录页面时使用的带有特定参数的URL。例如，　　https://graph.qq.com/oauth/...?...　　&amp;client_id=100490398&amp;...　　&amp;redirect_uri=http://www.mukewang.com/...第一行为QQ登录OAuth页面的地址。第二行为一个唯一的站点ID，必须和预置服务器上的一致。第三行为一个回调地址，必须和预置服务器上的一致。步骤二：用户使用QQ号登录并授权　　https://graph.qq.com/oauth/...?...　　&amp;client_id=100490398&amp;...　　&amp;redirect_uri=http://www.mukewang.com/...跳转到　　http://www.mukewang.com/user/qqcallback?code=xxxxx....慕课网服务器使用　　$_GET['code'];获取加密字符。步骤三：返回登录结果User Authorization URL，用户授权的令牌请求服务地址为保证安全，确保code是合法服务器获得，没有被劫持，则需要合法接收服务器再发送一个请求（User Authorization URL）。例如，用户QQ登录授权之后需要请求一个带有特定参数的URL。　　https://xxx.qq.com/oauth/...?...　　&amp;client_id=100490398&amp;...　　&amp;client_secret=xxxxxx&amp;...　　&amp;code=xxxxx......code在短期内会过期且只可使用一次，通常是10秒左右。基于安全考虑。 关于AccessTokenAccessToken，用户通过第三方应用访问OAuth接口的令牌，具有较长生命周期（10天半个月甚至更长）。如果AccessToken过期，可以重新登录授权，或在User Authorization URL中指定参数（刷新AccessToken的参数，各平台各有不同）”……&amp;need_refresh_token=true&amp;……“。获取AccessToken就可以访问授权帐号的资源，例如，通过慕课网把自己喜欢的课程分享到QQ空间。 AccessToken与RefreshTokenRefreshToken也是有生命周期的，不过比AccessToken生命周期要长，各大平台不一样。使用实例类比AccessToken将返回的XML或JSON解析成我们想要的数据希望对大家有所帮助。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 网络 </tag>
        
          <tag> 安全 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[常用的算法思想总结]]></title>
      <url>/blog/algorithm-idea/</url>
      <content type="text"><![CDATA[对于计算机科学而言，算法是一个非常重要的概念。它是程序设计的灵魂，是将实际问题同解决该问题的计算机程序建立起联系的桥梁。文章主要介绍一些常用的算法思想。一、穷举法思想穷举法，又称为强力法。它是一种最为直接，实现最为简单，同时又最为耗时的一种解决实际问题的算法思想。基本思想：在可能的解空间中穷举出每一种可能的解，并对每一个可能解进行判断，从中得到问题的答案。使用穷举法思想解决实际问题，最关键的步骤是划定问题的解空间，并在该解空间中一一枚举每一个可能的解。这里有两点需要注意，一是解空间的划定必须保证覆盖问题的全部解，二是解空间集合及问题的解集一定是离散的集合，也就是说集合中的元素是可列的、有限的。穷举法用时间上的牺牲换来了解的全面性保证，因此穷举法的优势在于确保得到问题的全部解，而瓶颈在于运算效率十分低下。但是穷举法算法思想简单，易于实现，在解决一些规模不是很大的问题，使用穷举法不失为一种很好地选择。现在我们通过具体的实例来理解穷举法思想。/** *  实例：寻找[1,100]之间的素数 * */#include &lt;stdio.h&gt; /** *  判断n是否是素数，是则返回1，不是则返回0 */int isPrime(int n){    int i = 0;    for (i = 2; i &lt; n; i++) {        if (0 == n % i) {            return 0;        }    }    return 1;} /** *  寻找[low,high]之间的素数 */void getPrime(int low, int high){    int i = 0;    for (i = low; i &lt;= high; i++) {        if (isPrime(i)) {            printf("%d ", i);        }    }} int main(int argc, const char * argv[]) {    // insert code here...    int low = 0, high = 0;    printf("Please input the domain for searching prime\n");    printf("low limitation:");    scanf("%d", &amp;low);    printf("high limitation:");    scanf("%d", &amp;high);    printf("The whole primes in this domain are\n");    getPrime(low, high);    getchar();         return 0;}程序运行结果：Please input the domain for searching primelow limitation:1high limitation:100The whole primes in this domain are1 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97二、递归与分治思想递归与分治的算法思想往往是相伴而生的，它们在各类算法中使用非常频繁，应用递归和分治的算法思想有时可以设计出代码简洁且比较高效的算法来。在解决一些比较复杂的问题，特别是解决一些规模较大得问题时，常常将问题进行分解。具体来说，就是将一个规模较大的问题分割成规模较小的同类问题，然后将这些小问题的子问题逐个加以解决，最终也就将整个大问题解决了。这种思想称之为分治。在解决一些问题比较复杂、计算量庞大的问题时经常被用到。最为经典的使用分治思想设计的算法就是“折半查找算法”。折半查找算法利用了元素之间的顺序关系（有序序列），采用分而治之的策略，不断缩小问题的规模，每次都将问题的规模减小至上一次的一半。而递归思想也是一种常见的算法设计思想，所谓递归算法，就是一种直接或间接地调用原算法本身的一种算法。接下来我们通过实例代码来理解递归、分治思想。分治思想：/** *  有一个数组A[10]，里面存放了10个整数，顺序递增 *  A[10] = {2, 3, 5, 7, 8, 10, 12, 15, 19, 21} * */ #include &lt;stdio.h&gt; int bin_search(int A[], int n, int key){    int low = 0, high = 0, mid = 0;    high = n - 1;    while (low &lt;= high) {        mid = (low + high) / 2;        if (A[mid] == key) { //查找成功，返回mid            return mid;        }        if (A[mid] &lt; key) { //在后半序列中查找            low = mid + 1;        }        if (A[mid] &gt; key) { //在前半序列中查找            high = mid - 1;        }    }    return -1; //查找失败} int main(int argc, const char * argv[]) {    // insert code here...    int A[10] = {2, 3, 5, 7, 8, 10, 12, 15, 19, 21};    int i = 0, n = 0, addr = 0;    printf("The contents of the Array A[10] are\n");    for (i = 0; i &lt; 10; i++) {        printf("%d ",A[i]); //显示数组A中的内容    }    printf("\nPlease input a interger for search\n");    scanf("%d", &amp;n); //输入待查找得元素    addr = bin_search(A, 10, n); //折半查找，返回该元素在数组中的下标    if (-1 != addr) {        printf("%d is at the %dth unit is array A\n", n, addr);    }else{        printf("There is no %d in array A\n", n); //查找失败    }    getchar();         return 0;}运行结果：The contents of the Array A[10] are2 3 5 7 8 10 12 15 19 21Please input a interger for search1212 is at the 6th unit is array A递归思想：/** *  计算n的阶乘n! * */ #include &lt;stdio.h&gt; int factorial(int n){    if (0 == n) {        return 1;    }else{        return n * factorial(n - 1);    }} int main(int argc, const char * argv[]) {    // insert code here...    int n = 0, result = 0;    printf("Please input factorial number\n");    scanf("%d", &amp;n);    result = factorial(n);    printf("result is %d", result);    getchar();         return 0;}运行结果：Please input factorial number6result is 720三、贪心算法思想贪心算法的思想非常简单且算法效率很高，在一些问题的解决上有着明显的优势。先来看一个生活中的例子。假设有3种硬币，面值分别为1元、5角、1角。这3种硬币各自的数量不限，现在要找给顾客3元6角钱，请问怎样找才能使得找给顾客的硬币数量最少呢？你也许会不假思索的说出答案：找给顾客3枚1元硬币，1枚5角硬币，1枚1角硬币。其实也可以找给顾客7枚5角硬币，1枚1角硬币。可是在这里不符合题意。在这里，我们下意识地应用了所谓贪心算法解决这个问题。所谓贪心算法，就是总是做出在当前看来是最好的选择的一种方法。以上述的题目为例，为了找给顾客的硬币数量最少，在选择硬币的面值时，当然是尽可能地选择面值大的硬币。因此，下意识地遵循了以下方案：（1）首先找出一个面值不超过3元6角的最大硬币，即1元硬币。（2）然后从3元6角中减去1元，得到2元6角，再找出一个面值不超过2元6角的最大硬币，即1元硬币。（3）然后从2元6角中减去1元，得到1元6角，再找出一个面值不超过1元6角的最大硬币，即1元硬币。（4）然后从1元6角中减去1元，得到6角，再找出一个面值不超过6角的最大硬币，即5角硬币。（5）然后从6角中减去5角，得到1角，再找出一个面值不超过1角的最大硬币，即1角硬币。（6）找零钱的过程结束。这个过程就是一个典型的贪心算法思想。因此，不难看出应用贪心算法求解问题，并不从问题的整体最优上加以考虑，它所作出的每一步选择只是在某种意义上得局部最优选择。因此，严格意义上讲，要使用贪心算法求解问题，该问题应当具备以下性质。（1）贪心选择性质所谓贪心选择性质，就是指所求解的问题的整体最优解可以通过一系列的局部最优解得到。所谓局部最优解，就是指在当前的状态下做出的最好选择。（2）最优子结构性质当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。我们经常使用的哈夫曼（Huffman Tree）编码算法，求解最小生成树的克鲁斯卡尔（Kruskal）算法和普利姆（Prim）算法，求解图的单源最短路径的迪克斯特拉（Dijkstra）算法都是基于贪心算法的思想设计的。下面，我们来通过实例代码来理解贪心算法思想。/** *  最优装船问题 *  有一批集装箱要装入一个载质量为C的货船中，每个集装箱的质量由用户自己输入指定，在货船的装载体积不限的前提下，如何装载集装箱才能尽可能多地将集装箱装入货船中。 */#include &lt;stdio.h&gt; void sort(int w[], int t[], int n){    int i = 0, j = 0, tmp = 0;    //存放w[]中的内容，用于排序    int *w_tmp = (int *)malloc(sizeof(int) * n);         for (i = 0; i &lt; n; i++) {        t[i] = i;  //初始化数组t    }    for (i = 0; i &lt; n; i++) {        w_tmp[i] = w[i];    }    for (i = 0; i &lt; n - 1; i++) { //冒泡排序        for (j = 0; j &lt; n - i - 1; j++) {            if (w_tmp[j] &gt; w_tmp[j+1]) {                tmp = w_tmp[j];                w_tmp[j] = w_tmp[j+1];                w_tmp[j+1] = tmp;                tmp = t[j];                t[j] = t[j+1];                t[j+1] = tmp;            }        }    }} void Loading(int x[], int w[], int c, int n){    int i = 0;    //存放w[]的下标，如果t[i]、t[j]、i&lt;j，则w[i]&lt;=w[j]    int *t = (int *)malloc(sizeof(int) * n);    //排序，用数组t[[]存放w[]的下标    sort(w, t, n);    for (i = 0; i &lt; n; i++) {        x[i] = 0;  //初始化数组x[]    }    for (i = 0; i &lt; n &amp;&amp; w[t[i]] &lt;= c; i++) {        x[t[i]] = 1; //将第t[i]个集装箱装入货船中        c = c - w[t[i]]; //变量c中存放货船的剩余载质量    }} int main(int argc, const char * argv[]) {    // insert code here...    int x[5], w[5], c = 0, i = 0;    printf("Please input the maximum loading of the sheep\n");    scanf("%d", &amp;c); //    printf("Please input the weight of FIVE box\n");    for (i = 0; i &lt; 5; i++) { //        scanf("%d", &amp;w[i]);    }    Loading(x, w, c, 5); //    printf("The following boxes will be loaded\n");    for (i = 0; i &lt; 5; i++) { //        if (1 == x[i]) {            printf("BOX:%d ", i);        }    }    getchar();         return 0;}运行结果：Please input the maximum loading of the sheep13Please input the weight of FIVE box5 7 6 3 2The following boxes will be loadedBOX:0 BOX:3 BOX:4以上，就是对算法设计中几个常见的思想的总结。写在最后欢迎大家加入算法交流Q群交流讨论，Q群号：855454453]]></content>
      <categories>
        
          <category> algorithm </category>
        
      </categories>
      <tags>
        
          <tag> c </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Apk 反编译]]></title>
      <url>/blog/apk-decompile/</url>
      <content type="text"><![CDATA[最近看见一些正版软件，便想到pc端软件的破解，便在网络上大肆搜索，终于找到了一个办公软件破解key的软件，对其实现非常感兴趣，想着反编译其apk，在网上也找了很多相关的实现方式，这里，本文介绍博主使用的简约方法与工具。步骤1、将apk文件解压，得到其中的classes.dex（java文件编译再通过dx工具打包而成的）。将classes.dex复制到d2j-dex2jar.bat所在目录dex2jar-0.0.9.13文件夹。在命令行下定位到d2j-dex2jar.bat所在目录，运行d2j-dex2jar.bat    classes.dex生成classes_dex2jar.jardex2jar工具下载2、使用jdgui.exe打开classes_dex2jar.jar，即可看见源码。jdgui工具下载只需以上两步，即可获得apk源码。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 逆向 </tag>
        
          <tag> java </tag>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Objective-C 中 new、alloc和init的区别]]></title>
      <url>/blog/objc-new-alloc-init/</url>
      <content type="text"><![CDATA[在实际开发中很少会用到new，一般创建对象我们看到的全是[[className alloc] init]，但是并不意味着你不会接触到new，在一些代码中还是会看到[className new]，还有去面试的时候，也很可能被问到这个问题。那么，它们两者之间到底有什么区别呢？我们先来看源码：+ + new {     id newObject = (*_alloc)((Class)self, 0);     Class metaClass = self-&gt;isa;     if (class_getVersion(metaClass) &gt; 1)         return [newObject init];     else         return newObject; }而 alloc/init 像这样+ + alloc {     return (*_zoneAlloc)((Class)self, 0, malloc_default_zone());  } - init {     return self; }通过源码中我们发现，[className new]基本等同于[[className alloc] init]，区别只在于alloc分配内存的时候使用了zone。那么，这个zone是个什么东西呢？它是给对象分配内存的时候，把关联的对象分配到一个相邻的内存区域内，以便于调用时消耗很少的代价，提升了程序处理速度。为什么不推荐使用new？不知大家发现了没有，如果使用new的话，初始化方法被固定死只能调用init。而你想调用initXXX怎么办？没门儿！据说最初的设计是完全借鉴Smalltalk语法来的。传说那个时候已经有allocFromZone:这个方法，但是这个方法需要传个参数id myCompanion = [[TheClass allocFromZone:[self zone]] init];这个方法像下面这样：+ + allocFromZone:(void *) z {     return (*_zoneAlloc)((Class)self, 0, z);  }后来简化为下面这个：+ + alloc {     return (*_zoneAlloc)((Class)self, 0, malloc_default_zone());  }但是，出现个问题：这个方法只是给对象分配了内存，并没有初始化实例变量。是不是又回到new那样的处理方式：在方法内部隐式调用init方法呢？后来发现“显示调用总比隐式调用更好”，所以后来就把两个方法分开了。概括来说，new和alloc/init在功能上几乎是一致的，分配内存并完成初始化。差别在于，采用new的方式只能采用默认的init方法完成初始化，采用alloc的方式可以用其他定制的初始化方法。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[YYModel源代码阅读 - 基础知识]]></title>
      <url>/blog/YYModel-reading/</url>
      <content type="text"><![CDATA[YYModel堪称神级大作，虽然不免一些小bug，但是完全不影响膝盖碎一地。文章主要分享在阅读YYModel源代码时，所引发的知识点的补充与思考。前言这段时间因为工作需要，阅读了YYModel这个开源框架，至于它能做什么，最直白的讲述就是JSON与Model之间的相互转化。源代码在Github，大家可以自行git clone或者download。接下来，笔者主要分析阅读源代码而引出的各种问题与知识点，不足之处请大家指正。NS_ASSUME_NONNULL_BEGIN &amp; NS_ASSUME_NONNULL_END这组宏是成对使用的，不得不说我们自己写代码的时候使用的很少，以至于遗漏这个知识点，现在我们就来看看这两个宏会引出什么问题。这组宏会引出几个关于Objective-C新特性的知识点：      Nullability Annotations        Lightweight Generics        __kindof  Nullability Annotations我们都知道在swift中，可以使用!和?来表示一个对象是optional的还是non-optional，如view?和view!。而在 Objective-C中则没有这一区分，view既可表示这个对象是optional，也可表示是non-optioanl。这样就会造成一个问题：在 Swift与Objective-C混编时，Swift编译器并不知道一个Objective-C对象到底是optional还是non-optional，因此这种情况下编译器会隐式地将Objective-C的对象当成是non-optional。为了解决这个问题，苹果在Xcode 6.3引入了一个Objective-C的新特性：nullability annotations。这一新特性的核心是两个新的类型注释：** __nullable** 和 __nonnull 。从字面上我们可以猜到，__nullable表示对象可以是NULL或nil，而__nonnull表示对象不应该为空。当我们不遵循这一规则时，编译器就会给出警告。我们来看看以下的实例，@interface TestNullabilityClass ()@property (nonatomic, copy) NSArray * items;- (id)itemWithName:(NSString * __nonnull)name;@end@implementation TestNullabilityClass...- (void)testNullability {    [self itemWithName:nil];    // 编译器警告：Null passed to a callee that requires a non-null argument}- (id)itemWithName:(NSString * __nonnull)name {    return nil;}@end不过这只是一个警告，程序还是能编译通过并运行。事实上，在任何可以使用const关键字的地方都可以使用__nullable和__nonnull，不过这两个关键字仅限于使用在指针类型上。而在方法的声明中，我们还可以使用不带下划线的nullable和nonnull，如下所示：- (nullable id)itemWithName:(NSString * nonnull)name在属性声明中，也增加了两个相应的特性，因此上例中的items属性可以如下声明：@property (nonatomic, copy, nonnull) NSArray * items;当然也可以用以下这种方式：@property (nonatomic, copy) NSArray * __nonnull items;推荐使用nonnull这种方式，这样可以让属性声明看起来更清晰。Nonnull区域设置(Audited Regions)如果需要每个属性或每个方法都去指定nonnull和nullable，是一件非常繁琐的事。苹果为了减轻我们的工作量，专门提供了两个宏：NS_ASSUME_NONNULL_BEGIN和NS_ASSUME_NONNULL_END。在这两个宏之间的代码，所有简单指针对象都被假定为 nonnull，因此我们只需要去指定那些nullable的指针。如下代码所示：NS_ASSUME_NONNULL_BEGIN@interface TestNullabilityClass ()@property (nonatomic, copy) NSArray * items;- (id)itemWithName:(nullable NSString *)name;@endNS_ASSUME_NONNULL_END在上面的代码中，items属性默认是nonnull的，itemWithName:方法的返回值也是nonnull，而参数是指定为nullable的。不过，为了安全起见，苹果还制定了几条规则：      typedef定义的类型的nullability特性通常依赖于上下文，即使是在Audited Regions中，也不能假定它为nonnull。        复杂的指针类型(如id *)必须显示去指定是nonnull还是nullable。例如，指定一个指向nullable对象的nonnull指针，可以使用”__nullable id * __nonnull”。        我们经常使用的NSError **通常是被假定为一个指向nullable NSError对象的nullable指针。  兼容性因为Nullability Annotations是Xcode 6.3新加入的，所以我们需要考虑之前的老代码。实际上，苹果已以帮我们处理好了这种兼容问题，我们可以安全地使用它们：      老代码仍然能正常工作，即使对nonnull对象使用了nil也没有问题。        老代码在需要和swift混编时，在新的swift编译器下会给出一个警告。        nonnull不会影响性能。事实上，我们仍然可以在运行时去判断我们的对象是否为nil。  事实上，我们可以将nonnull/nullable与我们的断言和异常一起看待，其需要处理的问题都是同一个：违反约定是一个程序员的错误。特别是，返回值是我们可控的东西，如果返回值是nonnull的，则我们不应该返回nil，除非是为了向后兼容。Lightweight GenericsLightweight Generics 轻量级泛型，轻量是因为这是个纯编译器的语法支持（LLVM 7.0），和 Nullability 一样，没有借助任何 objc runtime 的升级，也就是说，这个新语法在 Xcode 7 上可以使用且完全向下兼容（更低的 iOS 版本）带泛型的容器这无疑是本次最重大的改进，有了泛型后终于可以指定容器类中对象的类型了：NSArray&lt;NSString *&gt; *strings = @[@"sun", @"yuan"];NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @{@"a": @1, @"b": @2};返回值的 id 被替换成具体的类型后，令人感动的代码提示也出来了。假如向泛型容器中加入错误的对象，编译器会不开心的。系统中常用的一系列容器类型都增加了泛型支持，甚至连 NSEnumerator 都支持了，这是非常 Nice 的改进。和 Nullability 一样，我认为最大的意义还是丰富了接口描述信息，对比下面两种写法：@property (readonly) NSArray *imageURLs;@property (readonly) NSArray&lt;NSURL *&gt; *imageURLs;不用多想就清楚下面的数组中存的是什么，避免了 NSString 和 NSURL 的混乱。自定义泛型类比起使用系统的泛型容器，更好玩的是自定义一个泛型类，目前这里还没什么文档，但拦不住我们写测试代码，假设我们要自定义一个 Stack 容器类：@interface Stack&lt;ObjectType&gt; : NSObject- (void)pushObject:(ObjectType)object;- (ObjectType)popObject;@property (nonatomic, readonly) NSArray&lt;ObjectType&gt; *allObjects;@end这个 ObjectType 是传入类型的 placeholder，它只能在 @interface 上定义（类声明、类扩展、Category），如果你喜欢用 T 表示也 OK，这个类型在 @interface 和 @end 区间的作用域有效，可以把它作为入参、出参、甚至内部 NSArray 属性的泛型类型，应该说一切都是符合预期的。我们还可以给 ObjectType 增加类型限制，比如：// 只接受 NSNumber * 的泛型@interface Stack&lt;ObjectType: NSNumber *&gt; : NSObject// 只接受满足 NSCopying 协议的泛型@interface Stack&lt;ObjectType: id&lt;NSCopying&gt;&gt; : NSObject若什么都不加，表示接受任意类型 ( id )；当类型不满足时编译器将产生 error。实例化一个 Stack，一切工作正常：对于多参数的泛型，用逗号隔开，其他都一样，可以参考 NSDictionary 的头文件。协变性和逆变性当类支持泛型后，它们的 Type 发生了变化，比如下面三个对象看上去都是 Stack，但实际上属于三个 Type：Stack *stack; // Stack *Stack&lt;NSString *&gt; *stringStack; // Stack&lt;NSString *&gt;Stack&lt;NSMutableString *&gt; *mutableStringStack; // Stack&lt;NSMutableString *&gt;当其中两种类型做类型转化时，编译器需要知道哪些转化是允许的，哪些是禁止的，比如，默认情况下：Stack *stack;Stack&lt;NSString *&gt; *stringStack;Stack&lt;NSMutableString *&gt; *mutableStringStack; stack = stringStack;stack = mutableStringStack;stringStack = stack;stringStack = mutableStringStack;mutableStringStack = stack;mutableStringStack = stringStack在Xcode中我们可以看到，不指定泛型类型的 Stack 可以和任意泛型类型转化，但指定了泛型类型后，两个不同类型间是不可以强转的，假如你希望主动控制转化关系，就需要使用泛型的协变性和逆变性修饰符了：__covariant - 协变性，子类型可以强转到父类型（里氏替换原则）__contravariant - 逆变性，父类型可以强转到子类型（WTF）协变@interface Stack&lt;__covariant ObjectType&gt; : NSObject逆变@interface Stack&lt;__contravariant ObjectType&gt; : NSObject协变是非常好理解的，像 NSArray 的泛型就用了协变的修饰符。__kindof__kindof 这修饰符还是很实用的，解决了一个长期以来的小痛点，拿原来的 UITableView 的这个方法来说：- (id)dequeueReusableCellWithIdentifier:(NSString *)identifier;使用时前面基本会使用 UITableViewCell 子类型的指针来接收返回值，所以这个 API 为了让开发者不必每次都蛋疼的写显式强转，把返回值定义成了 id 类型，而这个 API 实际上的意思是返回一个 UITableViewCell 或 UITableViewCell 子类的实例，于是新的 __kindof 关键字解决了这个问题：- (__kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;既明确表明了返回值，又让使用者不必写强转。再举个带泛型的例子，UIView 的 subviews 属性被修改成了：@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews;这样，写下面的代码时就没有任何警告了：UIButton *button = view.subviews.lastObject;NS_ENUM &amp; NS_OPTIONS枚举是指将变量的值一一列举出来，变量的值只限于列举出来的值的范围内。枚举本质上是一个整数，枚举的作用是把值限定在指定的范围内，并且增加代码的可读性。 枚举的成员如果没有显示指定值，那么第一个成员的值总是0，后面成员的值依次递增。枚举可以直接用于比较。一般我们声明枚举：#import &lt;Foundation/Foundation.h&gt;// 声明枚举类型enum Direction {up, down, left = 10, right};int main(int argc, const char * argv[]){  ...}其中up = 0, down = 1, left = 10, right = 11。我们会发现枚举中一些不可自定义的部分，例如，枚举名。NS_ENUM 和 NS_OPTIONS 都不算太古老的宏，在iOS 6 / OS X Mountain Lion才开始有，它们都是代替 enum 的更好的办法。NS_ENUM如果要在早期的iOS或OS X系统中使用这两个宏，简单定义一下就好#ifndef NS_ENUM#define NS_ENUM(_type, _name) enum _name : _type _name; enum _name : _type#endif在OS X 10.4 中的原始定义如下：#define NS_ENUM(_type, _name) CF_ENUM(_type, _name)#define NS_OPTIONS(_type, _name) CF_OPTIONS(_type, _name)在之前枚举可以这么定义：typedef enum {    UITableViewCellStyleDefault,    UITableViewCellStyleValue1,    UITableViewCellStyleValue2,    UITableViewCellStyleSubtitle};或者typedef NSInteger UITableViewCellStyle;现在，有了统一的风格typedef NS_ENUM(NSInteger, UITableViewCellSelectionStyle) {    UITableViewCellSelectionStyleNone,    UITableViewCellSelectionStyleBlue,    UITableViewCellSelectionStyleGray,    UITableViewCellSelectionStyleDefault};NS_ENUM 的第一个参数是用于存储的新类型的类型。在64位环境下，UITableViewCellStyle 和 NSInteger 一样有8 bytes长。你要保证你给出的所有值能被该类型容纳，否则就会产生错误。第二个参数是新类型的名字。大括号里面和以前一样，是你要定义的各种值。NS_OPTIONS            语法和 NS_ENUM 完全相同，但这个宏提示编译器值是如何通过位掩码      组合在一起的。      typedef NS_OPTIONS(NSUInteger, AMGResizing) {    AMGResizingNone            = 0,    AMGResizingFlexibleWidth   = 1 &lt;&lt; 0,    AMGResizingFlexibleHeight  = 1 &lt;&lt; 1,    AMGResizingFlexibleUnicorn = 1 &lt;&lt; 2};attribute((always_inline))我们知道一般的函数调用都会通过call的方式来调用，这样让攻击很容易对一个函数做手脚，如果是以inline的方式编译的会，会把该函数的code拷贝到每次调用该函数的地方。而static会让生成的二进制文件中没有清晰的符号表，让逆向的人很难弄清楚逻辑。__attribute__((always_inline)) 的意思是强制内联，所有加了__attribute__((always_inline)) 的函数再被调用时不会被编译成函数调用而是直接扩展到调用函数体内，比如定义了函数__attribute__((always_inline)) void a()和void b()｛      a();｝b 调用 a 函数的汇编代码不会是跳转到a执行，而是 a 函数的代码直接在 b 内成为 b 的一部分。#define __inline __attribute__((always_inline)) 的意思就是用__inline 代替__attribute__((always_inline))内声明a的时候可以直接写成__inline void a() 这样比较方便因为__attribute__((always_inline)) 字多。undef这是预编译指令，和#define搭配使用，意思是取消之前的宏定义。#define PROC_ADD void main(void) {#ifdef PROC_ADD // Do this code here then undefined it to run the code in the else // processing work #undef PROC_ADD #else // now that PROC_ADD has been undefined run this code // processing work #endif }__unsafe_unretained__unsafe_unretained是对对象的非zeroing的weak reference，意思是当对象所指向的内存被销毁了，对象还存在，称为“野指针”。在iOS引入了Automatic Reference Count（ARC）之后，编译器可以在编译时对obj-c对象进行内存管理。大致规则如下：alloc的要release;retain/copy的要release;NSAutoreleasePool在ARC中被禁止使用,替换成@autoreleasepool 函数体;使用@ autoreleasepool,在函数入口的时候,autorelease pool入栈,正常退出时,autorelease pool出栈,从而释放变量.注意:@ autoreleasepool在非ARC模式下,也能使用,并据说使用@autoreleasepool比使用NSAutoreleasePool速度能快6倍, 明显提升程序性能.@package为了强制一个对象隐藏其数据，编译器限制实例变量范围以限制其在程序中的可见性，但是为了提供灵活性，苹果也让开发者显式设置范围。以下是这些关键字的使用范围：  @privateThe instance variable is accessible only within the class that declares it.实例变量只能被声明它的类访问.  @protectedThe instance variable is accessible within the class that declares it and within classes that inherit it. All instance variables without an explicit scope directive have @protected scope.实例变量能被声明它的类和子类访问，所有没有显式制定范围的实例变量都是.  @publicThe instance variable is accessible everywhere.实例变量可以被在任何地方访问.  @packageUsing the modern runtime, an @package instance variable has @public scope inside the executable image that implements the class, but acts like @private outside.使用modern运行时，一个@package实例变量在实现这个类的可执行文件镜像中实际上是@public的，但是在外面就是@private【runtime需要再看一下苹果文档Runtime Programming Guide】The @package scope for Objective-C instance variables is analogous to private_extern for C variables and functions. Any code outside the class implementation’s image that tries to use the instance variable gets a link error.Objective-C中的@package与C语言中变量和函数的private_extern类似。任何在实现类的镜像之外的代码想使用这个实例变量都会引发link errorThis scope is most useful for instance variables in framework classes, where @private may be too restrictive but @protected or @public too permissive.            这个类型最常用于框架类的实例变量，使用@private太限制，使用@protected或者@public又太开放.      ]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> 框架 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[内存对齐详解]]></title>
      <url>/blog/memory-alignment/</url>
      <content type="text"><![CDATA[现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。本文分享博主对内存对齐的一些理解。一、什么是内存对齐现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问， 这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是内存对齐。二、内存对齐的原因1、平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。2、性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。三、对齐规则每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。程序员可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16 来改变这一系数，其中的n 就是你要指定的“对齐系数”。规则1数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0 的地方，以后每个数据成员的对齐按照#pragma pack 指定的数值和这个数据成员自身长度中，比较小的那个进行。规则2结构（或联合）的整体对齐规则：在数据成员完成各自对齐之后，结构（或联合）本身也要进行对齐，对齐将按照#pragma pack 指定的数值和结构（或联合）最大数据成员长度中，比较小的那个进行。规则3结合1、2 可推断：当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n值的大小将不产生任何效果。四、试验接下来我们通过实际例子来说明这些规则。试验环境：编译器包括GCC 3.4.2 和VC6.0 的C 编译器。平台：Windows XP SP2。我们将用典型的struct 对齐来说明。首先我们定义一个struct：#pragma pack(n) /* n = 1, 2, 4, 8, 16 */struct test_t{    int a;    char b;    short c;    char d;};#pragma pack(n)首先我们首先确认在试验平台上的各个类型的size，经验证两个编译器的输出均为：sizeof(char) = 1sizeof(short) = 2sizeof(int) = 4验证过程如下：通过#pragma pack(n)改变“对齐系数”，然后查看sizeof(struct test_t)的值。字节对齐(#pragma pack(1))输出结果：sizeof(struct test_t) = 8 [两个编译器输出一致]分析过程：成员数据对齐#pragma pack(1)struct test_t {    /* 长度4 &lt; 1 按1 对齐；起始offset=0 0%1=0；存放位置区间[0,3] */       int a;    /* 长度1 = 1 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */    char b;    /* 长度2 &gt; 1 按1 对齐；起始offset=5 5%1=0；存放位置区间[5,6] */    short c;    /* 长度1 = 1 按1 对齐；起始offset=7 7%1=0；存放位置区间[7] */    char d;};#pragma pack()成员总大小=8整体对齐整体对齐系数= min((max(int,short,char), 1) = 1整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 8 /* 8%1=0 */ [注1][注1] 什么是圆整举例说明：如上面的8 字节对齐中的“整体对齐”，整体大小=9 按4 圆整= 12圆整的过程：从9 开始每次加一，看是否能被4 整除，这里9，10，11 均不能被4 整除，到12 时可以，则圆整结束。字节对齐(#pragma pack(2))输出结果：sizeof(struct test_t) = 10 [两个编译器输出一致]分析过程：成员数据对齐#pragma pack(2)struct test_t {    /* 长度4 &gt; 2 按2 对齐；起始offset=0 0%2=0；存放位置区间[0,3] */    int a;     /* 长度1 &lt; 2 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */    char b;    /* 长度2 = 2 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */    short c;    /* 长度1 &lt; 2 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */    char d;};#pragma pack()成员总大小=9整体对齐整体对齐系数= min((max(int,short,char), 2) = 2整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 10 /* 10%2=0 */字节对齐(#pragma pack(4))输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]分析过程：成员数据对齐#pragma pack(4)struct test_t {    /* 长度4 = 4 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */    int a;    /* 长度1 &lt; 4 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */    char b;    /* 长度2 &lt; 4 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */    short c;    /* 长度1 &lt; 4 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */    char d;};#pragma pack()成员总大小=9整体对齐整体对齐系数= min((max(int,short,char), 4) = 4整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 /* 12%4=0 */字节对齐(#pragma pack(8))输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]分析过程：成员数据对齐#pragma pack(8)struct test_t {    /* 长度4 &lt; 8 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */    int a;    /* 长度1 &lt; 8 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */    char b;    /* 长度2 &lt; 8 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */    short c;     /* 长度1 &lt; 8 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */    char d;};#pragma pack()成员总大小=9整体对齐整体对齐系数= min((max(int,short,char), 8) = 4整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 /* 12%4=0 */字节对齐(#pragma pack(16))输出结果：sizeof(struct test_t) = 12 [两个编译器输出一致]分析过程：成员数据对齐#pragma pack(16)struct test_t {    /* 长度4 &lt; 16 按4 对齐；起始offset=0 0%4=0；存放位置区间[0,3] */    int a;    /* 长度1 &lt; 16 按1 对齐；起始offset=4 4%1=0；存放位置区间[4] */    char b;    /* 长度2 &lt; 16 按2 对齐；起始offset=6 6%2=0；存放位置区间[6,7] */    short c;    /* 长度1 &lt; 16 按1 对齐；起始offset=8 8%1=0；存放位置区间[8] */    char d;};#pragma pack()成员总大小=9整体对齐整体对齐系数= min((max(int,short,char), 16) = 4整体大小(size)=$(成员总大小) 按$(整体对齐系数) 圆整= 12 /* 12%4=0 */五、结论8 字节和16 字节对齐试验证明了“规则”的第3 点：“当#pragma pack 的n 值等于或超过所有数据成员长度的时候，这个n 值的大小将不产生任何效果”。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 内存 </tag>
        
          <tag> windows </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[拆拆 iOS 数据持久化]]></title>
      <url>/blog/ios-data-persistence/</url>
      <content type="text"><![CDATA[持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制：1）属性列表；2）对象归档；3）iOS的嵌入式关系数据库SQLite3；4）Core Data。在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I/O调用（比如，fopen()）读写数据，也可以使用Cocoa的底层文件管理工具。只不过这两种方法都需要写很多代码，并且没有必要这么做。一、应用的沙盒Cocoa提供的四种数据持久化机制都涉及一个共同因素，即应用的/Documents文件夹。每个应用都有自己的/Documents文件夹，且能读写各自的/Documents目录中的内容。为了便于理解，我们先来看一下iPhone模拟器使用的文件夹布局，从而了解iOS中应用是如何组织的。打开Finder窗口，找到主目录，找到Library（资源库）目录，找到Developer/CoreSimulator/Devices/，在该目录中可以看到一些子目录，分别对应Xcode中的模拟器。子目录的名称是Xcode自动生成的GUID（Globally Unique Identifier，全局唯一标识符），因此无法确定每个目录对应哪一个模拟器。解决这个问题的方法是找到模拟器目录中名为device.plist的文件，并打开它，就可以看见一个对应模拟器设备名称的键。虽然这是模拟器的目录，但实际设备上的文件结构与此相似。如果想看到设备上应用程序的沙盒，就将它连接到Mac上并打开Xcode的Devices窗口，在窗口边侧栏可以看到该设备，选中它然后在Installed Apps表中选择一个应用程序。在表的下方有一个看起来像齿轮的图表。点击它并在弹出菜单中选择Show Container选项就可以看到应用程序沙盒的内容。每个应用程序沙盒都包含以下三个目录：1）Documents：应用程序可以将数据存储在Documents目录中。如果这个应用程序启用了iTunes文件分享功能，用户就可以在iTunes中看到目录的内容（以及应用程序创建的所有子目录），还可以对其更新文件。如果要为应用程序启用文件分享功能，需要打开它的Info.plist文件并添加键为Application supports iTunes file sharing值为YES的条目。2）Library：应用程序也可以在这里存储数据。它用来存放不想共享给用户的文件。需要时可以创建自己的子目录。系统创建了名为Cache和Preferences的子目录。后者包含了存储应用程序偏好设置的plist文件，通过NSUserDefaults来操作。3）tmp：tmp目录供应用存储临时文件。当iOS设备执行同步时，iTunes不会备份tmp中的文件。在不需要这些文件时，应用要负责删除tmp中的文件，以免占用文件系统空间。获取Documents目录NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = paths[0];常量NSDocumentDirectory表明我们正在查找Documents目录的路径。第二个常量NSUserDomainMask表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。NSString *filename = [documentsDirectory stringByAppendingPathComponent:@”theFile.txt”];完成此调用之后，filename就包含了指向应用Documents目录中theFile.txt文件的完整路径。获取Library目录NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);NSString *libraryDirectory = paths[0];常量NSLibraryDirectory表明我们正在查找Library目录的路径。第二个常量NSUserDomainMask表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。获取tmp目录NSString *tempPath = NSTemporaryDirectory();NSString *filename = [tempPath stringByAppendingPathComponent:@”theFile.txt”];二、文件保存方案Cocoa提供的四种实现数据持久化的方法，都使用iOS的文件系统。使用SQLite3将创建一个SQLite3数据库文件，并让SQLite3去存储和检索数据。Core Data则以其最简单的形式帮助开发者完成所有的文件系统的管理工作。使用属性列表则需要考虑将数据存储在一个文件中，还是存储在多个文件中。单文件持久化把数据保存在一个文件中是最简单的方法，而且对于许多应用，这也是完全可以接受的方法。首先，创建一个根对象，通常是数组或字典（使用归档容器的情况下根对象可以给予这个自定义类）。接下来，使用所有需要保存的程序数据填充根对象。真正保存时，代码会将该根对象的全部内容重新写入单个文件。应用在启动时会将该文件的全部内容读入内存，并在退出时注销。使用单文件的缺点：必须将全部数据加载到内存中，并且不管有多小的更改也必须将所有数据全部重新写入文件系统。多文件持久化使用多文件持久化是另一种实现持久化的方法。例如，电子邮件应用可能会将每封邮件都单独存储在一个文件中。这种方法的优点，例如应用可以只加载用户请求的数据（另一种形式的延迟加载），当用户进行更改时只保存更改的文件。此方法允许开发者在收到内存不足通知时释放内存。用户当前未查看的任何数据都可以从内存中删除，下次需要时再从文件系统重新加载即可。使用多文件持久化的缺点：它大大增加了应用的复杂性。三、属性列表属性列表使用起来非常方便，可以使用Xcode或Property List Editor应用手动编辑它们。而且只要字典或数组包含特定可序列化对象，就可以将NSDictionary和NSArray实例写入属性列表或者从属性列表创建它们。属性列表序列化序列化对象，是指可以被转换为字节流以便于存储到文件中或通过网络进行传输的对象。虽然任何对象都可以被序列化，但是只有某些对象才能放置到某个集合类中（如NSDictionary或NSArray中），然后才使用该集合类的writeToFile:atomically:或writeToURL:atomically:方法将它们存储到属性列表中。可以按照该方法序列化下面的类：1）NSArray、NSMutableArray2）NSDictionary、NSMutableDictionary3）NSData、NSMutableData4）NSString、NSMutableString5）NSNumber6）NSDate如果只使用这些对象构建数据模型，就可以使用属性列表来方便地保护和加载数据。如果打算使用属性列表持久保存应用数据，则可以使用数组或字典。假设放到字典或数组中的所有对象都是前面列出的可序列化对象，则可以通过对字典或数组的实例调用writeToFile:atomically:方法来写入属性列表。[myArray writeToFile:@”/some/file/location/output.plist” atomically:YES];说明：这里的atomically参数让该方法将数据写入辅助文件，而不是写入指定位置。成功写入该文件之后，辅助文件将被复制到第一个参数指定的位置。这是更安全的写入文件的方法，因为如果应用在保存期间崩溃，则现有文件（如果有）不会被破坏。尽管增加一点开销，但是多数情况下还是值得的。属性列表方法的一个问题就是，无法将自定义对象序列化到属性列表中，另外也不能使用没有在可序列化对象类型列表中指定的Cocoa Touch的其他类。这意味着无法使用NSURL、UIImage和UIColor等类。且不说序列化问题，将这些模型对象保存到属性列表中还意味着无法轻松创建派生的或需要计算的属性（例如，等于两个属性之后的属性），并且必须将实际上应该包含在模型中的某些代码移动到控制器类。这些限制也适用于简单数据模型和简单应用。但在多数情况下，如果创建了专用的模型类，则应用更容易维护。在复杂的应用中，简单属性列表仍然非常有用。它们是将静态数据包含在应用中的最佳方法。例如，当应用包含一个选取器时，创建一个属性列表文件并将其放在项目的Resources文件夹中，就是将项目列表包含到选取器中的最佳方法，这样能把项目列表编译到应用中。NSDataNSData主要是提供一块原始数据的封装，方便数据的封装与流动，比较常见的是NSString/NSImage数据的封装与传递。在应用中，最常用于访问存储在文件中或者网络资源中的数据。这个类提供的封装/解封方法：+(id)dataWithBytes:(const void *)bytes length:(NSUInteger)length;-(NSUInteger)length;-(const void *)bytes NS_RETURNS_INNER_POINTER;从这几个方法可以看出，NSData根本不管传递的内容到底是什么，仅仅是传递一块内存——仅需内存的起始地址和长度。解析plistidresult = [NSPropertyListSerialization propertyListWithData:data options:0format:NULL error:NULL];读写plist1）写入文件NSArray*phrase;phrase =[NSArray arrayWithObjects:@"I", @"seem", @"to",@"be" ,@"a", @"verb", nil];[phrasewriteToFile:@"/tmp/verbiage.txt" atomically:YES];现在看一下文件/tmp/verbiage.txt，&lt;?xmlversion="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPEplist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plistversion="1.0"&gt;&lt;array&gt;  &lt;string&gt;I&lt;/string&gt;  &lt;string&gt;seem&lt;/string&gt;  &lt;string&gt;to&lt;/string&gt;  &lt;string&gt;be&lt;/string&gt;  &lt;string&gt;a&lt;/string&gt;  &lt;string&gt;verb&lt;/string&gt;&lt;/array&gt;&lt;/plist&gt;这些属性列表文件可以为任意复杂的形式，可以是包含字符串、数字和日期数组的字典数组。Xcode还包含一个属性列表编辑器，所以可以查看plist文件并进行编辑。说明：有些属性列表文件（特别是首选项文件）是以压缩的二进制格式存储的。通过使用plutil命令：plutil -convert xml1 filename.plist，可以将这些文件转换为人们可读的形式。2）读取之前已经将verbiage.txt文件存放在磁盘上，可以使用+arrayWithContentsOfFile:方法读取该文件。代码如下：NSArray*pharse = [NSArray arrayWithContentsOfFile:@"/tmp/ verbiage.txt "];NSLog(@"%@",phrase);说明：注意到writeToFile:方法中的单词atomically了吗？这种调用有什么负面作用吗？没有。atomically:参数的值为BOOL类型，用于通知Cocoa是否应该首先将文件内容保存在临时文件中，当文件成功保存后，再将该临时文件和原始文件交换。这是一种安全机制：如果在保存过程中出现意外，不会破坏原始文件。但这种安全机制需要付出一定的代价：在保存过程中，由于原始文件仍然保存在磁盘中，所以需要使用双倍的磁盘空间。除非保存的文件非常大，将会占用用户硬盘空间，否则应该自动保存文件。如果能将数据精简为属性列表类型，则可以使用这些非常便捷的调用来将内容保存到磁盘中，供以后读取。如果你正在从事一项新创意或设计一个新项目，可以使用这些便捷方法来快速编写和运行程序。即使只想把数据块保存到磁盘中，并且根本不需要使用对象，也可以使用NSData来简化工作。只需要将数据包装在一个NSData对象中，然后再NSData对象上调用writeToFile: atomically:方法。这些函数的一个缺点就是，它们不会返回任何错误信息。如果不能加载文件，只能从方法中得到nil指针，而不能确定出现了何种错误。创建工程在Xcode中，使用Single View Application模板创建一个项目，命名Persistence，点击Main.storyboard，布局如下图连线，添加处理函数：@interface PlistViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end- (void)viewDidLoad {    [super viewDidLoad];    // Do any additional setup after loading the view.        NSString *filePath = [self dataFilePath];    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) {        NSArray *array = [[NSArray alloc] initWithContentsOfFile:filePath];        for (int i = 0; i &lt; 4; i++) {            UITextField *theField = self.lineFields[i];            theField.text = array[i];        }    }}-(NSString *)dataFilePath{    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    NSString *documentsDirectory = [paths objectAtIndex:0];    return [documentsDirectory stringByAppendingPathComponent:@"data.plist"];}- (IBAction)saveClicked:(id)sender {    NSString *filePath = [self dataFilePath];    NSArray *array = [self.lineFields valueForKey:@"text"];    [array writeToFile:filePath atomically:YES];}四、归档在Cocoa世界中，归档是指另一中形式的序列化，但它是任何对象都可以实现的更常规的类型。专门编写用于保存数据的任何模型对象都应该支持归档。使用对模型对象进行归档的技术可以轻松将复杂的对象写入文件，然后再从中读取它们。只要在类中实现的每个属性都是标量（如整型或浮点型）或都是遵循NSCoding协议的某个类的实例，就可以对整个对象进行完全的归档。由于大多数支持存储数据的Foundation和Cocoa Touch类都遵循NSCoding协议（不过，有一些例外，如UIImage），对于大多数类来说，归档相对而言比较容易实现。尽管对归档的使用没有严格要求，但还有一个协议应该与NSCoding一起实现，即NSCopying协议。后者允许复制对象，这使开发者在使用数据模型对象时具备了较大的灵活性。遵循NSCoding协议NSCoding协议声明了两个必须实现的方法，一个方法将对象编码到归档中，另一个方法对归档解码来创建一个新对象。这两个方法都传递一个NSCoder实例，使用方式与NSUserDefaults非常相似。也可以使用KVC对对象和原生数据类型进行编码和解码。@protocolNSCoding-(void)encodeWithCoder:(NSCoder*)aCoder;-(id)initWithCoder:(NSCoder*)aDecoder;@end当对象需要保存自身时，encodeWithCoder:方法将被调用；当对象需要加载自身时，initWithCoder:方法将被调用。那么，这个编码器是什么呢？NSCoder是一个抽象类，定义一些有用的方法来在对象与NSData之间来回转换。完全不需要创建新NSCoder，因为它实际上并无多大作用。但是，我们实际上要使用NSCoder的一些具体的子类来编码和解码对象。我们将使用其中两个子类NSKeyedArchiver和NSKeyedUnarchiver。initWithCoder:和其他任何init方法一样，在对对象执行操作之前，需要使用超类对它们进行初始化。为此，可以采用两种方式，具体取决于父类。如果父类采用NSCoding协议，则应该调用[super initWithCoder:decoder]；否则，只需要调用[super init]即可。NSObject不采用NSCoding协议，因此我们使用简单的init方法。+ archivedDataWithRootObject:类方法编码thing对象。首先，它在后台创建一个NSKeyedArchiver实例；然后，它将NSKeyedArchiver实例传递给对象thing的-encodeWithCoder:方法。当thing编码自身的属性时，它可能对其他对象也进行编码，例如，字符串、数组以及我们可能输入到该数组中的任何内容。整个对象集合完成键和值的编码后，具有键/值对的归档程序将所有对象扁平化为一个NSData类并将其返回。如果愿意，可以使用-writeToFile:atomically:方法将这个NSData类保存到磁盘中。在此，我们先处理thing对象，然后通过freezeDried表示法重新创建它，并将它输出：thing =[NSKeyedUnarchiveObjectWithData: freezeDried];NSLog(@"reconstitutedthing:%@",thing);如果被编码的数据中含有循环将会怎么样？例如，如果thing包含在自身的subThingies数组中会怎样？thing会对数组进行编码吗？哪个对象对thing进行编码，哪个对象对数组进行编码，哪个对象再次对thing进行编码，依此类推？幸运的是，Cocoa在归档程序和解压程序实现上非常灵活，能够保存并恢复对象周期。实现NSCopying协议遵循NSCopying对于任何数据模型对象来说都是非常好的事情。NSCopying有一个copyWithZone:方法，可用来复制对象。实现NSCopying与实现initWithCoder:非常相似，只需要创建一个同一类的新实例，然后将新实例的所有属性都设置为与该对象属性相同的值即可。说明：不要过于担心NSZone参数。它指向系统用于管理内存的struct。只有在极少数情况下，开发者才需要关注zone或者创建自己的zone。目前，还没有使用多个zone的说法。对某个对象调用copy的方法与使用默认zone调用copyWithZone的方法完全相同，几乎始终能满足你的需求。事实上，现在的iOS上完全可以忽略zone。NSCopying用zone在本质上是考虑向后兼容性所致。创建工程按照上文创建工程，设计界面（与上文界面相同），连线，添加响应方法：#import "ArchiverViewController.h"#import "Lines.h"static NSString *const kRootKey = @"kRootKey";@interface ArchiverViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end- (void)viewDidLoad {    [super viewDidLoad];    // Do any additional setup after loading the view.        NSString *filePath = [self dataFilePath];    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) {        NSData *data = [[NSMutableData alloc] initWithContentsOfFile:filePath];        NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];        Lines *lines = [unarchiver decodeObjectForKey:kRootKey];        [unarchiver finishDecoding];                for (int i = 0; i &lt; 4; i++) {            UITextField *theField = self.lineFields[i];            theField.text = lines.lines[i];        }    }}-(NSString *)dataFilePath{    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    NSString *documentsDirectory = [paths objectAtIndex:0];    return [documentsDirectory stringByAppendingPathComponent:@"data.archive"];}- (IBAction)saveClicked:(id)sender {    NSString *filePath = [self dataFilePath];    Lines *lines = [[Lines alloc] init];    lines.lines = [self.lineFields valueForKey:@"text"];    NSMutableData *data = [[NSMutableData alloc] init];    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];    [archiver encodeObject:lines forKey:kRootKey];    [archiver finishEncoding];    [data writeToFile:filePath atomically:YES];}与属性列表序列化实现多几行代码，那么是否就是使用归档比使用序列化属性列表更有优势呢？答案是否定的。如果我们拥有一个包含可归档对象的数组，则可以对数组实例本身进行归档来归档整个数组。对集合类（如数组）进行归档时，也会归档其包含的所有对象。只要放入数组或字典中的对象遵循NSCoding，就可以归档数组或字典并还原它。这样，对其进行归档时，其中所有对象都将位于已还原的数组和字典中。这一点并不适用于属性链接的持久化，它只支持一小部分的Foundation对象类型。如果没有编写额外的代码，来将这些自定义类的实例与字典通过每个对象属性的键进行互相转化，就不能对其进行持久化。换句话说，NSCoding方法具有非常好的伸缩性，因为无论添加多少对象，将这些对象写入磁盘的方式都完全相同。不过使用属性列表的话，工作量会随着添加对象而增加。五、SQLite3SQLite3在存储和检索大量数据方面非常有效。它能够对数据进行复杂的聚合，与使用对象执行这些操作相比，获得结果的速度更快。SQLite3使用SQL（Structured Query Language，结构化查询语言），SQL是与关系数据库交互的标准语言。这里推荐两篇SQLite3深入研究探索的参考文章：An Introduction to the SQLite3 C/C++ Interface (www.sqlite.org/cintro.html)SQL As Understood by SQLite (www.sqlite.org/lang.html)关系数据库（包括SQLite3）和面向对象的编程语言使用完全不同的方法来存储和组织数据。这些方法差异很大，因而出现了在两者之间进行转换的各种技术以及很多库和工具。这些技术统称为ORM（Object-Relational-Mapping，对象关系映射）。目前有很多种ORM工具可用于Cocoa Touch。绑定变量虽然可以通过创建SQL字符串来插入值，但常用的方法是使用绑定变量来执行数据库插入操作。正确处理字符串并确保它们没有无效字符（以及引号处理过的属性）是非常烦琐的事情。借助绑定变量，这些问题将迎刃而解。要使用绑定变量插入值，只需要按正常方式创建SQL语句即可，不过要在SQL字符串中添加一个问号。每个问号都表示一个需要在语句执行之前进行绑定的变量。然后，准备好SQL语句，将值绑定到各个变量并执行命令。/*将整型数据绑定到第一个变量，将字符串绑定到第二个变量，然后执行并结束语句*/char *sql = “insert into foo values (?, ?);”;sqlite3_stmt *stmt;if(sqlite3_prepare_v2(database, sql, -1, &amp;stmt, nil) == SQLITE_OK){    sqlite3_bind_int(stmt, 1, 235);    sqlite3_bind_text(stmt, 2, “Bar”, -1, NULL);}if(sqlite3_step(stmt) != SQLITE_DONE){    NSLog(@”This should be real error checking!”);}sqlite3_finalize(stmt);根据希望使用的数据类型，可以选择不同的绑定语句。大部分绑定函数都只有3个参数。1）无论针对哪种数据类型，任何绑定函数的第一个参数都指向之前在sqlite3_prepare_v2()调用中使用的sqlite3_stmt。2）第二个参数是被绑定变量的索引。它是一个有序索引值，者这表示SQL语句中的第一个问号是索引1，其后面的每个问号都依次按序增加1。3）第三个参数始终表示应该替换问号的值。有些绑定函数（比如用于绑定文本和二进制数据的绑定函数）拥有另外两个参数。1）一个参数是在上面第三个参数中传递的数据长度。对于C字符串，可以传递-1来代替字符串长度，这样函数将使用整个字符串。对于所有其他情况，需要指定所传递数据的长度。2）另外一个参数是可选的函数回调，用于在语句执行后完成内存清理工作。通常，这种函数使用malloc()释放已分配的内存。创建工程创建工程，设计布局，与前文工程相同操作，连线，添加响应方法：#import "SqliteViewController.h"#import &lt;sqlite3.h&gt;@interface SqliteViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end导入sqlite库- (void)viewDidLoad {    [super viewDidLoad];    // Do any additional setup after loading the view.        sqlite3 *database;    //打开数据库    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) {        sqlite3_close(database);        NSAssert(0, @"Failed to open database");    }        /**     有用的C语言知识：     如果两个内联的字符串之间只有空白（包括换行符）而没有其他字符，     那么这两个字符串会被连接为一个字符串。     */        //创建数据库SQL    NSString *createSQL = @"create table if not exists fields (row integer primary key, field_data text);";    char *errorMsg;    //执行SQL语句    if (sqlite3_exec(database, [createSQL UTF8String], NULL, NULL, &amp;errorMsg) != SQLITE_OK) {        sqlite3_close(database);        NSAssert(0, @"Error creating table: %s", errorMsg);    }        //查询数据库    NSString *query = @"select row, field_data from fields order by row;";    sqlite3_stmt *statement;    if (sqlite3_prepare_v2(database, [query UTF8String], -1, &amp;statement, nil) == SQLITE_OK) {        //遍历返回的每行        while (sqlite3_step(statement) == SQLITE_ROW) {            int row = sqlite3_column_int(statement, 0);            char *rowData = (char *)sqlite3_column_text(statement, 1);            NSString *fieldValue = [[NSString alloc] initWithUTF8String:rowData];            UITextField *field = self.lineFields[row];            field.text = fieldValue;        }        sqlite3_finalize(statement);    }    //关闭数据库    sqlite3_close(database);}-(NSString *)dataFilePath{    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);    NSString *documentsDirectory = [paths objectAtIndex:0];    return [documentsDirectory stringByAppendingPathComponent:@"data.sqlite"];}- (IBAction)saveClicked:(id)sender {    sqlite3 *database;    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) {        sqlite3_close(database);        NSAssert(0, @"Failed to open database");    }        for (int i = 0; i &lt; 4; i++) {        UITextField *field = self.lineFields[i];        //内联字符串的连接，又一次派上用场        char *update = "insert or replace into fields (row, field_data) values (?, ?);";        char *errorMsg = NULL;        sqlite3_stmt *stmt;        //绑定变量        if (sqlite3_prepare_v2(database, update, -1, &amp;stmt, nil) == SQLITE_OK) {            sqlite3_bind_int(stmt, 1, i);            sqlite3_bind_text(stmt, 2, [field.text UTF8String], -1, NULL);        }        //判断执行更新是否成功        if (sqlite3_step(stmt) != SQLITE_DONE) {            NSAssert(0, @"Error updating table: %s", errorMsg);        }        sqlite3_finalize(stmt);    }    sqlite3_close(database);}其实，以上者三种方式没有什么差异，只不过是三种不同的持久化机制而已。六、Core DataCore Data是一款稳定、功能全面的持久化工具。术语实体：表示对对象的描述。托管对象：表示在运行时创建该实体的具体实例。注意，在数据模型编辑器中，你将创建实体；而在代码中，你将创建并检索托管对象。实体和托管对象之间的差异类似于类与类的实例。实体由属性组成，属性分为3种类型：1）特性（attribute）：特性在Core Data实体中的作用与实例变量在Objective-C类中的作用完全相同，它们都用于保存数据。2）关系（relationship）：关系用于定义实体之间的关系。举例来说，假设要定义一个Person实体，你可能首先会定义一些特性，比如height和weight，还可以定义地址特性，比如state和zipCode，或者将它们嵌入到单独的HomeAddr实体中。使用后面这种方法，你可能希望在Person与HomeAddr之间创建一个关系。关系可以是一对一或一对多。从Person到HomeAddr的关系可以是“一对一”，因为大多数人都只有一个家庭地址。从HomeAddr到Person的关系则可以是“一对多”，因为可能多个人住在同一个家庭地址。3）提取属性（fetched property）：提取属性是关系的备选方法。用提取属性可以创建一个能在提取时被评估的查询，从而确定哪些对象属于这个关系。沿用刚才的例子，一个Person对象可以拥有一个名为Neighbors的提取属性，该属性查找数据存储中与这个Person的HomeAddr拥有相同zipCode的所有HomeAddr对象。由于提取属性的结构和使用方式，它们通常都是一对一关系。提取属性也是唯一一种能够让你跨越多个数据存储的关系。创建工程依旧如前文方式创建工程，添加响应参数，不过在这里要注意的是，Core Data的创建方法步骤：1）创建Model文件2）编辑Model文件，点击“Add Entity”添加实体，点击“Add Attribute”添加特性3）创建NSManagedObject文件，关联数据模型#import "CoreDataViewController.h"#import &lt;CoreData/CoreData.h&gt;static NSString *const kLineEntityName = @"Line";static NSString *const kLineNumberKey = @"lineNumber";static NSString *const kLineTextKey = @"lineText";@interface CoreDataViewController ()- (IBAction)saveClicked:(id)sender;@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;@end- (void)viewDidLoad {    [super viewDidLoad];    // Do any additional setup after loading the view.        NSManagedObjectContext *context = [self myContext];    NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];    NSError *error;    NSArray *objects = [context executeFetchRequest:request error:&amp;error];    if (objects == nil) {        NSLog(@"There was an error!");    }    for (NSManagedObject *oneObject in objects) {        int lineNum = [[oneObject valueForKey:kLineNumberKey] intValue];        NSString *lineText = [oneObject valueForKey:kLineTextKey];        UITextField *theField = self.lineFields[lineNum];        theField.text = lineText;    }}-(NSManagedObjectContext *)myContext{    //上下文 关联Company.xcdatamodeld模型文件    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];    //模型文件    NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];    //持久化存储调度器    NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];    NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];    NSString *sqlitePath = [doc stringByAppendingPathComponent:@"line.sqlite"];    //数据存储的类型 数据库存储路径    [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:sqlitePath] options:nil error:nil];    context.persistentStoreCoordinator = store;        return context;}- (IBAction)saveClicked:(id)sender {        NSManagedObjectContext *context = [self myContext];        NSError *error;    for (int i = 0; i &lt; 4; i++) {        UITextField *theField = self.lineFields[i];        NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];        NSPredicate *pred = [NSPredicate predicateWithFormat:@"(%K = %d)", kLineNumberKey, i];        [request setPredicate:pred];        NSArray *objects = [context executeFetchRequest:request error:&amp;error];        if (objects == nil) {            NSLog(@"There was an error!");        }        NSManagedObject *theLine = nil;        if ([objects count] &gt; 0) {            theLine = [objects objectAtIndex:0];        }else{            theLine = [NSEntityDescription insertNewObjectForEntityForName:kLineEntityName inManagedObjectContext:context];        }        [theLine setValue:[NSNumber numberWithInt:i] forKey:kLineNumberKey];        [theLine setValue:theField.text forKey:kLineTextKey];    }    [context save:nil];    }Core Data版本与之前的版本功能完全相同。Core Data需要的工作量很大。对于这种简单的应用，它并没有提供明显的优势。但是在比较复杂的应用中，Core Data可以显著减少设计和编写数据模型所需的时间。七、总结四种数据持久化机制，各有优势，根据使用情况选择对应机制进行数据持久化。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 存储 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS App 偏好设置]]></title>
      <url>/blog/ios-preference-setting/</url>
      <content type="text"><![CDATA[如今，即便是最简单的计算机程序也会包含一个偏好设置窗口，用户可以在其中设置应用专属的选项。在MAC OS X中，Preferences…菜单通常位于应用菜单中。选择该菜单项会弹出一个窗口，用户可以在其中输入和更改各种选项。iPhone和其他iOS设备有一个专门的“设置”应用程序来进行各种设置，你肯定用过很多次了。设置捆绑包通过应用设置，用户可以输入和更改任何带有设置捆绑包（settings bundle）的应用中的偏好设置。设置捆绑包是应用自带的一组文件，用于告诉设置该应用期望得到用户的哪些偏好设置。下图是实例效果图：对于iOS用户默认设置（User Defaults）机制，设置应用充当着通用用户界面的角色。用户默认设置是保存和获取偏好设置的系统的一部分。在iOS应用中，用户默认设置由NSUserDefaults类实现。应用通过NSUserDefaults用键值对的方式来读取和保存偏好设置数据，与通过键从NSDictionary对象中获取数据一样。不同之处在于NSUserDefaults数据会被持久保存在文件系统中，而不是存储在内存的对象实例中。应用接下来的部分，通过创建一个简单的应用，来实现应用设置控制应用程序。创建应用在Xcode中，创建Tabbed Application工程。使用设置捆绑包设置应用使用每个应用中设置捆绑包的内容构建出一个应用的设置视图。如果应用没有设置捆绑包，则设置应用不会显示出应用程序的任何信息。每个设置捆绑包必须包含一个名为Root.plist的属性列表，它定义了根级偏好设置视图。此属性列表必须遵循一种非常严格的格式。当设置应用启动时，它会检查每个应用程序的设置捆绑包并为包含设置捆绑包的每个应用添加设置组。在项目中添加设置捆绑包新建设置捆绑包，操作如下图在iOS－－&gt;Resource－－&gt;Settings Bundle点击Next，名字保留默认，最后点击Create即可。编辑属性列表文件接下来需要编辑Root.plist文件，具体内容如下图在Item8中，引用的More.plist文件，具体内容如下图这里需要补充说明一点：iOS上的应用不能从其他应用的沙盒中读取文件。设置捆绑包并不是我们应用沙盒的一部分，而是设置应用沙盒的一部分。设计展示界面数据准备好之后，添加图标资源，设计数据展示界面。效果图如下界面是通过代码实现的，主要使用了如下几个控件：@interface FirstViewController ()@property (nonatomic, strong) UILabel *officerLabel;@property (nonatomic, strong) UILabel *authorizationCodeLabel;@property (nonatomic, strong) UILabel *rankLabel;@property (nonatomic, strong) UILabel *warpDriveLabel;@property (nonatomic, strong) UILabel *warpFactorLabel;@property (nonatomic, strong) UILabel *favoriteTeaLabel;@property (nonatomic, strong) UILabel *favoriteCaptainLabel;@property (nonatomic, strong) UILabel *favoriteGadgetLabel;@property (nonatomic, strong) UILabel *favoriteAlienLabel;@end@interface SecondViewController ()@property (nonatomic, strong) UISwitch *engineSwitch;@property (nonatomic, strong) UISlider *warpFactorSlider;@property (nonatomic, strong) UIButton *settingInfo;@end读取应用中的设置我们将使用NSUserDefaults类访问用户设置。NSUserDefaults作为单例类，意味着应用中只能有一个NSUserDefaults实例在运行。为了访问这个实例，需要调用standardUserDefaults。键宏定义#ifndef BridgeControl_Constants_h#define BridgeControl_Constants_h#define kOfficerKey @"officer"#define kAuthorizationCodeKey @"authorizationCode"#define kRankKey @"rank"#define kWarpDriveKey @"warp"#define kWarpFactorKey @"warpFactor"#define kFavoriteTeaKey @"favoriteTea"#define kFavoriteCaptionKey @"favoriteCaptain"#define kFavoriteGadgetKey @"favoriteGadget"#define kFavoriteAlienKey @"favoriteAlien"#endif更新主视图控制器//FirstViewController.m- (void)viewDidLoad {    [super viewDidLoad];    // Do any additional setup after loading the view, typically from a nib.    [self refreshFields];}-(void)refreshFields{    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];    self.officerLabel.text = [defaults objectForKey:kOfficerKey];    self.authorizationCodeLabel.text = [defaults objectForKey:kAuthorizationCodeKey];    self.rankLabel.text = [defaults objectForKey:kRankKey];    self.warpDriveLabel.text = [defaults boolForKey:kWarpDriveKey] ? @"engaged" : @"Disabled";    self.warpFactorLabel.text = [[defaults objectForKey:kWarpFactorKey] stringValue];    self.favoriteTeaLabel.text = [defaults objectForKey:kFavoriteTeaKey];    self.favoriteCaptainLabel.text = [defaults objectForKey:kFavoriteCaptionKey];    self.favoriteGadgetLabel.text = [defaults objectForKey:kFavoriteGadgetKey];    self.favoriteAlienLabel.text = [defaults objectForKey:kFavoriteAlienKey];}//SecondViewController.m- (void)viewDidLoad {    [super viewDidLoad];    // Do any additional setup after loading the view, typically from a nib.    [self refreshFields];}-(void)refreshFields{    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];    self.engineSwitch.on = [defaults boolForKey:kWarpDriveKey];    self.warpFactorSlider.value = [defaults floatForKey:kWarpFactorKey];}添加控件响应事件为SecondViewController中的UIButton，UISwitch和UISlider控件添加监听事件。- (void)engineSwitchTapped {    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];    [defaults setBool:self.engineSwitch.on forKey:kWarpDriveKey];    [defaults synchronize];}- (void)warpSliderTouched {    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];    [defaults setFloat:self.warpFactorSlider.value forKey:kWarpFactorKey];    [defaults synchronize];}//切换到“设置”应用程序-(void)settingInfoClicked{    [[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];}注册默认值//AppDelegate.m- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {    // Override point for customization after application launch.        //程序启动后的一些自定义设置    NSDictionary *defaults = @{kWarpDriveKey:@YES,                               kWarpFactorKey:@2,                               kFavoriteAlienKey:@"Vulcan"                               };    [[NSUserDefaults standardUserDefaults] registerDefaults:defaults];        return YES;}保证设置有效如果现在将应用运行，查看设置信息并按下主屏幕按钮来修改一些值。然后再按Home键，再重新打开应用，结果发现设置并没有生效。原因在于：在iOS中，当应用正在运行时按Home键并不会退出该应用，而是由操作系统在后台将其暂停，这样它就能随时快速启动。在这个例子中，我们需要添加一点工作，以实现应用被唤醒时，能重新加载用户偏好设置并重新显示它们。通知，时对象之间进行通信的轻量级机制。任何对象都能定义一个或多个发送到应用通知中心的通知。通知中心是一个单例对象，作用在于对象之间传送通知。UIApplication类会发送大量的通知，大多数通知的用途从命名就能看出来，这个例子中我们就使用到了通知。将下列代码添加到两个控制器的viewDidLoad方法中：UIApplication *app = [UIApplication sharedApplication];    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationWillEnterForeground:) name:UIApplicationWillEnterForegroundNotification object:app];然后添加相应的响应方法-(void)applicationWillEnterForeground:(NSNotification *)notification{    NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];    [defaults synchronize];    [self refreshFields];}小结本文主要讲解了如何使用应用设置，如何使用NSUserDefaults读取偏好设置，以及如何让用户在应用内修改偏好设置。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> application </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HTTP 状态码清单]]></title>
      <url>/blog/http-state-code-list/</url>
      <content type="text"><![CDATA[HTTP 我们常用的网络请求之一，然因为各种网络或者硬件原因，网络请求之后总能拿到一些状态返回码，那么它们到底代表什么意思呢？本文就是将这些常见的状态码加以收集，整理归类。1xx消息这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。100 Continue客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。101 Switching Protocols服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。102 Processing由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。2xx成功这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。201 Created请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。202 Accepted服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。203 Non-Authoritative Information服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。204 No Content服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。205 Reset Content服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。206 Partial Content服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。响应必须包含如下的头部域：Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。DateETag和／或Content-Location，假如同样的请求本应该返回200响应。Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。207 Multi-Status由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。3xx重定向这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。300 Multiple Choices被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。302 Found请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。303 See Other对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。304 Not Modified如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag和／或Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。305 Use Proxy被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。306 Switch Proxy在最新版的规范中，306状态码已经不再被使用。307 Temporary Redirect请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。4xx客户端错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。400 Bad Request由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。401 Unauthorized当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。402 Payment Required该状态码是为了将来可能的需求而预留的。403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。405 Method Not Allowed请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。406 Not Acceptable请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。407 Proxy Authentication Required与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。408 Request Timeout请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。409 Conflict由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。410 Gone被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。411 Length Required服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。412 Precondition Failed服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。413 Request Entity Too Large服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。414 Request-URI Too Long请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。415 Unsupported Media Type对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。416 Requested Range Not Satisfiable如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。417 Expectation Failed在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。418 I’m a teapot本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。421 There are too many connections from your internet address从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。422 Unprocessable Entity请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked当前资源被锁定。（RFC 4918 WebDAV）424 Failed Dependency由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）425 Unordered Collection在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。426 Upgrade Required客户端应当切换到TLS/1.0。（RFC 2817）449 Retry With由微软扩展，代表请求应当在执行完适当的操作后进行重试。5xx服务器错误这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。501 Not Implemented服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。502 Bad Gateway作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。504 Gateway Timeout作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。注意：某些代理服务器在DNS查询超时时会返回400或者500错误505 HTTP Version Not Supported服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。506 Variant Also Negotiates由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。507 Insufficient Storage服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918）509 Bandwidth Limit Exceeded服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。510 Not Extended获取资源所需要的策略并没有没满足。]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> 网络 </tag>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[iOS 二维码扫描]]></title>
      <url>/blog/ios-qrcode-scaner/</url>
      <content type="text"><![CDATA[二维条码/二维码（2-dimensional bar code）是用某种特定的几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息的；在代码编制上巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特流的概念，使用若干个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理：它具有条码技术的一些共性：每种码制有其特定的字符集；每个字符占有一定的宽度；具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。在这么一个二维码泛滥的时代，一般的App都会支持二维码扫描，那么这个功能应该如何实现呢？这几天博主高仿新浪微博的项目进行一个阶段性的tag，在此也将这个项目在实现二维码扫描这个功能来做一个简要的记录。关于二维码的扫描，网上说的最多的框架莫过于ZBar和ZXing框架，刚开始也是想使用第三方框架，但是，在iOS7之后苹果官方已经提供了二维码扫描方法，而且实现起来还是蛮简单的，故而选择原生态方法。不过，我们还是来看看，如何使用ZBar实现二维码扫描。首先在github上下载ZBar代码，然后将如下的相关类库添加进去：　  AVFoundation.framwork  CoreMedia.framework  CoreVideo.framework  libiconv.dylib  libzbar.a接下来在.h文件中#import “ZBarSDK.h”，同时添加代理ZBarReaderDelegate，然后在.m文件中添加如下代码：-(void)sysbutbuttonclick{           ZBarReaderViewController *reader = [ZBarReaderViewController new];     reader.readerDelegate = self;     ZBarImageScanner *scanner = reader.scanner;           [scanner setSymbology: ZBAR_I25                    config: ZBAR_CFG_ENABLE                        to: 0];     [self presentModalViewController: reader    animated: YES]; }   - (void) imagePickerController: (UIImagePickerController*) reader  didFinishPickingMediaWithInfo: (NSDictionary*) info {           NSLog(@"info=%@",info);     // 得到条形码结果     id&lt;NSFastEnumeration&gt; results =[info objectForKey: ZBarReaderControllerResults];     ZBarSymbol *symbol = nil;     for(symbol in results)         // EXAMPLE: just grab the first barcode         break;                 UIAlertView *alert=[[UIAlertView alloc] initWithTitle:@"信息提示!" message:symbol.data delegate:self cancelButtonTitle:@"取消" otherButtonTitles:@"确定", nil];     [alert show]; }最后触发扫描事件的时候调用sysbutbuttonclick即可。博主在项目中使用的是苹果官方提供的，并将其实现单独封装，以方便使用。其实我们只需要三个步骤即可实现二维码扫描功能：1）导入AVFoundation框架，import &lt;AVFoundation/AVFoundation.h&gt;；2）设置一个用于显示扫描的view；3）实例化AVCaptureSession、AVCaptureVideoPreviewLayer。具体实现方式如下：1）添加开始扫描方法：- (void)startReading{    NSError *error;         //1.初始化捕捉设备（AVCaptureDevice），类型为AVMediaTypeVideo    AVCaptureDevice *captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];         //2.用captureDevice创建输入流    AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:captureDevice error:&amp;error];    if (!input) {        NSLog(@"%@", [error localizedDescription]);    }         //3.创建媒体数据输出流    AVCaptureMetadataOutput *captureMetadataOutput = [[AVCaptureMetadataOutput alloc] init];         //4.实例化捕捉会话    _captureSession = [[AVCaptureSession alloc] init];    //4.1.将输入流添加到会话    [_captureSession addInput:input];    //4.2.将媒体输出流添加到会话中    [_captureSession addOutput:captureMetadataOutput];         //5.创建串行队列，并加媒体输出流添加到队列当中    dispatch_queue_t dispatchQueue;    dispatchQueue = dispatch_queue_create("myScanQueue", NULL);    //5.1.设置代理    [captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatchQueue];    //5.2.设置输出媒体数据类型为QRCode    [captureMetadataOutput setMetadataObjectTypes:[NSArray arrayWithObject:AVMetadataObjectTypeQRCode]];         //6.实例化预览图层    _videoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:_captureSession];         //7.设置预览图层填充方式    [_videoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];         //8.设置图层的frame    [_videoPreviewLayer setFrame:_viewPreview.layer.bounds];         //9.将图层添加到预览view的图层上    [_viewPreview.layer addSublayer:_videoPreviewLayer];         //10.设置扫描范围    captureMetadataOutput.rectOfInterest = CGRectMake(0.2f, 0.2f, 0.8f, 0.8f);    //10.1.扫描框    _boxView = [[UIView alloc] initWithFrame:CGRectMake(_viewPreview.bounds.size.width * 0.1f, _viewPreview.bounds.size.height * 0.2f, _viewPreview.bounds.size.width * 0.8f, _viewPreview.bounds.size.width * 0.8f)];    _boxView.layer.borderColor = kRangeColor;    _boxView.layer.borderWidth = 1.0f;    [_viewPreview addSubview:_boxView];    //10.2.扫描线    _scanLayer = [[CALayer alloc] init];    _scanLayer.frame = CGRectMake(0, 0, _boxView.bounds.size.width, kLineBorad);    _scanLayer.backgroundColor = kLineColor;    [_boxView.layer addSublayer:_scanLayer];         NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:0.2f target:self selector:@selector(moveScanLayer:) userInfo:nil repeats:YES];       [timer fire];         //11.开始扫描    [_captureSession startRunning];}2）实现代理方法：#pragma mark - AVCaptureMetadataOutputObjectsDelegate- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection{    NSString *urlStr;    //判断是否有数据    if (metadataObjects != nil &amp;&amp; [metadataObjects count] &gt; 0) {        AVMetadataMachineReadableCodeObject *metadataObj = [metadataObjects objectAtIndex:0];        //判断回传的数据类型        if ([[metadataObj type] isEqualToString:AVMetadataObjectTypeQRCode]) {            urlStr = metadataObj.stringValue;            [self performSelectorOnMainThread:@selector(stopReading) withObject:nil waitUntilDone:NO];        }    }     _videoPreviewLayer.hidden = YES;    _webView.hidden = NO;    NSURLRequest *request =[NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]];    [self.webView loadRequest:request];   }3）设置好页面布局，用来显示扫描结果即可。以上就是两种二维码扫描实现简要过程。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> 外设 </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[PHP MVC模式简单实现]]></title>
      <url>/blog/php-mvc-framework/</url>
      <content type="text"><![CDATA[MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。代码结构代码实现&lt;?php        //function.php  	//控制器调用函数	function C($name, $method){		require_once('libs/Controller/'.$name.'Controller.class.php');		//$testController = new testController();		//$testController-&gt;show();		eval('$obj = new '.$name.'Controller(); $obj-&gt;'.$method.'();');	}	//模型调用函数	function M($name){		require_once('libs/Model/'.$name.'Model.class.php');		eval('$obj = new '.$name.'Model();');		return $obj;	}	//视图调用函数	function V($name){		require_once('libs/View/'.$name.'View.class.php');		eval('$obj = new '.$name.'View();');		return $obj;	}	//过滤非法值	function daddslashes($str){		return (!get_magic_quotes_gpc())?addslashes($str):$str;	}?&gt; &lt;?php//test.php/*第一步 浏览者 -&gt; 调用控制器,对它发出指令第二步 控制器 -&gt; 按指令选取一个合适的模型第三步 模型 -&gt; 按控制器指令取相应数据第四步 控制器 -&gt; 按指令选取相应视图第五步 视图 -&gt; 把第三步取到的数据按用户想要的样子显示出来*/require_once('View/testView.class.php');require_once('Model/testModel.class.php');require_once('Controller/testController.class.php');$testController = new testController();$testController-&gt;show();?&gt;&lt;?php//testController.class.php/*控制器的作用是调用模型,并调用视图,将模型产生的数据传递给视图,并让相关视图去显示*/	class testController{		function show(){			/*$testModel = new testModel();			$data = $testModel-&gt;get();			$testView = new testView();			$testView-&gt;display($data);*/			$testModel = M('test');			$data = $testModel-&gt;get();			$testView = V('test');			$testView-&gt;display($data);		}	}?&gt; &lt;?php//testModel.class.php/*模型的作用是获取数据并处理,返回数据*/	class testModel{		function get(){			return "hello world";		}	}?&gt; &lt;?php//testView.class.php/*视图的作用是将获得的数据进行组织,美化等,并最终向用户终端输出*/	class testView{		function display($data){			echo $data;		}	}?&gt;运行结果]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> php </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaScript 实现自适应窗口大小的网页]]></title>
      <url>/blog/js-adjust-window-page/</url>
      <content type="text"><![CDATA[随着移动互联网的兴起，网页浏览端不再仅仅只是电脑，更多的用户选择在移动端使用，那么，我们肯定不能再使用电脑版的页面布局，那么我们将如何适应纷繁多样的界面尺寸呢，本问主要介绍如何使用JavaScript实现自适应窗口大小的网页。&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;    &lt;meta http-equiv="imagetoolbar" content="no"&gt;    &lt;meta name="viewport" content="width=device-width,inital-scale=1"/&gt;    &lt;title&gt;Login&lt;/title&gt;    &lt;style type="text/css"&gt;body{    text-align: left;    background-color: F6F6F6;    background-attachment: fixed;}#imgcenter{    position:relative;    height: auto;    width:50%;    left:20%;    top:250px;}#center{    position:relative;    height: auto;    width:50%;    left:20%;    top:220px;}#account{    position:relative;    height: auto;    left:60%;    top:-110px;    padding:2%;    width:50%;}#pwd{    position:relative;    height: auto;    left:60%;    top:-100px;    padding:2%;    width: 50%;}#login{    position:relative;    height: auto;    left:60%;    top:-95px;    padding:1%;    width: 25%;}#logo{    padding:3%;    width: 50%;    height: auto;}#div_forgetpwd{    position:relative;    height: 30%;    left: 90%;    top:-115px;    width: 25%;    font-size: 1pt;       white-space:nowrap;}#div_forgetpwd a{    text-decoration: none;    margin: auto;}#div_forgetpwd a:hover{    text-decoration: underline;    margin: auto;}.Clew{    position:relative;    height: 15px;    left:-10%;    top:-80%;    padding:2% 50%;    white-space:nowrap;    color: #FFFFD5;    font-weight: bold;    font-family: century gothic, arial;    background: #FCBE47;    border-top: 2px solid #db6e3c;    border-bottom: 2px solid #db6e3c;}&lt;/style&gt;    &lt;script type="text/javascript" src="E:\MyProject\html\KServer\jquery-1.4.2.min.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript"&gt;//error clewvar userFlag=0;var pwdFlag=0;$().ready(function() {    $("form :input").blur(function() {        var $parent = $(this).parent();        $parent.find(".clew").remove();        if($(this).is(".username")) {            if(this.value=="" || this.value.length &lt; 0) {                var errorMsg = "Please enter your account.";                $parent.append("&lt;span class='clew Clew'&gt;"+errorMsg+"&lt;/span&gt;");            }else		userFlag=1;        }        if($(this).is(".password")) {            if(this.value=="" || this.value.length &lt; 0) {                var errorMsg = "Please enter your password.";                $parent.append("&lt;span class='clew Clew'&gt;"+errorMsg+"&lt;/span&gt;");            }else		pwdFlag=1;        }           }).keyup(function() {        $(this).triggerHandler("blur");    }).focus(function() {        $(this).triggerHandler("blur");    });});//提交检验function validate_form(thisform){    with (thisform){        if (userFlag==0||pwdFlag==0){            username.focus();            return false;        }    }}&lt;/script&gt;&lt;/head&gt;&lt;body bgcolor="#F6F6F6" &gt;&lt;!--&lt;form  action="#" method="get" name="form" id="form"&gt; 当前窗口高度： &lt;input type="text" name="availHeight" size="6"&gt; &lt;br&gt; 当前窗口宽度： &lt;input type="text" name="availWidth" size="6"&gt; &lt;br&gt; &lt;/form&gt;--&gt;    &lt;div id="imgcenter"&gt;        &lt;img src="E:\MyProject\html\KServer\login\login.png" id="logo" align="left" &gt;&lt;/div&gt;    &lt;div id="center"&gt;        &lt;form method="post" action="db.html" onsubmit="return validate_form(this);"&gt;            &lt;input type=text name="username" value="请输入用户名.." id="account"            class="username"&gt;            &lt;br&gt;            &lt;input type=password name="password" value=".." id="pwd" class="password"&gt;            &lt;br&gt;            &lt;input type=submit value="登录" id="login"&gt;            &lt;div id="div_forgetpwd"&gt;                                &lt;a href="E:\MyProject\html\KServer\register\register.html" &gt;注册帐号&lt;/a&gt;                &lt;a href="E:\MyProject\html\KServer\forget_pwd\forget_pwd.html" &gt;忘记密码&lt;/a&gt;            &lt;/div&gt;                    &lt;/form&gt;    &lt;/div&gt;    &lt;script type="text/javascript"&gt;    //更改元素CSS属性    function set(){        var setImgDiv = document.getElementById("imgcenter");        setImgDiv.style.top = "150px";        setImgDiv.style.left = "36%";        var setTextDiv = document.getElementById("center");        setTextDiv.style.top = "280px";        setTextDiv.style.left = "8%";        var setLogo=document.getElementById("logo");        setLogo.style.height="100px";        setLogo.style.width="240px";        var setAccount=document.getElementById("account");        setAccount.style.height="15px";        setAccount.style.width="240px";        var setPwd=document.getElementById("pwd");        setPwd.style.height="15px";        setPwd.style.width="240px";        var setLogin=document.getElementById("login");        setLogin.style.height="25px";        setLogin.style.width="100px";        var setForgetPwd=document.getElementById("div_forgetpwd");        setForgetPwd.style.width="100px";        setForgetPwd.style.left="100%";    }    function reSet(){        var reSetImgDiv = document.getElementById("imgcenter");        reSetImgDiv.style.top = "250px";        reSetImgDiv.style.left = "20%";        var reSetTextDiv = document.getElementById("center");        reSetTextDiv.style.top = "220px";        reSetTextDiv.style.left = "20%";        var reSetLogo=document.getElementById("logo");        reSetLogo.style.height="auto";        reSetLogo.style.width="50%";        var reSetAccount=document.getElementById("account");        reSetAccount.style.height="auto";        reSetAccount.style.width="50%";        var reSetPwd=document.getElementById("pwd");        reSetPwd.style.height="auto";        reSetPwd.style.width="50%";        var reSetLogin=document.getElementById("login");        reSetLogin.style.height="auto";        reSetLogin.style.width="25%";        var reSetForgetPwd=document.getElementById("div_forgetpwd");        reSetForgetPwd.style.width="100px";        reSetForgetPwd.style.left="90%";    }    function setSizeMid(){        var setSizeMidImgDiv = document.getElementById("imgcenter");        setSizeMidImgDiv.style.top = "150px";        setSizeMidImgDiv.style.left = "22%";        var setSizeMidTextDiv = document.getElementById("center");        setSizeMidTextDiv.style.top = "280px";        setSizeMidTextDiv.style.left = "-35px";        var setSizeMidLogo=document.getElementById("logo");        setSizeMidLogo.style.height="100px";        setSizeMidLogo.style.width="240px";        var setSizeMidAccount=document.getElementById("account");        setSizeMidAccount.style.height="15px";        setSizeMidAccount.style.width="240px";        var setSizeMidPwd=document.getElementById("pwd");        setSizeMidPwd.style.height="15px";        setSizeMidPwd.style.width="240px";        var setSizeMidLogin=document.getElementById("login");        setSizeMidLogin.style.height="25px";        setSizeMidLogin.style.width="80px";        var setSizeMidForgetPwd=document.getElementById("div_forgetpwd");        setSizeMidForgetPwd.style.width="80px";        setSizeMidForgetPwd.style.left="110%";    }    function setSizeMini(){        var setSizeMiniImgDiv = document.getElementById("imgcenter");        setSizeMiniImgDiv.style.top = "150px";        setSizeMiniImgDiv.style.left = "6%";        var setSizeMiniTextDiv = document.getElementById("center");        setSizeMiniTextDiv.style.top = "280px";        setSizeMiniTextDiv.style.left = "-60px";        var setSizeMiniLogo=document.getElementById("logo");        setSizeMiniLogo.style.height="100px";        setSizeMiniLogo.style.width="240px";        var setSizeMiniAccount=document.getElementById("account");        setSizeMiniAccount.style.height="15px";        setSizeMiniAccount.style.width="240px";        var setSizeMiniPwd=document.getElementById("pwd");        setSizeMiniPwd.style.height="15px";        setSizeMiniPwd.style.width="240px";        var setSizeMiniLogin=document.getElementById("login");        setSizeMiniLogin.style.height="25px";        setSizeMiniLogin.style.width="80px";        var setSizeMiniForgetPwd=document.getElementById("div_forgetpwd");        setSizeMiniForgetPwd.style.width="80px";        setSizeMiniForgetPwd.style.left="125%";    }        //获取当前窗口尺寸     var winWidth = 0;     var winHeight = 0;     function findDimensions() //函数：获取尺寸     {        //获取窗口宽度        if (window.innerWidth)        winWidth = window.innerWidth;        else if ((document.body) &amp;&amp; (document.body.clientWidth))        winWidth = document.body.clientWidth;        //获取窗口高度        if (window.innerHeight)        winHeight = window.innerHeight;        else if ((document.body) &amp;&amp; (document.body.clientHeight))        winHeight = document.body.clientHeight;        //通过深入Document内部对body进行检测，获取窗口大小        if (document.documentElement  &amp;&amp; document.documentElement.clientHeight &amp;&amp; document.documentElement.clientWidth)        {        winHeight = document.documentElement.clientHeight;        winWidth = document.documentElement.clientWidth;    }    //结果输出至两个文本框    if(winWidth&lt;420||winHeight&lt;537)        setSizeMini();    else if(420&lt;=winWidth&amp;&amp;winWidth&lt;=595)        setSizeMid();    else if(595&lt;winWidth&amp;&amp;winWidth&lt;850||537&lt;winHeight&amp;&amp;winHeight&lt;590)        set();    else        reSet();    }         findDimensions();     //调用函数，获取数值     window.onresize=findDimensions; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        
          <category> web </category>
        
      </categories>
      <tags>
        
          <tag> js </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MD5 算法解析]]></title>
      <url>/blog/algorithm-md5-resolve/</url>
      <content type="text"><![CDATA[MD5的全称是Message-Digest Algorithm 5，在90年代初由MIT的计算机科学实验室和RSA Data Security Inc发明，经MD2、MD3和MD4发展而来。MD5将任意长度的“字节串”变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。MD5的典型应用是对一段Message(字节串)产生fingerprint(指纹)，以防止被“篡改”。举个例子，你将一段话写在一个叫 readme.txt文件中，并对这个readme.txt产生一个MD5的值并记录在案，然后你可以传播这个文件给别人，别人如果修改了文件中的任何内容，你对这个文件重新计算MD5时就会发现。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。MD5还广泛用于加密和解密技术上，在很多操作系统中，用户的密码是以MD5值（或类似的其它算法）的方式保存的， 用户Login的时候，系统是把用户输入的密码计算成MD5值，然后再去和系统中保存的MD5值进行比较，而系统并不“知道”用户的密码是什么。在一些初始化处理后，MD5以512位分组来处理输入文本，每一分组又划分为16个32位子分组。算法的输出由四个32位分组组成，将它们级联形成一个128位散列值。首先填充消息使其长度恰好为一个比512位的倍数仅小64位的数。填充方法是附一个1在消息后面，后接所要求的多个0，然后在其后附上64位的消息长度（填充前）。这两步的作用是使消息长度恰好是512位的整数倍（算法的其余部分要求如此），同时确保不同的消息在填充后不相同。四个32位变量初始化为：A=0×01234567 B=0×89abcdef C=0xfedcba98 D=0×76543210 它们称为链接变量（chaining variable）接着进行算法的主循环，循环的次数是消息中512位消息分组的数目。将上面四个变量复制到别外的变量中：A到a，B到b，C到c，D到d。主循环有四轮（MD4只有三轮），每轮很相拟。第一轮进行16次操作。每次操作对a，b，c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向右环移一个不定的数，并加上a，b，c或d中之一。最后用该结果取代a，b，c或d中之一。以下是每次操作中用到的四个非线性函数（每轮一个）。F(X,Y,Z)=(X&amp;Y)|((~X)&amp;Z) G(X,Y,Z)=(X&amp;Z)|(Y&amp;(~Z)) H(X,Y,Z)=X^Y^Z I(X,Y,Z)=Y^(X|(~Z)) (&amp;是与,|是或,~是非,^是异或) 这些函数是这样设计的：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。函数F是按逐位方式操作：如果X，那么Y，否则Z。函数H是逐位奇偶操作符。 设Mj表示消息的第j个子分组（从0到15），«&lt; s表示循环左移s位，则四种操作为：FF(a,b,c,d,Mj,s,ti)表示a=b+((a+(F(b,c,d)+Mj+ti)&lt;&lt;&lt; s) GG(a,b,c,d,Mj,s,ti)表示a=b+((a+(G(b,c,d)+Mj+ti)&lt;&lt;&lt; s) HH(a,b,c,d,Mj,s,ti)表示a=b+((a+(H(b,c,d)+Mj+ti)&lt;&lt;&lt; s) II(a,b,c,d,Mj,s,ti)表示a=b+((a+(I(b,c,d)+Mj+ti)&lt;&lt;&lt; s) 这四轮（64步）是：第一轮FF(a,b,c,d,M0,7,0xd76aa478) FF(d,a,b,c,M1,12,0xe8c7b756) FF(c,d,a,b,M2,17,0×242070db) FF(b,c,d,a,M3,22,0xc1bdceee) FF(a,b,c,d,M4,7,0xf57c0faf) FF(d,a,b,c,M5,12,0×4787c62a) FF(c,d,a,b,M6,17,0xa8304613) FF(b,c,d,a,M7,22,0xfd469501) FF(a,b,c,d,M8,7,0×698098d8) FF(d,a,b,c,M9,12,0×8b44f7af) FF(c,d,a,b,M10,17,0xffff5bb1) FF(b,c,d,a,M11,22,0×895cd7be) FF(a,b,c,d,M12,7,0×6b901122) FF(d,a,b,c,M13,12,0xfd987193) FF(c,d,a,b,M14,17,0xa679438e) FF(b,c,d,a,M15,22,0×49b40821)第二轮GG(a,b,c,d,M1,5,0xf61e2562) GG(d,a,b,c,M6,9,0xc040b340) GG(c,d,a,b,M11,14,0×265e5a51) GG(b,c,d,a,M0,20,0xe9b6c7aa) GG(a,b,c,d,M5,5,0xd62f105d) GG(d,a,b,c,M10,9,0×02441453) GG(c,d,a,b,M15,14,0xd8a1e681) GG(b,c,d,a,M4,20,0xe7d3fbc8) GG(a,b,c,d,M9,5,0×21e1cde6) GG(d,a,b,c,M14,9,0xc33707d6) GG(c,d,a,b,M3,14,0xf4d50d87) GG(b,c,d,a,M8,20,0×455a14ed) GG(a,b,c,d,M13,5,0xa9e3e905) GG(d,a,b,c,M2,9,0xfcefa3f8) GG(c,d,a,b,M7,14,0×676f02d9) GG(b,c,d,a,M12,20,0×8d2a4c8a)第三轮HH(a,b,c,d,M5,4,0xfffa3942) HH(d,a,b,c,M8,11,0×8771f681) HH(c,d,a,b,M11,16,0×6d9d6122) HH(b,c,d,a,M14,23,0xfde5380c) HH(a,b,c,d,M1,4,0xa4beea44) HH(d,a,b,c,M4,11,0×4bdecfa9) HH(c,d,a,b,M7,16,0xf6bb4b60) HH(b,c,d,a,M10,23,0xbebfbc70) HH(a,b,c,d,M13,4,0×289b7ec6) HH(d,a,b,c,M0,11,0xeaa127fa) HH(c,d,a,b,M3,16,0xd4ef3085) HH(b,c,d,a,M6,23,0×04881d05) HH(a,b,c,d,M9,4,0xd9d4d039) HH(d,a,b,c,M12,11,0xe6db99e5) HH(c,d,a,b,M15,16,0×1fa27cf8) HH(b,c,d,a,M2,23,0xc4ac5665) 第四轮II(a,b,c,d,M0,6,0xf4292244) II(d,a,b,c,M7,10,0×432aff97) II(c,d,a,b,M14,15,0xab9423a7) II(b,c,d,a,M5,21,0xfc93a039) II(a,b,c,d,M12,6,0×655b59c3) II(d,a,b,c,M3,10,0×8f0ccc92) II(c,d,a,b,M10,15,0xffeff47d) II(b,c,d,a,M1,21,0×85845dd1) II(a,b,c,d,M8,6,0×6fa87e4f) II(d,a,b,c,M15,10,0xfe2ce6e0) II(c,d,a,b,M6,15,0xa3014314) II(b,c,d,a,M13,21,0×4e0811a1) II(a,b,c,d,M4,6,0xf7537e82) II(d,a,b,c,M11,10,0xbd3af235) II(c,d,a,b,M2,15,0×2ad7d2bb) II(b,c,d,a,M9,21,0xeb86d391) 常数ti可以如下选择：在第i步中，ti是4294967296*abs(sin(i))的整数部分,i的单位是弧度。 (2的32次方)所有这些完成之后，将A，B，C，D分别加上a，b，c，d。然后用下一分组数据继续运行算法，最后的输出是A，B，C和D的级联。 　　MD5的安全性MD5相对MD4所作的改进：  增加了第四轮。  每一步均有唯一的加法常数。                              为减弱第二轮中函数G的对称性从(X&amp;Y)          (X&amp;Z)          (Y&amp;Z)变为(X&amp;Z)          (Y&amp;(~Z))                      第一步加上了上一步的结果，这将引起更快的雪崩效应。  改变了第二轮和第三轮中访问消息子分组的次序，使其更不相似。  近似优化了每一轮中的循环左移位移量以实现更快的雪崩效应。各轮的位移量互不相同。MD5源码:md5.h/*                  md5.h            */#ifndef _MD5_H_#define _MD5_H_#define R_memset(x, y, z) memset(x, y, z)#define R_memcpy(x, y, z) memcpy(x, y, z)#define R_memcmp(x, y, z) memcmp(x, y, z)typedef unsigned long UINT4;typedef unsigned char *POINTER;/* MD5 context. */typedef struct {   /* state (ABCD) */     /*四个32bits数，用于存放最终计算得到的消息摘要。当消息长度〉512bits时，也用于存放每个512bits的中间结果*/   UINT4 state[4];     /* number of bits, modulo 2^64 (lsb first) */      /*存储原始信息的bits数长度,不包括填充的bits，最长为 2^64 bits，因为2^64是一个64位数的最大值*/   UINT4 count[2];      /* input buffer */   /*存放输入的信息的缓冲区，512bits*/   unsigned char buffer[64]; } MD5_CTX;void MD5Init(MD5_CTX *);void MD5Update(MD5_CTX *, unsigned char *, unsigned int);void MD5Final(unsigned char [16], MD5_CTX *);#endif /* _MD5_H_ */md5.cpp/*     md5.cpp    */#include "stdafx.h"/* Constants for MD5Transform routine. *//*md5转换用到的常量，算法本身规定的*/#define S11 7#define S12 12#define S13 17#define S14 22#define S21 5#define S22 9#define S23 14#define S24 20#define S31 4#define S32 11#define S33 16#define S34 23#define S41 6#define S42 10#define S43 15#define S44 21static void MD5Transform(UINT4 [4], unsigned char [64]);static void Encode(unsigned char *, UINT4 *, unsigned int);static void Decode(UINT4 *, unsigned char *, unsigned int);/*用于bits填充的缓冲区，为什么要64个字节呢？因为当欲加密的信息的bits数被512除其余数为448时，需要填充的bits的最大值为512=64*8 。*/static unsigned char PADDING[64] = {   0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};/*接下来的这几个宏定义是md5算法规定的，就是对信息进行md5加密都要做的运算。据说有经验的高手跟踪程序时根据这几个特殊的操作就可以断定是不是用的md5*//* F, G, H and I are basic MD5 functions.*/#define F(x, y, z) (((x) &amp; (y)) | ((~x) &amp; (z)))#define G(x, y, z) (((x) &amp; (z)) | ((y) &amp; (~z)))#define H(x, y, z) ((x) ^ (y) ^ (z))#define I(x, y, z) ((y) ^ ((x) | (~z)))/* ROTATE_LEFT rotates x left n bits.*/#define ROTATE_LEFT(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.   Rotation is separate from addition to prevent recomputation.*/#define FF(a, b, c, d, x, s, ac) { \   (a) += F ((b), (c), (d)) + (x) + (UINT4)(ac); \   (a) = ROTATE_LEFT ((a), (s)); \   (a) += (b); \}#define GG(a, b, c, d, x, s, ac) { \   (a) += G ((b), (c), (d)) + (x) + (UINT4)(ac); \   (a) = ROTATE_LEFT ((a), (s)); \   (a) += (b); \}#define HH(a, b, c, d, x, s, ac) { \   (a) += H ((b), (c), (d)) + (x) + (UINT4)(ac); \   (a) = ROTATE_LEFT ((a), (s)); \   (a) += (b); \}#define II(a, b, c, d, x, s, ac) { \   (a) += I ((b), (c), (d)) + (x) + (UINT4)(ac); \   (a) = ROTATE_LEFT ((a), (s)); \   (a) += (b); \}/* MD5 initialization. Begins an MD5 operation, writing a new context. *//*初始化md5的结构*/void MD5Init (MD5_CTX *context){   /*将当前的有效信息的长度设成0,这个很简单,还没有有效信息,长度当然是0了*/   context-&gt;count[0] = context-&gt;count[1] = 0;   /* Load magic initialization constants.*/   /*初始化链接变量，算法要求这样，这个没法解释了*/   context-&gt;state[0] = 0x67452301;   context-&gt;state[1] = 0xefcdab89;   context-&gt;state[2] = 0x98badcfe;   context-&gt;state[3] = 0x10325476;}/* MD5 block update operation. Continues an MD5 message-digest   operation, processing another message block, and updating the   context. *//*将与加密的信息传递给md5结构，可以多次调用context：初始化过了的md5结构input：欲加密的信息，可以任意长inputLen：指定input的长度*/void MD5Update(MD5_CTX *context,unsigned char * input,unsigned int   inputLen){unsigned int i, index, partLen;/* Compute number of bytes mod 64 *//*计算已有信息的bits长度的字节数的模64, 64bytes=512bits。用于判断已有信息加上当前传过来的信息的总长度能不能达到512bits，如果能够达到则对凑够的512bits进行一次处理*/index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3F);/* Update number of bits *//*更新已有信息的bits长度*/if((context-&gt;count[0] += ((UINT4)inputLen &lt;&lt; 3)) &lt; ((UINT4)inputLen &lt;&lt; 3))   context-&gt;count[1]++;context-&gt;count[1] += ((UINT4)inputLen &gt;&gt; 29);/*计算已有的字节数长度还差多少字节可以 凑成64的整倍数*/partLen = 64 - index;/* Transform as many times as possible.   *//*如果当前输入的字节数 大于 已有字节数长度补足64字节整倍数所差的字节数*/if(inputLen &gt;= partLen)     {   /*用当前输入的内容把context-&gt;buffer的内容补足512bits*/   R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)input, partLen);   /*用基本函数对填充满的512bits（已经保存到context-&gt;buffer中） 做一次转换，转换结果保存到context-&gt;state中*/   MD5Transform(context-&gt;state, context-&gt;buffer);/*对当前输入的剩余字节做转换（如果剩余的字节&lt;在输入的input缓冲区中&gt;大于512bits的话 ），转换结果保存到context-&gt;state中*/   for(i = partLen; i + 63 &lt; inputLen; i += 64)/*把i+63&lt;inputlen改为i+64&lt;=inputlen更容易理解*/    MD5Transform(context-&gt;state, &amp;input[i]);         index = 0;     }     else   i = 0;/* Buffer remaining input *//*将输入缓冲区中的不足填充满512bits的剩余内容填充到context-&gt;buffer中，留待以后再作处理*/R_memcpy((POINTER)&amp;context-&gt;buffer[index], (POINTER)&amp;input[i], inputLen-i);}/* MD5 finalization. Ends an MD5 message-digest operation, writing the   the message digest and zeroizing the context. *//*获取加密 的最终结果digest：保存最终的加密串context：你前面初始化并填入了信息的md5结构*/void MD5Final (unsigned char digest[16],MD5_CTX *context){unsigned char bits[8];unsigned int index, padLen;/* Save number of bits *//*将要被转换的信息(所有的)的bits长度拷贝到bits中*/Encode(bits, context-&gt;count, 8);/* Pad out to 56 mod 64. *//* 计算所有的bits长度的字节数的模64, 64bytes=512bits*/index = (unsigned int)((context-&gt;count[0] &gt;&gt; 3) &amp; 0x3f);/*计算需要填充的字节数，padLen的取值范围在1-64之间*/padLen = (index &lt; 56) ? (56 - index) : (120 - index);/*这一次函数调用绝对不会再导致MD5Transform的被调用，因为这一次不会填满512bits*/MD5Update(context, PADDING, padLen);/* Append length (before padding) *//*补上原始信息的bits长度（bits长度固定的用64bits表示），这一次能够恰巧凑够512bits，不会多也不会少*/MD5Update(context, bits, 8);/* Store state in digest *//*将最终的结果保存到digest中。ok，终于大功告成了*/Encode(digest, context-&gt;state, 16);/* Zeroize sensitive information. */R_memset((POINTER)context, 0, sizeof(*context));}/* MD5 basic transformation. Transforms state based on block. *//*对512bits信息(即block缓冲区)进行一次处理，每次处理包括四轮state[4]：md5结构中的state[4]，用于保存对512bits信息加密的中间结果或者最终结果block[64]：欲加密的512bits信息*/static void MD5Transform (UINT4 state[4], unsigned char block[64]){UINT4 a = state[0], b = state[1], c = state[2], d = state[3], x[16];Decode(x, block, 64);/* Round 1 */FF(a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */FF(d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */FF(c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */FF(b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */FF(a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */FF(d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */FF(c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */FF(b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */FF(a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */FF(d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */FF(c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */FF(b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */FF(a, b, c, d, x[12], S11, 0x6b901122); /* 13 */FF(d, a, b, c, x[13], S12, 0xfd987193); /* 14 */FF(c, d, a, b, x[14], S13, 0xa679438e); /* 15 */FF(b, c, d, a, x[15], S14, 0x49b40821); /* 16 *//* Round 2 */GG(a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */GG(d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */GG(c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */GG(b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */GG(a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */GG(d, a, b, c, x[10], S22,   0x2441453); /* 22 */GG(c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */GG(b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */GG(a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */GG(d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */GG(c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */GG(b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */GG(a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */GG(d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */GG(c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */GG(b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 *//* Round 3 */HH(a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */HH(d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */HH(c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */HH(b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */HH(a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */HH(d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */HH(c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */HH(b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */HH(a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */HH(d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */HH(c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */HH(b, c, d, a, x[ 6], S34,   0x4881d05); /* 44 */HH(a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */HH(d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */HH(c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */HH(b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 *//* Round 4 */II(a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */II(d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */II(c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */II(b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */II(a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */II(d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */II(c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */II(b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */II(a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */II(d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */II(c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */II(b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */II(a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */II(d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */II(c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */II(b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */state[0] += a;state[1] += b;state[2] += c;state[3] += d;/* Zeroize sensitive information. */R_memset((POINTER)x, 0, sizeof(x));}/* Encodes input (UINT4) into output (unsigned char). Assumes len is   a multiple of 4. *//*将4字节的整数copy到字符形式的缓冲区中output：用于输出的字符缓冲区input：欲转换的四字节的整数形式的数组len：output缓冲区的长度，要求是4的整数倍*/static void Encode(unsigned char *output, UINT4 *input,unsigned int   len){unsigned int i, j;for(i = 0, j = 0; j &lt; len; i++, j += 4) {   output[j] = (unsigned char)(input[i] &amp; 0xff);   output[j+1] = (unsigned char)((input[i] &gt;&gt; 8) &amp; 0xff);   output[j+2] = (unsigned char)((input[i] &gt;&gt; 16) &amp; 0xff);   output[j+3] = (unsigned char)((input[i] &gt;&gt; 24) &amp; 0xff);}}/* Decodes input (unsigned char) into output (UINT4). Assumes len is   a multiple of 4. *//*与上面的函数正好相反，这一个把字符形式的缓冲区中的数据copy到4字节的整数中（即以整数形式保存）output：保存转换出的整数input：欲转换的字符缓冲区len：输入的字符缓冲区的长度，要求是4的整数倍*/static void Decode(UINT4 *output, unsigned char *input,unsigned int   len){unsigned int i, j;for(i = 0, j = 0; j &lt; len; i++, j += 4)   output[i] = ((UINT4)input[j]) | (((UINT4)input[j+1]) &lt;&lt; 8) |    (((UINT4)input[j+2]) &lt;&lt; 16) | (((UINT4)input[j+3]) &lt;&lt; 24);}md5test.cpp// md5test.cpp : Defines the entry point for the console application.//#include "stdafx.h"#include "string.h"int main(int argc, char* argv[]){	MD5_CTX md5;	MD5Init(&amp;md5);                          //初始化用于md5加密的结构 	unsigned char encrypt[200];      //存放于加密的信息	unsigned char decrypt[17];        //存放加密后的结果	scanf("%s",encrypt);                  //输入加密的字符 	MD5Update(&amp;md5,encrypt,strlen((char *)encrypt));    //对欲加密的字符进行加密	MD5Final(decrypt,&amp;md5);                                             	//获得最终结果 	printf("加密前:%s\n加密后:",encrypt);	for(int i=0;i&lt;16;i++)   		printf("%2x ",decrypt[i]); 	printf("\n\n\n加密结束!\n"); 	return 0;}写在最后欢迎大家加入算法交流Q群交流讨论，Q群号：855454453]]></content>
      <categories>
        
          <category> algorithm </category>
        
      </categories>
      <tags>
        
          <tag> c </tag>
        
          <tag> md5 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[地图定位异常问题]]></title>
      <url>/blog/location-map-debug-error/</url>
      <content type="text"><![CDATA[地图定位是做LBS服务的App通常用到的模块。但是，随着iOS系统的升级，地图定位模块出现了不一样的异常，这里将遇到的并解决的问题分享出来。一、CLLocationManagerDelegate不调用didUpdateLocations这是因为xcode升级造成的定位权限设置问题。升级xcode6以后打开以前xcode5工程，程序不能定位。工程升级到xcode6编译时需要iOS8 要自己写授权，不然没权限定位。解决方法：首先在 info.plist里加入对应的缺省字段，值设置为YES（前台定位写上边字段，前后台定位写下边字段）NSLocationWhenInUseUsageDescription  //允许在前台获取GPS的描述NSLocationAlwaysUsageDescription  //允许在前、后台获取GPS的描述代码：#import "ViewController.h"#import &lt;CoreLocation/CoreLocation.h&gt;@interface ViewController ()&lt;CLLocationManagerDelegate&gt;@property (nonatomic, strong)CLLocationManager *locationManager;@end@implementation ViewController //    1. 懒加载初始化：- (CLLocationManager *)locationManager{    if(!_locationManager){        self.locationManager= [[CLLocationManager alloc] init];        self.locationManager.delegate= self;    }    return_locationManager;}- (void)viewDidLoad {    [superviewDidLoad];//    2. 调用请求：    if ([[[UIDevicecurrentDevice] systemVersion] doubleValue] &gt; 8.0){        //设置定位权限 仅ios8有意义        [self.locationManagerrequestWhenInUseAuthorization];// 前台定位                //[self.locationManagerrequestAlwaysAuthorization];// 前后台同时定位    }    [self.locationManagerstartUpdatingLocation];} // 3.代理方法- (void)locationManager:(CLLocationManager*)manager didUpdateLocations:(NSArray *)locations{    NSLog(@"%ld",locations.count);}@end二、ErrorDomain=kCLErrorDomain Code=0 “The operation couldn’t be completed.环境：XCODE6.0.1 + iPhone / iOS8错误：使用CoreLocation获取地理位置信息，报错Error Domain=kCLErrorDomain Code=0"The operation couldn’t be completed. (kCLErrorDomain error 0.)"解决方法：1.确定模拟器（手机）已经联网并且允许程序获取地理位置2.重置地理位置服务或者网络服务PS：如果是模拟器就果断直接重置模拟器重置模拟器方法：iOS Simulator -&gt; Reset Content andSettings…]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> debug </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Objective-C 继承和多态]]></title>
      <url>/blog/objc-inherit-multimodal/</url>
      <content type="text"><![CDATA[学习Java我们知道类有三大特征，封装，继承，多态。而在Objective-C中也有继承的概念，今天就来看看Objective-C中的继承和多态。首先,我们来看看示例代码://Animal.h#import &lt;Foundation/Foundation.h&gt;  @interface Animal : NSObject{    int food_consumption; //食量    int count; //数量    int parturition_days; //生产周期} -(int)count; -(void)setCount:(int)c; -(int)foodConsumption; -(void)setFoodConsumption:(int)food_c; -(int)parturitionDays; -(void)setParturitionDays:(int)parturition_day; @end//Animal.m#import "Animal.h" @implementation Animal -(int)count{    return count;} -(void)setCount:(int)c{    count = c;} -(int)foodConsumption{    return food_consumption;} -(void)setFoodConsumption:(int)food_c{    food_consumption = food_c;} -(int)parturitionDays{    return parturition_days;} -(void)setParturitionDays:(int)parturition_day{    parturition_days = parturition_day;}  @end//Panda.h#import "Animal.h"  @interface Panda : Animal @end//Panda.m#import "Panda.h" @implementation Panda @end//Tool.h#import &lt;Foundation/Foundation.h&gt;#import "Animal.h"#import "Panda.h" @interface Tool : NSObject +(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict; @end//Tool.m#import "Tool.h" @implementation Tool +(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict{    NSDictionary *animalDict;    if(YES == [animal isKindOfClass:[Panda class]]){        animalDict = [dict objectForKey:@"Panda"];             }else{        NSLog(@"error class!");    }    [animal setCount:[[animalDict objectForKey:@"count"] intValue]];    [animal setFoodConsumption:[[animalDict objectForKey:@"food_consumption"] intValue]];    [animal setParturitionDays:[[animalDict objectForKey:@"parturition_days"] intValue]];} @enddata.plist文件&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt;    &lt;key&gt;fodder&lt;/key&gt;    &lt;dict&gt;        &lt;key&gt;count_num&lt;/key&gt;        &lt;string&gt;1024&lt;/string&gt;    &lt;/dict&gt;    &lt;key&gt;Panda&lt;/key&gt;    &lt;dict&gt;        &lt;key&gt;food_consumption&lt;/key&gt;        &lt;string&gt;2&lt;/string&gt;        &lt;key&gt;count&lt;/key&gt;        &lt;string&gt;6&lt;/string&gt;        &lt;key&gt;parturition_days&lt;/key&gt;        &lt;string&gt;76&lt;/string&gt;    &lt;/dict&gt;&lt;/dict&gt;&lt;/plist&gt;//main.m#import &lt;Foundation/Foundation.h&gt;#import "Tool.h" int main(int argc, const char * argv[]) {    @autoreleasepool {        // insert code here...        Panda *panda = [[Panda alloc] init];             //读取plist        NSString *plistPath = [[NSBundle mainBundle] pathForResource:@"data" ofType:@"plist"];        NSMutableDictionary *data = [[NSMutableDictionary alloc] initWithContentsOfFile:plistPath];             [Tool initWithAnimalDictionary:panda andDict:data];             int fooder_num = 0;        int surplus = 0;        int day = 1;             NSDictionary *fooderDict = [data objectForKey:@"fodder"];        fooder_num = [[fooderDict objectForKey:@"count_num"] intValue];        surplus = fooder_num;             while(surplus &gt; 0){            if(0 == (day % [panda parturitionDays])){                [panda setCount:([panda count] + 1)];            }            surplus = fooder_num - ([panda count] * [panda foodConsumption]);            fooder_num = surplus;                     if(surplus){                NSLog(@"第 %d 天，熊猫:%d 只，饲料余量:%d 。\n", day, [panda count],  surplus);            }            day++;        }    }    return 0;}继承　　继承是类中的一个重要的特性，它的出现使得我们没必要别写重复的代码，可重用性很高。当然Objective-C中的继承和Java中是一样的，没多大区别。不仅仅Java，C++也有继承特性，但C++支持多继承，而Objective-C不支持多继承。概念:(1)超类(superclass)，是你所继承的类。例如，Panda的超类是Animal，Animal的超类是NSObject。(2)父类(parentclass)，是超类的另一种表达方式。例如，Animal是Panda的父类。(3)子类(subclass)，是实施继承的类。例如，Panda是Animal的子类。(4)孩子类(childclass)，是子类的另一种表达方式。例如，Panda是Animal的孩子类。继承的工作机制:(1)方法调度当代码发送消息时，Objective-C的方法调度程序将在当前类中搜索相应的方法。如果调度程序无法在接收消息的对象类中找到相应的方法，它就在该对象的超类中进行查找。(2)实例变量接下来我们看看Objective-C如何访问实例变量。创建一个新类时，其对象首先从自身的超类中继承实例变量，然后(可选)添加它们自己的实例变量。最后，说说重写方法，制作自己全新的子类时，通常需要添加自己的方法。有时，为了在类中引入某个独特的特性，需要添加新方法。还有些时候，可能需要替换或增强由这个新类的某个超类所定义的现有方法。当遇到我们子类特有的方法时，则只需要在子类中重写该方法即可。多态在Objective-C中，多态就是指，父类指针可以指向子类。+(void) initWithAnimalDictionary:(Animal *)animal andDict:(NSDictionary *)dict;上例代码中的从字典中获取数据的类方法就很好地使用了多态。该方法主要是从字典中读取数据，示例中只有Panda一个子类，若是以后拥有更多的类，那么该功能的方法需要为每一个子类写一个方法，而使用多态特性，则只需根据传入的参数进行分别处理即可，减少代码冗余问题。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> ios </tag>
        
          <tag> objc </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[NSString 字符串使用（基础篇）]]></title>
      <url>/blog/nsstring-using/</url>
      <content type="text"><![CDATA[iOS字符串主要分为两大类：NSString和NSMutableString。即不可变和可变字符串。在很多时候两者使用差异不大。文章分享字符串使用方法。一、不可变字符NSString是不可变字符串，它产生的其他字符串方法都是生成一个新的字符串，而不会改变原来字符串。1.创建方式1）字面量，它是常量字符串，存储常量区NSString *str=@"hello";2）通过快捷构造法，存储堆区NSString *str = [NSString stringWithFormat:@"hello %@", @"world"];3）初始化方法NSString *str = [[NSString alloc] initWithFormat:@"%@",@"hello"];2.字符串的获取1）获取字符串长度NSString *str=@"hello";long length = str.length;2）获取子串NSString *str=@"hello";/*从索引字符串开始截取，直到字符串末尾，包含索引上的字符*/NSString *strSub = [str substringFormIndex:2];/*从字符串开头开始截取，直到索引位置，不包含索引上的字符*/NSString *strSubT = [str substringToIndex:2];/*从哪个位置开始，截取多长*/NSRange range = {2,4};NSString *strSubR = [str substringWithRange:range];/*获取某个子串所在的区域*/NSRange rangeS = [str rangeOfString"@"el"];/*单词首字母转大写*/[str capitalizedString];/*字符替换*/NSString *newStr = [str stringByReplacingOccurencesOfString:@"ll" withString:@"al"];/*使用某个字符串替换掉原来字符串中某个区间的字符串*/NSRange range = [str rangeOfString:@"ll"];NSString *newStr = [str stringByReplacingCharactersInRange:range withSring:@"hi"];/*删除原字符串中的所有指定字符串*/NSString *newStr = [str stringByReplacingOccurencesOfString:@"ll" withString:@""];/*去掉两头空格*/NSString *newStr = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];/*在原来路径上拼接一个路径*/NSString *path = @"/Users/dengwei";path = [path stringByAppendingPathComponent:@"Desktop"];/*获取扩展名*/NSString *path = @"/Users/dengwei/Desktop/apple.txt";path = [path stringByDeletingPathExtension];path = [path stringByAppendingPathExtension:@"png"];/*把字符串写入文件*/NSString *str = @"today is cold!";NSString *path = @"/Users/dengwei/Desktop/apple.txt";NSError *error;BOOL isSuccess = [str writeToFile:path atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];/*读取文件*/NSString *string = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:&amp;error];/*字符串与URL*//*URL：Uniform Resource Locator 统一资源定位符URL：格式  协议头://主机名称/资源路径http://www.baidu.com/some/images/pic.png404：没有找到资源*/NSString *str = @"today is cold!";/*url路径中不支持中文，若是有中文则需将中文转码*/NSURL *url =  [NSURL URLWithString:@"file:///Users/dengwei/Desktop/apple.txt"];/*将中文转码*/NSString *url_cn =  @"file:///Users/dengwei/Desktop/中文.txt";/*编码，把UTF8编码的字符串编码成URL中可用的字符串*/url_cn = [url_cn stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];/*解码，把URL中可用的字符串编码的字符串解码成UTF8编码的字符串*/url_cn = [url_cn stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding];url_cn = [NSURL URLWithString:url_cn];NSError *error;/*写入*/BOOL isSuccess = [str writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];/*读取*/NSString *string = [str stringWithContentsOfURL:url atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];3.字符串范围获取/*计算文本大小*/CGSize maxSize = CGSizeMake(MAXFLOAT, MAXFLOAT);/*width与height都不限制*/CGSize nameSize = [self.microBlogModel.name boundingRectWithSize:maxSize options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:[UIFont systemFontOfSize:15]} context:nil].size;二、可变字符NSMutableString，可变字符，是NSString的子类。一个字符串需要经常修改其中的内容，则使用NSMutableString。NSMutableString *strM = [NSMutableString string];/*Capacity表示容量，可以容纳多少字符，如果超过这个存储空间，就会扩展它*/NSMutableString *strM = [NSMutableString stringWithCapacity:10];]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> objc </tag>
        
          <tag> ios </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[VC 调用 DLL]]></title>
      <url>/blog/vc-invoke-dll/</url>
      <content type="text"><![CDATA[DLL 动态数据链路库。调用DLL有两种方法：静态调用和动态调用.(一).静态调用其步骤如下:      1.把你的youApp.DLL拷到你目标工程(需调用youApp.DLL的工程)的Debug目录下;        2.把你的youApp.lib拷到你目标工程(需调用youApp.DLL的工程)目录下;        3.把你的youApp.h(包含输出函数的定义)拷到你目标工程(需调用youApp.DLL的工程)目录下;        4.打开你的目标工程选中工程,选择Visual C++的Project主菜单的Settings菜单;        5.执行第4步后，VC将会弹出一个对话框，在对话框的多页显示控件中选择Link页。然后在Object/library modules输入框中输入:youApp.lib        6.选择你的目标工程Head Files加入：youApp.h文件;        7.最后在你目标工程(*.cpp,需要调用DLL中的函数)中包含你的:#include “youApp.h”  注：youApp是你DLL的工程名。(二).动态调用其程序如下:动态调用时只需做静态调用{	HINSTANCE hDllInst = LoadLibrary("youApp.DLL");	if(hDllInst)	{		typedef DWORD (WINAPI *MYFUNC)(DWORD,DWORD);		MYFUNC youFuntionNameAlias = NULL; // youFuntionNameAlias 函数别名		youFuntionNameAlias = (MYFUNC)GetProcAddress(hDllInst,"youFuntionName");		// youFuntionName 在DLL中声明的函数名		if(youFuntionNameAlias)			{				youFuntionNameAlias(param1,param2);		}		FreeLibrary(hDllInst);	}}  显式（静态）调用：LIB + DLL + .H，注意.H中dllexport改为dllimport  隐式（动态）调用：DLL + 函数原型声明，先LoadLibrary，再GetProcAddress（即找到DLL中函数的地址），不用后FreeLibrary]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Factory模式与Prototype模式的异同]]></title>
      <url>/blog/factory-prototype-diff/</url>
      <content type="text"><![CDATA[设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。原型模式与工厂模式的定义，本文不想在这讲太多，本文主要想在这讲一下对原型模式的一些误解－－将原型模式等价于工厂模式。为什么会产生这种误导呢？其实也不是我们的错，关键在于设计模式这本书以及网上的其它资料很喜欢将原型和工厂方法进行比较，从而导致我们误解了原型引入的本质意义。按博主的理解，原型引入的根本原因就是在于它可以利用一个原型对象（指的是实例，而非类），快速地生成一批和原型对象一样的实例。举个例子来说，你有一个类A的实例a (A a=new A()),现在你想生成一个和a一样的实例b,那么，按照原型的定义，你应该可以这样做b=a.clone()。这样，你就可以得到一个和a一模一样的实例b(即a和部b的数据成员的值完全一样）。上面是原型的一个简单说明，那么引入原型有什么好处呢？按博主的理解，就是在于：你如果要生成一大批很相像的类的实例时，省得每次去做重复的赋值工作。再举个例子，如果你有一个类A,它有十个成员变量，现在你打算生成100个A的实例，而这些实例的变量值大部分相同（比如说七个相同），只有一小部分不一样（比如说三个），那么如果没有Prototype,那么你就得每次New一个A的对像，然后赋值，这样，你要重复100次同样的七个变量的赋值工作，显然，这样很麻烦。现在你有了原型，那么问题就简单了，你只要生成一个A的实例，再通过clone来生成其它的实例，然后再一一修改其它实例不同的地方。可能这么讲，大家不信，那下面，再让我们来看看Java中活生生的原型应用。学过Java的人都知道，在Java中,有一个clone()函数，这个函数的功能，就是返回一个和当前调用它的对象一样的实例。那么Java中为什么要引入这个函数呢？在【Think in Java】一书中，作者如是解释：“如果，你要将一个对象的引用作为参数传进去，但又不希望函数改变对象的值，那么，你该怎么办？由于在Java中对象没有像C++那样的Const修饰符，所以，为了实现这个功能，Java中引入了clone函数，使得你将对象的引用作为参数传进函数时，这个函数可以调用该对象的Clone方法生成该对象的一份拷贝，从而达到不修改原对象的目的。”之所以用上面这么多篇幅来讲述原型本质，目的就在于希望各位不要把原型的功能与它的意义给混了，以致于当真正要使用原型来解决问题时，却不知可以使用它。好了，上面说了原型的本质意义。那为什么很多资料喜欢将原型同工厂模式进行比较呢？不知是不是巧合，虽然原型引入的初衷是像上面所说，但它实现起来，却又完全可以达到工厂模式的效果。而且，用起来甚至比工厂模式更方便、灵活。对于工厂模式与原型模式在功能上的这点巧合，也许是因为本来工厂模式和原型模式都是创建型模式，这样，它们的基本功能都能生成对象，因而使得原型模式在功能上可以代替工厂模式。对这两种模式在功能上的相同点，程序员2001年第11期杂志上有一篇”非鱼“写的文章，作者理解得非常巧妙，即：如果你将工厂模式的UML图对折，你得到的就是Prototype原型的UML图。有兴趣比较这两种模式的朋友，可以去参考这篇文章。接下来，让我们在实现机制上来看看原型模式为什么可以实现工厂模式的功能(本文只限于Java语言）。在Java中，对于原型的实现，其实根本不用我们做，在object类中早就定义了一个clone函数，而这个函数，就使得我们可以动态地生成对象的当前拷贝。既然这样，那么让我们来看看，如果要实现工厂模式的功能，我们该如何使用原型模式为做到呢？工厂模式实现生产产品的功能，关键是利用了继承的特性。也就是说，你生成的产品，一定是由同一个抽象产品类派生出来的。所以，在工厂模式下，你如果要生成一类产品，就要引入一个抽像产品类，然后再由它派生出具体产品。同样，在原型模式中，你完全可以同样定义一个这样的“抽象产品－－具体产品”层次，再利用具体产品本身的clone功能来产生具体产品本身。从而达到实现工厂模式功能的目的。可能说到这，大家有点糊涂了。实际上，在原型模式中，每个具体产品就扮演了工厂模式里的具体工厂的角色（为什么会这样，其实很简单，因为，每个具体产品都具有生成自己拷贝的功能？从这种意义上讲，难道这不正是工厂的作用吗？）。另外，要在Java中利用原型模式实现工厂模式的功能，则更为简单，因为object已经为我们实现了clone函数，且对于clone方法，Java中默认是：如果A是父类且A实现了clone函数，B是A的子类，则B不用实现clone函数，它只要调用父类的clone函数，Java就会在运行时动态地为我们生成正确的B的对象。理解这点的关键在于，所有类实现的clone操作都是调用object的clone方法。这也就是说，上面所说的父类A根本就不用自己实现clone方法，而仅仅是调用父类（object)的clone方法而已。好，到了这，读者也许又有疑问了，既然所有的clone操作都是由object实现的，而在Java中所有的自定义类默认都是由object派生而来，那这样的话，应该所有的类都自动就具有了clone自己的能力？确实，如果object不将它的clone函数声明为protect的话，情况的确如此。但Java为了安全方面的原因，所以没有将clone方法公开，而是声明为保护类型，这样的话，子类是不可以直接调用object类的clone方法的，而必须做到如下两点：  1.必须实现Cloneable接口；  2.必须声明一个clone方法，来调用object的clone函数；Java在调用父类的clone函数时，都会在运行时动态地进行检查，如果发现调用的类不符合上面的任何一点，则会抛出一个异常。明白了上面的原因，那么如果我们希望某个类具备clone自身的能力，那么，我们可以这样做：  1.直接按上面所说，自己实现clone操作；  2.声明一个抽象父类，实现上面的clone操作并将它声明为公开方法，再由此类派生出子类，这样，所有的子类只要调用父类的clone方法，就能够正确地拷贝自己。通常，我们都是使用第一种方式，但在我们现在讨论的如何用原型模式实现工厂模式的功能的问题中，我们最好是采用第二种方式。最后，让我们通过具体的代码来看看如何用Prototype模式实现工厂模式的功能。问题：现有两类产品 1－Ram,2–Cpu,现在要生成具体的产品MacRam,MacCpu和WinRam,WinCpu.代码如下：/**A:Abstract*C:Concrete *//* 定义抽象产品Ram的类 APrototypeRam * 同时它也是抽象工厂*/abstract class APrototypeRam implements Cloneable {	public Object clone() {		Object o=null;		try {			o=super.clone();//调用父类，即Object的clone()		}		catch(CloneNotSupportedException e) {			System.err.println("APrototypeRam is not cloneable!");		}		return o;	}}/* 定义抽象产品Ram的类APrototypeProductCpu* 同时它也是抽象工厂*/abstract class APrototypeCpu implements Cloneable {	public Object clone() {		Object o=null;		try {			o=super.clone();//调用父类，即Object的clone()		}		catch(CloneNotSupportedException e) {			System.err.println("APrototypeCpu is not cloneable!");		}		return o;	}}/* 定义具体产品MacRam的类CPrototypeMacRam* 同时它也是具体工厂*/class CPrototypeMacRam extends APrototypeRam{	public String toString() {		return "MacRam";	}}/* 定义具体产品WinRam的类CPrototypeWinRam* 同时它也是具体工厂*/class CPrototypeWinRam extends APrototypeRam {	public String toString() {		return "WinRam";	}}/* 定义具体产品MacCpu的类CPrototypeMacCpu* 同时它也是具体工厂*/class CPrototypeMacCpu extends APrototypeCpu{	public String toString() {		return "MacCpu";	}}/* 定义具体产品WinCpu的类CPrototypeWinCpu* 同时它也是具体工厂*/class CPrototypeWinCpu extends APrototypeCpu{	public String toString() {		return "WinCpu";	}}/* 客户端，使用CPrototypeRam和CPrototypeCpu生成如下产品* MacRam,MacCpu,WinRam,WinCpu*/public class Prototype {	public static void main(String[] args) {	/*	* 在生成产品之前，先生成原型产品，以便后面利用它们成批生产相同产品	* 其作用等价于产品工厂	*/	CPrototypeMacRam prototypeMacRam=new CPrototypeMacRam();	CPrototypeWinRam prototypeWinRam=new CPrototypeWinRam();	CPrototypeMacCpu prototypeMacCpu=new CPrototypeMacCpu();	CPrototypeWinCpu prototypeWinCpu=new CPrototypeWinCpu();		CPrototypeMacRam MacRam=(CPrototypeMacRam)prototypeMacRam.clone();	CPrototypeWinRam WinRam=(CPrototypeWinRam)prototypeWinRam.clone();	CPrototypeMacCpu MacCpu=(CPrototypeMacCpu)prototypeMacCpu.clone();	CPrototypeWinCpu WinCpu=(CPrototypeWinCpu)prototypeWinCpu.clone();	System.out.println("打印原型产品与它的克隆产品与比较异同!");	System.out.println("prototypeMacRam:"+prototypeMacRam+" Cloned:"+MacRam);	System.out.println("prototypeWinRam:"+prototypeWinRam+" Cloned:"+WinRam);	System.out.println("prototypeMacCpu:"+prototypeMacCpu+" Cloned:"+MacCpu);	System.out.println("prototypeWinCpu:"+prototypeWinCpu+" Cloned:"+WinCpu);		}}通过上面代码，我们可以清楚地看到，用Prototype模式实现工厂模式更为简单，如果再配上原型管理器的话，那么Prototype模式则会变得更为灵活。但同时，我们也发现，使用原型模式时，有一个不足之处，即在客户端代码里，我们必须显式进行类型转换，这样可能导致错误。为了改正这一点，我们可以使用真正的工厂模式将Prototype模式再封装一遍。对工厂模式的这项功能，恐怕，Prototype原型模式就无能为力了。总之，工厂模式和原型模式虽然在引入目的上不同，但在实现上，原型模式可以实现工厂模式同样的功能。但读者也不要因为这样，而将两者混为一体，因为，反过来，在将原型模式作为生成本身拷贝的这项功能使用时，工厂模式根本无法取代它。]]></content>
      <categories>
        
          <category> pieces </category>
        
      </categories>
      <tags>
        
          <tag> 设计模式 </tag>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SQL Server 错误代码和解释 (下篇)]]></title>
      <url>/blog/sql-server-state-code-list-3/</url>
      <content type="text"><![CDATA[承接《中篇》继续罗列分享SQL Server状态码。            错误码      错误原因说明                  5001      因为其它资源需要它，不能将群集资源移到另一个组。              5002      找不到此群集资源的依存。              5003      因为已经处于依存状态，此群集资源不能依存于指定的资源。              5004      此群集资源未联机。              5005      此操作没有可用的群集节点。              5006      没有群集资源。              5007      找不到群集资源。              5008      正在关闭群集。              5009      因为联机，群集节点无法从群集中脱离。              5010      对象已存在。              5011      此对象已在列表中。              5012      新请求没有可用的群集组。              5013      找不到群集组。              5014      因为群集组未联机，此操作不能完成。              5015      群集节点不是此资源的所有者。              5016      群集节点不是此资源的所有者。              5017      群集资源不能在指定的资源监视器中创建。              5018      群集资源不能通过资源监视器来联机。              5019      因为群集资源联机，此操作不能完成。              5020      由于是仲裁资源，群集资源不能被删除或脱机。              5021      由于没有能力成为仲裁资源，此群集不能使指定资源成为仲裁资源。              5022      群集软件正关闭。              5023      组或资源的状态不是执行请求操作的正确状态。              5024      属性已被存储，但在下次资源联机前，不是所有的修改将生效。              5025      由于不属于共享存储类别，群集不能使指定资源成为仲裁资源。              5026      由于是内核资源，无法删除群集资源。              5027      仲裁资源联机失败。              5028      无法成功创建或装入仲裁日志。              5029      群集日志损坏。              5030      由于该日志已超出最大限量，无法将记录写入群集日志。              5031      群集日志已超出最大限量。              5032      群集日志没有发现检查点记录。              5033      不满足日志所需的最小磁盘空间。              5034      群集节点未能控制仲裁资源，因为它被另一个活动节点拥有。              5035      这个操作的群集网络无效。              5036      此操作没有可用的群集节点。              5037      所有群集节点都必须运行才能执行这个操作。              5038      群集资源失败。              5039      该群集节点无效。              5040      该群集节点已经存在。              5041      一个节点正在加入该群集。              5042      找不到群集节点。              5043      找不到群集本地节点信息。              5044      群集网络已经存在。              5045      找不到群集网络。              5046      群集网络界面已经存在。              5047      找不到群集网络界面。              5048      群集请求在这个对象中无效。              5049      群集网络提供程序无效。              5050      群集节点坏了。              5051      无法连接到群集节点。              5052      该群集节点不是群集的一个成员。              5053      群集加入操作正在进行中。              5054      该群集网络无效。              5055      Mar              5056      该群集节点可以使用。              5057      该群集 IP 地址已在使用中。              5058      该群集节点没有中止。              5059      没有有效的群集安全上下文。              5060      该群集网络不是为内部群集通讯配置的。              5061      群集节点已经开始。              5062      群集节点已经坏了。              5063      群集网络已经联机。              5064      群集网络已经脱机。              5065      群集节点已经是该群集的成员。              5066      该群集网络是唯一个为两个或更多活动群集节点进行内部群集通讯的配置。不能从网络上删除内部通讯能力。              5067      一个或更多的群集资源依靠网络来向客户提供服务。不能从网络上删除客户访问能力。              5068      该操作不能在群集资源上作为仲裁资源执行。您不能将仲裁资源脱机或修改它的所有者名单。              5069      该群集仲裁资源不允许有任何依存关系。              5070      该群集节点暂停。              5071      群集资源不能联机。所有者节点不能在这个资源上运行。              5072      群集节点没有准备好，不能执行所请求的操作。              5073      群集节点正在关闭。              5074      放弃群集节点加入操作。              5075      由于加入节点和支持者之间的软件版本不兼容，该群集加入操作失败。              5076      由于该群集已经到达其所能监督的资源限制，不能创建这个资源。              5077      系统配置在群集加入或形成操作时已更改。放弃加入或形成操作。              5078      找不到指定的资源种类。              5079      指定的节点不支持这种资源，这也许是由于版本不一致或是由于在这个节点上没有资源 DLL。              5080      该资源 DLL 不支持指定的资源名称。这可能是由于一个提供给源 DLL 名称是错误的(或经过更改的)。              5081      不能在 RPC 服务器上注册任何身份验证包。              5082      由于组的所有者不在组的首选列表中，不能将组联机。要改变组的所有者节点，请移动组。              5083      群集数据库的系列号已改变，或者与锁定程序节点不相容，因此加入操作没有成功。如果在加入操作期间群集数据库有任何改动，这都可能发生。              5084      资源在其当前状态下，资源监视器不允许执行失败操作。资源处于挂起状态时，这都可能发生。              5085      非锁定程序代码收到一个为全局更新保留锁定的请求。              5086      群集服务找不到仲裁磁盘。              5087      已备份的群集数据库可能已损坏。              5088      DFS 根目录已在这个群集节点中。              5089      由于与另一个现有属性冲突，未能修改资源属性。              5090      西班牙              5091      丹麦              5092      瑞典              5093      挪威              5094      德国              5095      澳大利亚              5096      日本              5097      韩国              5098      中国              5099      台湾              5100      亚洲              5101      葡萄牙              5102      芬兰              5103      阿拉伯              5104      希伯莱              5153      UPS 服务即将执行最后的关机操作。              5170      工作站必须用 NET START 才能启动。              5175      远程 IPC              5176      远程管理              5177      默认共享              5291      永不              5292      永不              5293      永不              5295      NETUS.HLP              5296      NET.HLP              5300      网络控制块 (NCB) 请求运行成功。 NCB 是相关数据。              5301      SEND DATAGRAM、SEND BROADCAST、ADAPTER STATUS 或 SESSION STATUS 的网络控制块 (NCB) 缓冲区长度无效。 NCB 是相关数据。              5302      网络控制块 (NCB) 指定的数据描述数组无效。 NCB 是相关数据。              5303      网络控制块 (NCB) 指定的命令无效。 NCB 是相关数据。              5304      网络控制块 (NCB) 指定的消息交换码无效。 NCB 是相关数据。              5305      网络控制块 (NCB) 命令超时。会话可能异常终止。 NCB 是相关数据。              5306      接收的网络控制块 (NCB) 消息不完整。 NCB 是相关数据。              5307      网络控制块 (NCB) 指定的缓冲区无效。 NCB 是相关数据。              5308      网络控制块 (NCB) 指定的会话号码没有作用。 NCB 是相关数据。              5309      网卡没有任何资源可用。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5310      网络控制块 (NCB) 指定的会话已经关闭。 NCB 是相关数据。              5311      网络控制块 (NCB) 命令已经取消。 NCB 是相关数据。              5312      网络控制块 (NCB) 指定的消息块不合逻辑。 NCB 是相关数据。              5313      该名称已经存在于本地适配器名称表中。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5314      网卡名称表已满。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5315      网络名称已经有活动的会话，现在取消注册。 网络控制块 (NCB) 命令运行完毕。NCB 是相关数据。              5316      先前发出的 Receive Lookahead 命令对此会话仍起作用。 网络控制块 (NCB) 命令被拒绝。 NCB 是相关数据。              5317      本地会话表已满。网络控制块 (NCB) 请求被拒绝。 NCB 是相关数据。              5318      拒绝打开网络控制块 (NCB) 会话，远程计算机上没有侦听命令在执行。 NCB 是相关数据。              5319      网络控制块 (NCB) 指定的名称号码无效。 NCB 是相关数据。              5320      网络控制块 (NCB) 中指定的调用名称找不到， 或者没有应答。NCB 是相关数据。              5321      网络控制块 (NCB) 中指定的名称找不到。无法将“*”或 00h 填入 NCB 名称。NCB 是相关数据。              5322      网络控制块 (NCB) 中指定的名称正用于远程适配器。 NCB 是相关数据。              5323      网络控制块 (NCB) 中指定的名称已经删除。 NCB 是相关数据。              5324      网络控制块 (NCB) 中指定的会话异常终止。 NCB 是相关数据。              5325      网络协议在网络上检测两个或数个 相同的名称。 网络控制块 (NCB) 是相关数据。              5326      收到意外的协议数据包。 远程设备可能不兼容。网络控制块 (NCB) 是相关数据。              5333      NetBIOS 界面正忙。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5334      未完成的网络控制块 (NCB) 命令太多。 NCB 请求被拒绝。NCB 是相关数据。              5335      网络控制块 (NCB) 中指定的适配器号无效。 NCB 是相关数据。              5336      网络控制块 (NCB) 命令在取消的同时运行完毕。 NCB 是相关数据。              5337      网络控制块 (NCB) 指定的名称已经保留。 NCB 是相关数据。              5338      网络控制块 (NCB) 命令无法取消。 NCB 是相关数据。              5351      同一个会话有多个网络控制块 (NCB)。 NCB 请求被拒绝。NCB 是相关数据。              5352      网卡出错。 唯一可能发出的 NetBIOS 命令是 NCB RESET。 网络控制块 (NCB) 是相关数据。              5354      超过应用程序数目上限。 网络控制区 (NCB) 请求被拒绝，NCB 是相关数据。              5356      请求的资源无法使用。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5364      系统出错。 网络控制块 (NCB) 请求被拒绝。NCB 即为数据。              5365      “ROM 校验和”失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5366      RAM 测试失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5367      数字式环回失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5368      模拟式环回失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5369      界面失败。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5370      收到的网络控制块 (NCB) 返回码无法识别。 NCB 是相关数据。              5380      网卡故障。 网络控制块 (NCB) 请求被拒绝。NCB 是相关数据。              5381      网络控制块 (NCB) 命令仍然处于搁置状态。 NCB 是相关数据。              5509      Windows 2000 无法按指定的配置启动， 将换用先前可工作的配置。              5600      无法共享用户或脚本路径。              5601      计算机的密码在本地安全 数据库中找不到。              5602      访问计算机的本地或网络安全数据库时， 发生内部错误。              5705      Netlogon 服务用于记录数据库更改数据的 日志高速缓存已损坏。 Netlogon 服务正在复位更改日志文件。              5728      无法加载任何传输。              5739      此域的全局组数目超过可以复制到 LanMan BDC 的限制。 请删除部分的全局组或删除域中的 LanMan BDC。              5742      服务无法检索必要的消息，所以无法运行远程启动客户。              5743      服务发生严重的错误，无法从远程启动 3Com 3Start 远程启动客户。              5744      服务发生严重的系统错误，即将关机。              5760      服务在分析 RPL 配置时出错。              5761      服务在创建所有配置的 RPL 配置文件时出错。              5762      服务在访问注册表时出错。              5763      服务在替换可能过期的 RPLDISK.SYS 时出错。              5764      服务在添加安全帐户或设置文件权限时出错。 这些帐户是独立 RPL 工作站的 RPLUSER 本地组 以及用户帐户。.              5765      服务无法备份它的数据库。              5766      服务无法从它的数据库初始化。 数据库可能找不到或损坏。 服务会试图从备份数据库恢复该数据库。              5767      服务无法从备份数据库还原它的数据库。服务 将不启动。              5768      服务无法从备份数据库还原它的数据库。              5769      服务无法从它还原的数据库初始化。服务 将不启动。              5771      远程启动数据库采用 NT 3.5 / NT 3.51 格式。NT 正在转换其为 NT 4.0 格式。完成转换后，JETCONV 转换器将写出应用事件日志。              5773      该 DC 的 DNS 服务器不支持动态 DNS。 将文件 ‘SystemRoot\System32\Config\netlogon.dns’ 中的 DNS 记录添加到伺服那个文件中引用的域的 DNS 服务器。              5781      由于没有可以使用的 DNS 服务器，一个或更多 DNS 记录的动态注册和注销未成功。              6000      无法加密指定的文件。              6001      指定的文件无法解密。              6002      指定的文件已加密，而且用户没有能力解密。              6003      这个系统没有有效的加密恢复策略配置。              6004      所需的加密驱动程序并未加载到系统中。              6005      文件加密所使用的加密驱动程序与目前加载的加密驱动程序不同。              6006      没有为用户定义的 EFS 关键字。              6007      指定的文件并未加密。              6008      指定的文件不是定义的 EFS 导出格式。              6009      指定的文件是只读文件。              6010      已为加密而停用目录。              6011      不信任服务器来进行远程加密操作。              6118      此工作组的服务器列表当前无法使用              6200      要正常运行，任务计划程序服务的配置必须在系统帐户中运行。单独的任务可以被配置成在其他帐户中运行。              7001      指定的会话名称无效。              7002      指定的协议驱动程序无效。              7003      在系统路径上找不到指定的协议驱动程序。              7004      在系统路径上找不到指定的终端连接。              7005      不能为这个会话创建一个事件日志的注册键。              7006      同名的一个服务已经在系统中存在。              7007      在会话上一个关闭操作挂起。              7008      没有可用的输出缓冲器。              7009      找不到 MODEM.INF 文件。              7010      在 MODEM.INF 中没有找到调制解调器名称。              7011      调制解调器没有接受发送给它的指令。验证配置的调制解调器与连接的调制解调器是否匹配。              7012      调制解调器没有接受发送给它的指令。验证该调制解调器是否接线正确并且打开了电源开关。              7013      运载工具检测失败或者由于断开连接，运载工具已被丢弃。              7014      在要求的时间内没有发现拨号音。 确定电话线连接正确并可使用。              7015      在远程站点回叫时检测到了占线信号。              7016      在回叫时远程站点上检测到了声音。              7017      传输驱动程序错误              7022      找不到指定的会话。              7023      指定的会话名称已处于使用中。              7024      由于终端连接目前正在忙于处理一个连接、断开连接、复位或删除操作，无法完成该请求的操作。              7025      试图连接到其视频模式不受当前客户支持的会话。              7035      应用程序尝试启动 DOS 图形模式。 不支持 DOS 图形模式。              7037      您的交互式登录权限已被禁用。 请与您的管理员联系。              7038      该请求的操作只能在系统控制台上执行。 这通常是一个驱动程序或系统 DLL 要求直接控制台访问的结果。              7040      客户未能对服务器连接消息作出响应。              7041      不支持断开控制台会话。              7042      不支持重新将一个断开的会话连接到控制台。              7044      远程控制另一个会话的请求被拒绝。              7045      拒绝请求的会话访问。              7049      指定的终端连接驱动程序无效。              7050      不能远程控制该请求的会话。 这也许是由于该会话被中断或目前没有一个用户登录。而且，您不能从该系统控制台远程控制一个会话或远程控制系统控制台。并且，您不能远程控制您自己的当前会话。              7051      该请求的会话没有配置成允许远程控制。              7052      拒绝连接到这个终端服务器。终端服务器客户许可证目前正在被另一个用户使用。 请与系统管理员联系，获取一份新的终端服务器客户，其许可证号码必须是有效的、唯一的。              7053      拒绝连接到这个终端服务器。还没有为这份终端服务器客户输入您的终端服务器客户许可证号码。 请与系统管理员联系，为该终端服务器客户输入一个有效的、唯一的许可证号码。              7054      系统已达到其授权的登录限制。 请以后再试一次。              7055      您正在使用的客户没有使用该系统的授权。您的登录请求被拒绝。              7056      系统许可证已过期。您的登录请求被拒绝。              8001      文件复制服务 API 被错误调用。              8002      无法启动文件复制服务。              8003      无法停止文件复制服务。              8004      文件复制服务 API 终止了请求。 事件日志可能有详细信息。              8005      该文件复制服务中断了该请求。 事件日志可能有详细信息。              8006      无法联系文件复制服务。 事件日志可能有详细信息。              8007      由于该用户没有足够特权，文件复制服务不能满足该请求。 事件日志可能有详细信息。              8008      由于验证的 RPC 无效，文件复制服务不能满足该请求。 事件日志可能有详细信息。              8009      由于该用户在域控制器上没有足够特权，文件复制服务不能满足该请求。 事件日志可能有详细信息。              8010      由于在域控制器上的验证的 RPC 无效，文件复制服务不能满足该请求。 事件日志可能有详细信息。              8011      该文件复制服务无法与在域控制器上的文件复制服务通讯。 事件日志可能有详细信息。              8012      在域控制器上的文件复制服务无法与这台计算机上的文件复制服务通讯。 事件日志可能有详细信息。              8013      由于内部错误，该文件复制服务不能进入该系统卷中。 事件日志可能有详细信息。              8014      由于内部超时，该文件复制服务不能进入该系统卷中。 事件日志可能有详细信息。              8015      该文件复制服务无法处理此请求。该系统卷仍在忙于前一个请求。              8016      由于内部错误，该文件复制服务无法停止复制该系统卷。 事件日志可能有详细信息。              8017      该文件复制服务检测到一个无效参数。              8200      在安装目录服务时出现一个错误。有关详细信息，请查看事件日志。              8201      目录服务在本地评估组成员身份。              8202      指定的目录服务属性或值不存在。              8203      指定给目录服务的属性语法无效。              8204      指定给目录服务的属性类型未定义。              8205      指定的目录服务属性或值已经存在。              8206      目录服务忙。              8207      该目录服务无效。              8208      目录服务无法分配相对标识号。              8209      目录服务已经用完了相对标识号池。              8210      由于目录服务不是该类操作的主控，未能执行操作。              8211      目录服务无法初始化分配相对标识号的子系统。              8212      该请求的操作没有满足一个或多个与该对象的类别相关的约束。              8213      目录服务只可以在一个页状对象上运行要求的操作。              8214      目录服务不能在一个对象的 RDN 属性上执行该请求的操作。              8215      目录服务检测出修改对象类别的尝试。              8216      不能执行请求的通过域的移动操作。              8217      无法联系全局编录服务器。              8218      策略对象是共享的并只可在根目录上修改。              8219      策略对象不存在。              8220      请求的策略信息只在目录服务中。              8221      域控制器升级目前正在使用中。              8222      域控制器升级目前不在使用中              8224      出现一个操作错误。              8225      出现一个协议错误。              8226      已经超过这个请求的时间限制。              8227      已经超过这个请求的大小限制。              8228      已经超过这个请求的管理限制。              8229      比较的响应为假。              8230      比较的响应为真。              8231      这个服务器不支持请求的身份验证方式。              8232      这台服务器需要一个更安全的身份验证方式。              8233      不适当的身份验证。              8234      未知的身份验证机制。              8235      从服务器返回了一个建议。              8236      该服务器不支持该请求的关键扩展。              8237      这个请求需要一个安全的连接。              8238      不恰当的匹配。              8239      出现一个约束冲突。              8240      在服务器上没有这样一个对象。              8241      有一个别名问题。              8242      指定了一个无效的 dn 语法。              8243      该对象为叶对象。              8244      有一个别名废弃问题。              8245      该服务器不愿意处理该请求。              8246      检查到一个循环。              8247      有一个命名冲突。              8248      结果设置太大。              8249      该操作会影响到多个 DSA。              8250      该服务器不可操作。              8251      出现一个本地错误。              8252      出现一个编码错误。              8253      出现一个解码错误。              8254      无法识别寻找筛选器。              8255      一个或多个参数非法。              8256      不支持指定的方式。              8257      没有返回结果。              8258      该服务器不支持该指定的控制。              8259      客户检测到一个参考循环。              8260      超过当前的参考限制。              8301      根目录对象必须是一个命名上下文的头。该根目录对象不能有实例父类。              8302      不能执行添加副本操作。名称上下文必须可写才能创建副本。              8303      出现一个对架构中未定义的一个属性的参考。              8304      超过了一个对象的最大尺寸。              8305      尝试向目录中添加一个已在使用中的名称的对象。              8306      尝试添加一个对象，该对象属于那类在架构中没有一个 RDN 定义的类别。              8307      尝试添加一个使用 RDN 的对象，但该 RDN 不是一个在架构中定义的 RDN 。              8308      在对象中找不到任何请求的属性。              8309      用户缓冲区太小。              8310      在操作中指定的属性不出现在对象上。              8311      修改操作非法。不允许该修改的某个方面。              8312      指定的对象太大。              8313      指定的实例类别无效。              8314      操作必须在主控 DSA 执行。              8315      必须指定对象类别属性。              8316      一个所需的属性丢失。              8317      尝试修改一个对象，将一个对该类别来讲是非法的属性包括进来。              8318      在对象上指定的属性已经存在。              8320      指定的属性不存在或没有值。              8321      为只有一个值的属性指定了多个值。              8322      属性值不在接受范围内。              8323      指定的值已存在。              8324      由于不存在于对象上，不能删除该属性。              8325      由于不存在于对象上，不能删除该属性值。              8326      指定的根对象不能是子参考。              8327      不允许链接。              8328      不允许链接的评估。              8329      由于对象的父类不是未实例化就是被删除了，所以不能执行操作。              8330      不允许有一个用别名的父类。别名是叶对象。              8331      对象和父类必须是同一种类，不是都是原件就是 都是副本。              8332      由于子对象存在，操作不能执行。这个操作只能在叶对象上执行。              8333      没有找到目录对象。              8334      别名对象丢失。              8335      对象名语法不对。              8336      不允许一个别名参考另一个别名。              8337      别名不能解除参考。              8338      操作超出范围。              8340      不能删除 DSA 对象。              8341      出现一个目录服务错误。              8342      操作只能在内部主控 DSA 对象上执行。              8343      对象必须为 DSA 类别。              8344      访问权不够不能执行该操作。              8345      由于父类不在可能的上级列表上，不能添加该对象。              8346      由于该属性处于“安全帐户管理器” (SAM)，不允许访问该属性。              8347      名称有太多部分。              8348      名称太长。              8349      名称值太长。              8350      目录服务遇到了一个错误分列名称。              8351      目录服务找不到一个名称的属性种类。              8352      该名称不能识别一个对象; 该名称识别一个幻象。              8353      安全描述符太短。              8354      安全描述符无效。              8355      为删除的对象创建名称失败。              8356      一个新子参考的父类必须存在。              8357      该对象必须是一个命名上下文。              8358      不允许添加一个不属于系统的属性。              8359      对象的类别必须是有结构的; 您不能实例化一个抽象的类别。              8360      找不到架构的对象。              8361      有这个 GUID (非活动的的或活动的)的本地对象已经存在。              8362      操作不能在一个后部链接上执行。              8363      找不到指定的命名上下文的互交参考。              8364      由于目录服务关闭，操作不能执行。              8365      目录服务请求无效。              8366      无法读取角色所有者属性。              8367      请求的 FSMO 操作失败。不能连接当前的 FSMO 盒。              8368      不允许跨过一个命名上下文修改 DN。              8369      由于属于系统，不能修改该属性。              8370      只有复制器可以执行这个功能。              8371      指定的类别没有定义。              8372      指定的类别不是一个子类别。              8373      名称参考无效。              8374      交叉参考已经存在。              8375      不允许删除一个主控交叉参考。              8376      只在 NC 头上支持子目录树通知。              8377      通知筛选器太复杂。              8378      架构更新失败: 重复的 RDN。              8379      架构更新失败: 重复的 OID。              8380      架构更新失败: 重复的 MAPI 识别符。              8381      架构更新失败: 复制架构 id GUID。              8382      架构更新失败: 重复的 LDAP 显示名称。              8383      架构更新失败: 范围下部少于范围上部。              8384      架构更新失败: 语法不匹配。              8385      架构更新失败: 属性在必须包含中使用。              8386      架构更新失败: 属性在可能包含中使用。              8387      架构更新失败: 可能包含中的属性不存在。              8388      架构更新失败:必须包含中的属性不存在。              8389      架构更新失败: 在辅助类别列表中的类别不存在或不是一个辅助类别。              8390      架构更新失败: poss-superior 中的类别不存在。              8391      架构更新失败: 在 subclassof 列表中的类别不存在或不能满足等级规则。              8392      架构更新失败: Rdn-Att-Id 语法不对。              8393      架构更新失败: 类别作为辅助类别使用。              8394      架构更新失败: 类别作为子类别使用。              8395      架构更新失败: 类别作为 poss superior 使用。              8396      架构更新在重新计算验证缓存时失败。              8397      目录树删除没有完成。要继续删除目录树，必须再次发出请求。              8398      不能执行请求的删除操作。              8399      不能读取架构记录管理类别识别符。              8400      属性架构语法不对。              8401      不能缓存属性。              8402      不能缓存类别。              8403      不能从缓存删除属性。              8404      无法从缓存中删除类别。              8405      无法读取特殊名称的属性。              8406      丢失一个所需的子参考。              8407      不能检索范例种类属性。              8408      出现一个内部错误。              8409      出现一个数据错误。              8410      丢失一个属性 GOVERNSID。              8411      丢失一个所需要的属性。              8412      指定的命名上下文丢失了一个交叉参考。              8413      出现一个安全检查错误。              8414      没有加载架构。              8415      架构分配失败。请检查机器内存是否不足。              8416      为属性架构获得所需语法失败。              8417      全局编录验证失败。全局编录无效或不支持操作。目录的某些部分目前无效。              8418      由于有关服务器之间的架构不匹配，复制操作失败。              8419      找不到 DSA 对象。              8420      找不到命名上下文。              8421      在缓存中找不到命名上下文。              8422      无法检索子对象。              8423      由于安全原因不允许修改。              8424      操作不能替换该隐藏的记录。              8425      等级无效。              8426      尝试建立等级表失败。              8427      目录配置参数在注册中丢失。              8428      尝试计算地址簿索引失败。              8429      等级表的分配失败。              8430      目录服务遇到一个内部失败。              8431      目录服务遇到一个未知失败。              8432      根对象需要一个 ‘top’ 类别。              8433      这个目录服务器已关闭，并且不能接受新上浮单一主机操作角色的所有权。              8434      目录服务没有必需的配置信息，并且不能决定新上浮单一主机操作角色的所有权。              8435      该目录服务无法将一个或多个上浮单一主机操作角色传送给其它服务器。              8436      复制操作失败。              8437      为这个复制操作指定了一个无效的参数。              8438      目录服务太忙，现在无法完成这个复制操作。              8439      为这个复制操作指定的单一名称无效。              8440      为这一个复制操作所指定的命名上下文无效。              8441      为这个复制操作指定的单一名称已经存在。              8442      复制系统遇到一个内部错误。              8443      复制操作遇到数据库不一致问题。              8444      不能连接到为这个复制操作指定的服务器上。              8445      复制操作遇到一个有无效范例类型的对象。              8446      复制操作无法分配内存。              8447      复制操作遇到一个邮件系统错误。              8448      目标服务器的复制参考信息已经存在。              8449      目标服务器的复制参考信息不存在。              8450      由于是由另一台服务器上复制的，因此不能删除命名上下文。              8451      复制操作遇到一个数据库错误。              8452      命名上下文要被删除或没有从指定的服务器上复制。              8453      复制访问被拒绝。              8454      这个版本的目录服务不支持请求的操作。              8455      取消复制远程过程呼叫。              8456      源服务器目前拒绝复制请求。              8457      目标服务器当前拒绝复制请求。              8458      由于对象名称冲突，复制操作失败。              8459      复制源已被重新安装。              8460      由于一个所需父对象丢失，复制操作失败。              8461      复制操作被抢先。              8462      由于缺乏更新，放弃复制同步尝试。              8463      由于系统正在关闭，复制操作被中断了。              8464      由于目标部分属性设置不是一个源部分属性设置的子设置，复制同步尝试失败。              8465      由于主复制尝试从部分复制同步，复制同步尝试失败。              8466      已经与为这个复制操作的指定的服务器联系，但是该服务器无法与完成这个操作所需的另外一个服务器联系。              8467      在副本安装时，检测到一个使用的源和内部版本之间的架构不匹配，不能安装该副本。              8468      架构更新失败: 有同一连接标识符的属性已经存在。              8469      名称翻译: 常见处理错误。              8470      名称翻译: 不能找到该名称或权限不够，不能看到名称。              8471      名称翻译: 输入名称映射到多个输出名称。              8472      名称翻译: 找到输出名称，但是找不到相应的输出格式。              8473      名称翻译: 不能完全解析，只找到了域。              8474      名称翻译: 不接到线上，无法在客户机上执行纯粹的语法映射。              8475      不允许一个构造 att 修改。              8476      指定的 OM-Object 类别对指定语法的一个属性是不正确的。              8477      复制请求已暂停; 等待回答。              8478      要求的操作需要一个目录服务，但没有可用的。              8479      类别或属性的 LDAP 显示名称含有非 ASCII 字符。              8480      请求的查找操作只支持基本查找。              8481      查找未能从数据库检索属性。              8482      架构更新操作试图添加一个反向链接，但该反向链接没有相应的正向链接。              8483      跨域移动的来源和目标在对象日期上不一致。或者是来源，或者是目标没有对象的最后一个版本。              8484      跨域移动的来源和目标在对象当前的名称上不一致。或者是来源，或者是目标没有对象的最后一个版本。              8485      域间移动的来源和目标是一样的。调用程序应该使用本地移动操作，而不是域间移动操作。              8486      域间移动的来源和目标与目录林中的命名上下文不一致。来源或目标没有分区容器的最近版本。              8487      跨域移动的目标不是目标命名上下文的权威。              8488      跨域移动的来源和目标提供的来源对象的身份不一样。 来源或目标没有来源对象的最近版本。              8489      跨域移动的对象应该已经被目标服务器删除。来源服务器没有来源对象的最近版本。              8490      要求对 PDC FSMO 的专门访问权的另一个操作正在进行中。              8491      跨域移动没有成功，导致被移动对象有两个版本 - 一个在来源域，一个在目标域。需要删除目标对象，将系统还原到一致状态。              8492      因为不允许这个类别的跨域移动，或者对象有一些特点，如: 信任帐户或防止移动的受限制的 RID；所以不能将该对象跨域移动。              8493      一旦移动，不能将带有成员身份的对象跨域移动，这会侵犯帐户组的成员身份条件。从帐户组成员身份删除对象，再试一次。              8494      命名上下文标题必须是另一个命名上下文标题的直接子标题，而不是一个内节点的子标题。              8495      因为目录没有提议的命名上下文上面的命名上下文的副本，所以无法验证所提议的命名上下文的名称。请保证充当域命名主机的服务器已配置成全局编录服务器，并且服务器及其复制伙伴是最新的。              8496      目标域必须在本机模式中。              8497      因为服务器在指定域中没有基础结构容器，所以无法执行操作。              8498      不允许跨域移动帐户组。              8499      不允许跨域移动资源组。              8500      属性的搜索标志无效。ANR 位只在 Unicode 或 Teletex 字符串的属性上有效。              8501      不允许在将 NC 头作为子体的对象开始删除目录树。              8502      因为目录树在使用中，目录服务未能为删除目录树而将其锁定。              8503      删除目录树时，目录服务未能识别要删除的对象列表。              8505      只有管理员才能修改管理组的成员列表。              8506      不能改变域控制器帐户的主要组 ID。              8507      试图修改基础架构。              8508      不允许进行下列操作: 为现有类别添加新的强制属性；从现有类别删除强制属性；为没有向回链接属性的特殊类别 “Top” 添加可选属性，向回链接属性指的是直接或通过继承。例如: 添加或删除附属类别。              8509      该域控制器上不允许架构更新。没有设置注册表项，或者 DC 不是架构 FSMO 角色所有者。              8510      无法在架构容器下创建这个类别的对象。在架构容器下，您只能创建属性架构和类别架构对象。              8511      副本/子项安装未能获取源 DC 上的架构容器的 objectVersion 属性。架构容器上的属性不存在，或者提供的凭据没有读取属性的权限。              8512      副本/子项安装未能读取 system32 目录中的文件 schema.ini 的 SCHEMA 段中的 objectVersion 属性。              8513      指定的组类型无效。              8514      如果域是安全启用的，在混合型域中不能嵌套全局组。              8515      如果域是安全启用的，在混合型域中不能嵌套本地组。              8516      全局组不能将本地组作为成员。              8517      全局组不能将通用组作为成员。              8518      通用组不能将本地组作为成员。              8519      全局组不能有跨域成员。              8520      本地组不能将另一个跨域本地组作为成员。              8521      包含主要成员的组不能改变为安全停用的组。              8522      架构缓冲加载未能转换类架构对象上的字符串默认值 SD。              8523      只有配置成全局编录服务器的 DSAs 才能充当域命名主机 FSMO 的角色。              8524      由于 DNS 查找故障，DSA 操作无法进行。              8525      处理一个对象的 DNS 主机名改动时，服务主要名称数值无法保持同步。              8526      未能读取安全描述符属性。              8527      没有找到请求的对象，但找到了具有那个密钥的对象。              8528      正在添加的链接属性的语法不正确。正向链接只能有语法 2.5.5.1、2.5.5.7 和 2.5.5.14，而反向链接只能有语法 2.5.5.1              8529      安全帐户管理员需要获得启动密码。              8530      安全帐户管理员需要从软盘获得启动密钥。              8531      目录服务无法启动。              8532      未能启动目录服务。              8533      客户和服务器之间的连接要求数据包保密性。              8534      来源域跟目标域不在同一个目录林中。              8535      目标域必须在目录林中。              8536      该操作要求启用目标域审核。              8537      该操作无法为来源域找到 DC。              8538      来源对象必须是一个组或用户。              8539      来源对象的 SID 已经在目标目录林中。              8540      来源对象和目标对象必须属于同一类型。              8542      在复制请求中不能包括架构信息。              8543      由于架构不兼容性，无法完成 复制操作。              8544      由于前一个架构的不兼容性，无法完成复制操作。              8545      因为源和目标都没有收到有关最近跨域启动操作的信息，所以无法应用复制更新。              8546      因为还有主控这个域的域控制器，所以无法删除请求的域。              8547      只能在全局编录服务器上执行请求的操作。              8548      本地组只能是同一个域中其他本地组的成员。              8549      外部安全主要成员不能是通用组的成员。              8550      出于安全，无法将属性复制到 GC。              8551      由于目前正在处理的修改太多，无法采取 PDC 的检查点。              8552      操作需要启用那个源域审核。              8553      安全主要对象仅能在域命名环境菜单中创建。              8554      服务主要名称(SPN) 无法建造，因为提供的主机名格式不适合。              8555      筛选器已传递建造的属性。              8556      unicodePwd 属性值必须括在双引号中。              8557      您的计算机无法加入域。已超出此域上允许创建的计算机帐户的最大值。请同系统管理员联系，复位或增加此限定值。              8558      由于安全原因，操作必须在目标 DC 上运行。              8559      由于安全原因，源 DC 必须是 Service Pack 4 或更新版本。              8560      在树目录删除的操作中不能删除“关键目录服务系统”对象。数目录删除操作可能只进行了一部分。              9001      DNS 服务器无法解释格式。              9002      DNS 服务器失败。              9003      DNS 名称不存在。              9004      名称服务器不支持 DNS 请求。              9005      拒绝 DNS 操作。              9006      不应该存在的 DNS 名称仍然存在。              9007      不应该存在的 DNS RR 集仍然存在。              9008      应该存在的 DNS RR 集不存在。              9009      DNS 服务器对区域没有权威。              9010      在更新或 prereq 中的 DNS 名称不在区域中。              9016      DNS 签名验证失败。              9017      DNS 不正确密钥。              9018      DNS 签名验证过期。              9501      为 DNS 查询找不到记录。              9502      无效 DNS 包。              9503      没有 DNS 包。              9504      DNS 错误，请检查 rcode。              9505      为保险的 DNS 包。              9551      无效的 DNS 种类。              9552      无效的 IP 地址。              9553      无效的属性。              9554      稍后再试一次 DNS 操作。              9555      给出的记录名称和种类不是单一的。              9556      DNS 名称不符合 RFC 说明。              9557      DNS 名称是一个完全合格的 DNS 名称。              9558      DNS 名称以“.”分隔(多标签)。              9559      DNS 名称是单一部分名称。              9560      DNS 名称含有无效字符。              9561      DNS 名称完全是数字的。              9601      DNS 区域不存在。              9602      DNS 区域信息无效。              9603      DNS 区域无效操作。              9604      无效 DNS 区域配置。              9605      DNS 区域没有颁发机构记录的开始(SOA)。              9606      DNS 区域没有“名称服务器” (NS)的记录。              9607      DNS 区域已锁定。              9608      DNS 区域创建失败。              9609      DNS 区域已经存在。              9610      DNS 自动区域已经存在。              9611      无效的 DNS 区域种类。              9612      次要 DNS 区域需要主 IP 地址。              9613      DNS 区域不是次要的。              9614      需要一个次要 IP 地址              9615      WINS 初始化失败。              9616      需要 WINS 服务器。              9617      NBTSTAT 初始化呼叫失败。              9618      颁发机构起始(SOA)删除无效              9651      主要 DNS 区域需要数据文件。              9652      DNS 区域的无效数据文件名称。              9653      为 DNS 区域打开数据文件失败。              9654      为 DNS 区域写数据文件失败。              9655      为 DNS 区域读取数据文件时失败。              9701      DNS 记录不存在。              9702      DNS 记录格式错误。              9703      DNS 中节点创建失败。              9704      未知 DNS 记录类型。              9705      DNS 记录超时。              9706      名称不在 DNS 区域。              9707      检测到 CNAME 循环。              9708      节点为一个 CNAME DNS 记录。              9709      指定名称的 CNAME 记录已经存在。              9710      记录不在 DNS 区域根目录。              9711      DNS 记录已经存在。              9712      次要 DNS 区域数据错误。              9713      不能创建 DNS 缓存数据。              9714      DNS 名称不存在。              9715      不能创建指针(PTR)记录。              9716      DNS 域没有被删除。              9717      该目录服务无效。              9718      DNS 区域已经在目录服务中存在。              9719      DNS 服务器没有为目录服务集合 DNS 区域创建或读取启动文件。              9751      完成 DNS AXFR (区域复制)。              9752      DNS 区域复制失败。              9753      添加了本地 WINS 服务器。              9801      安全更新呼叫需要继续更新请求。              9851      TCP/IP 没有安装网络协议。              9852      没有为本地系统配置 DNS 服务器。              10004      一个封锁操作被对 WSACancelBlockingCall 的调用中断。              10009      提供的文件句柄无效。              10013      以一种访问权限不允许的方式做了一个访问套接字的尝试。              10014      系统检测到在一个调用中尝试使用指针参数时的无效指针地址。              10022      提供了一个无效的参数。              10024      打开的套接字太多。              10035      无法立即完成一个非阻挡性套接字操作。              10036      目前正在执行一个阻挡性操作。              10037      在一个非阻挡套接字上尝试了一个已经在进行的操作。              10038      在一个非套接字上尝试了一个操作。              10039      请求的地址在一个套接字中从操作中忽略。              10040      一个在数据报套接字上发送的消息大于内部消息缓冲器或其它一些网络限制，或该用户用于接收数据报的缓冲器比数据报小。              10041      在套接字函数调用中指定的一个协议不支持请求的套接字类别的语法。              10042      在 getsockopt 或 setsockopt 调用中指定的一个未知的、无效的或不受支持的选项或层次。              10043      请求的协议还没有在系统中配置，或者没有它存在的迹象。              10044      在这个地址家族中不存在对指定的插槽种类的支持。              10045      参考的对象种类不支持尝试的操作。              10046      协议家族尚未配置到系统中或没有它的存在迹象。              10047      使用了与请求的协议不兼容的地址。              10048      通常每个套接字地址 (协议/网络地址/端口) 只允许使用一次。              10049      在其上下文中，该请求的地址无效。              10050      套接字操作遇到了一个已死的网络。              10051      向一个无法连接的网络尝试了一个套接字操作。              10052      当该操作在进行中，由于保持活动的操作检测到一个故障，该连接中断。              10053      您的主机中的软件放弃了一个已建立的连接。              10054      远程主机强迫关闭了一个现有的连接。              10055      由于系统缓冲区空间不足或列队已满，不能执行套接字上的操作。              10056      在一个已经连接的套接字上做了一个连接请求。              10057      由于套接字没有连接并且 (当使用一个 sendto 调用发送数据报套接字时) 没有提供地址，发送或接收数据的请求没有被接受。              10058      由于以前的关闭调用，套接字在那个方向已经关闭，发送或接收数据的请求没有被接受。              10059      对某个内核对象的引用过多。              10060      由于连接方在一段时间后没有正确的答复或连接的主机没有反应，连接尝试失败。              10061      不能做任何连接，因为目标机器积极地拒绝它。              10062      无法翻译名称。              10063      名称组件或名称太长。              10064      由于目标主机坏了，套接字操作失败。              10065      套接字操作尝试一个无法连接的主机。              10066      不能删除目录，除非它是空的。              10067      一个 Windows 套接字操作可能在可以同时使用的应用程序数目上有限制。              10068      超过限额。              10069      超过磁盘限额。              10070      文件句柄引用不再有效。              10071      项目在本地不可用。              10091      因为它使用提供网络服务的系统目前无效，WSAStartup 目前不能正常工作。              10092      不支持请求的 Windows 套接字版本              10093      应用程序没有调用 WSAStartup，或者 WSAStartup 失败。              10101      由 WSARecv 或 WSARecvFrom 返回表示远程方面已经开始了关闭步骤。              10102      WSALookupServiceNext 不能返回更多的结果。              10103      在处理这个调用时，就开始调用 WSALookupServiceEnd。该调用被删除。              10104      过程调用无效。              10105      请求的服务提供程序无效。              10106      没有加载或初始化请求的服务提供程序。              10107      从来不应失败的系统调用失败了。              10108      没有已知的此服务。在指定的名称空间中找不这个服务。              10109      找不到指定的类别。              10110      WSALookupServiceNext 不能返回更多的结果。              10111      在处理这个调用时，就开始调用 WSALookupServiceEnd。该调用被删除。              10112      由于被拒绝，数据查询失败。      更多错误编码请参看 《上篇》。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> debug </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SQL Server 错误代码和解释 (中篇)]]></title>
      <url>/blog/sql-server-state-code-list-2/</url>
      <content type="text"><![CDATA[承接《上篇》继续罗列分享SQL Server状态码。            错误码      错误原因说明                         2001      指定的驱动程序无效。                     2002      窗口样式或类别属性对此操作无效。                     2003      不支持请求的图元操作。                     2004      不支持请求的变换操作。                     2005      不支持请求的剪切操作。                     2010      指定的颜色管理模块无效。                     2011      制定的颜色文件配置无效。                     2012      找不到指定的标识。                     2013      找不到所需的标识。                     2014      指定的标识已经存在。                     2015      指定的颜色文件配置与任何设备都不相关。                     2016      找不到该指定的颜色文件配置                     2017      指定的颜色空间无效。                     2018      图像颜色管理没有启动。                     2019      在删除该颜色传输时有一个错误。                     2020      该指定的颜色传输无效。                     2021      该指定的变换与位图的颜色空间不匹配。                     2022      该指定的命名颜色索引在配置文件中不存在。                     2102      没有安装工作站驱动程序。                     2103      无法定位服务器。                     2104      发生内部错误，网络无法访问共享内存段。                     2105      网络资源不足。                     2106      工作站不支持这项操作。                     2107      设备没有连接。                     2108      网络连接已成功，但需要提示用户输入一个不同于原始指定的密码。                     2114      没有启动服务器服务。                     2115      队列空。                     2116      设备或目录不存在。                     2117      无法在重定向的资源上执行这项操作。                     2118      名称已经共享。                     2119      服务器当前无法提供所需的资源。                     2121      额外要求的项目超过允许的上限。                     2122      对等服务只支持两个同时操作的用户 。                     2123      API 返回缓冲区太小。                     2127      远程 API 错误。                     2131      打开或读取配置文件时出错。                     2136      发生一般网络错误。                     2137      工作站服务的状态不一致。重新启动工作站服务之前，请先重新启动计算机。                     2138      工作站服务没有启动。                     2139      所需信息不可用。                     2140      发生 Windows 2000 内部错误。                     2141      服务器没有设置事务处理。                     2142      远程服务器不支持请求的 API。                     2143      事件名无效。                     2144      网络上已经有此计算机名。请更名后重新启动。                     2146      配置信息中找不到指定的组件。                     2147      配置信息中找不到指定的参数。                     2149      配置文件中有一个命令行太长。                     2150      打印机不存在。                     2151      打印作业不存在。                     2152      打印机目标找不到。                     2153      打印机目标已经存在。                     2154      打印机队列已经存在。                     2155      无法添加其它的打印机。                     2156      无法添加其它的打印作业。                     2157      无法添加其它的打印机目标。                     2158      此打印机目标处于空闲中，不接受控制操作。                     2159      此“打印机目标请求”包含无效的控制函数。                     2160      打印处理程序没有响应。                     2161      后台处理程序没有运行。                     2162      打印目标当前的状况，无法执行这项操作。                     2163      打印机队列当前的状况，无法执行这项操作。                     2164      打印作业当前的状况，无法执行这项操作。                     2165      无法为后台处理程序分配内存。                     2166      设备驱动程序不存在。                     2167      打印处理程序不支持这种数据类型。                     2168      没有安装打印处理程序。                     2180      锁定服务数据库。                     2181      服务表已满。                     2182      请求的服务已经启动。                     2183      这项服务没有响应控制操作。                     2184      服务仍未启动。                     2185      服务名无效。                     2186      服务没有响应控制功能。                     2187      服务控制处于忙碌状态。                     2188      配置文件包含无效的服务程序名。                     2189      在当前的状况下无法控制服务。                     2190      服务异常终止。                     2191      这项服务无法接受请求的 “暂停” 或 “停止” 操作。                     2192      服务控制“计划程序”在“计划表”中找不到服务名。                     2193      无法读取服务控制计划程序管道。                     2194      无法创建新服务的线程。                     2200      此工作站已经登录到局域网。                     2201      工作站没有登录到局域网。                     2202      指定的用户名无效。                     2203      密码参数无效。                     2204      登录处理器没有添加消息别名。                     2205      登录处理器没有添加消息别名。                     2206      注销处理器没有删除消息别名。                     2207      注销处理器没有删除消息别名。                     2209      暂停网络登录。                     2210      中心登录服务器发生冲突。                     2211      服务器没有设置正确的用户路径。                     2212      加载或运行登录脚本时出错。                     2214      没有指定登录服务器，计算机的登录状态是单机操作。                     2215      登录服务器找不到。                     2216      此计算机已经有一个登录域。                     2217      登录服务器无法验证登录。                     2219      安全数据库找不到。                     2220      组名找不到。                     2221      用户名找不到。                     2222      资源名找不到。                     2223      组已经存在。                     2224      帐户已经存在。                     2225      资源使用权限清单已经存在。                     2226      此操作只能在该域的主域控制器上执行。                     2227      安全数据库没有启动。                     2228      用户帐户数据库中的名称太多。                     2229      磁盘 I/O 失败。                     2230      已经超过每个资源 64 个项目的限制。                     2231      不得删除带会话的用户。                     2232      上层目录找不到。                     2233      无法添加到安全数据库会话高速缓存段。                     2234      这项操作不能在此特殊的组上执行。                     2235      用户帐户数据库会话高速缓存没有记录此用户。                     2236      用户已经属于此组。                     2237      用户不属于此组。                     2238      此用户帐户尚未定义。                     2239      此用户帐户已过期。                     2240      此用户不得从此工作站登录网络。                     2241      这时候不允许用户登录网络。                     2242      此用户的密码已经过期。                     2243      此用户的密码无法更改。                     2244      现在无法使用此密码。                     2245      密码不满足密码策略的需要。检查最小密码长度、密码复杂性和密码历史的需求。                     2246      此用户的密码最近才启用，现在不能更改。                     2247      安全数据库已损坏。                     2248      不需要更新此副本复制的网络/本地安全数据库。                     2249      此副本复制的数据库已过时；请同步处理其中的数据。                     2250      此网络连接不存在。                     2251      此 asg_type 无效。                     2252      此设备当前正在共享中。                     2270      计算机名无法作为消息别名添加。网络上可能已经有此名称。                     2271      信使服务已经启动。                     2272      信使服务启动失败。                     2273      网络上找不到此消息别名。                     2274      此消息别名已经转发出去。                     2275      已经添加了此消息别名，但是仍被转发。                     2276      此消息别名已在本地存在。                     2277      添加的消息别名已经超过数目上限。                     2278      无法删除计算机名。                     2279      消息无法转发回到同一个工作站。                     2280      域消息处理器出错。                     2281      消息已经发送出去，但是收件者已经暂停信使服务。                     2282      消息已经发送出去，但尚未收到。                     2283      消息别名当前正在使用中。请稍候片刻再试。                     2284      信使服务尚未启动。                     2285      该名称不在本地计算机上。                     2286      网络上找不到转发的消息别名。                     2287      远程通讯站的消息别名表已经满了。                     2288      此别名的消息当前没有在转发中。                     2289      广播的消息被截断。                     2294      设备名无效。                     2295      写入出错。                     2297      网络上的消息别名重复。                     2298      此消息别名会在稍后删除。                     2299      没有从所有的网络删除消息别名。                     2300      这项操作无法在使用多种网络的计算机上执行。                     2310      此共享的资源不存在。                     2311      设备没有共享。                     2312      带此计算机名的会话不存在。                     2314      没有用此识别号打开的文件。                     2315      执行远程管理命令失败。                     2316      打开远程临时文件失败。                     2317      从远程管理命令返回的数据已经被截断成 64K。                     2318      此设备无法同时共享为后台处理资源和非后台处理资源。                     2319      服务器清单中的信息可能不正确                     2320      计算机在此域未处于活动状态                     2321      在删除共享之前，需要将该共享从分布式文件系统中删除。                     2331      无法在此设备执行这项操作                     2332      此设备无法共享。                     2333      此设备未打开。                     2334      此设备名清单无效。                     2335      队列优先级无效。                     2337      没有任何共享的通讯设备。                     2338      指定的队列不存在。                     2340      此设备清单无效。                     2341      请求的设备无效。                     2342      后台处理程序正在使用此设备。                     2343      此设备已经被当成通讯设备来使用。                     2351      此计算机名无效。                     2354      指定的字符串及前缀太长。                     2356      此路径组成部分无效。                     2357      无法判断输入类型。                     2362      类型缓冲区不够大。                     2370      配置文件不得超过 64K。                     2371      初始偏移量越界。                     2372      系统无法删除当前到网络资源的连接。                     2373      系统无法分析此文件中的命令行。                     2374      加载配置文件时出错。                     2375      保存配置文件时出错，只部份地保存了配置文件。                     2378      此日志文件在前后两次读取之间已经发生变化。                     2380      资源路径不可以是目录。                     2381      资源路径无效。                     2382      目标路径无效。                     2383      源路径及目标路径分属不同的服务器。                     2385      请求的 Run 服务器现在暂停。                     2389      与 Run 服务器通讯时出错。                     2391      启动后台处理时出错。                     2392      找不到您连接的共享资源。                     2400      LAN 适配器号码无效。                     2401      此网络连接有文件打开或请求挂起。                     2402      使用中的连接仍存在。                     2403      此共享名或密码无效。                     2404      设备正由活动进程使用，无法断开。                     2405      此驱动器号已在本地使用。                     2430      指定的客户已经在指定的事件注册。                     2431      警报表已满。                     2432      发出的警报名称无效或不存在。                     2433      警报接收者无效。                     2434      用户的登录时间长短不再合法。 所以已经删除用户与该服务器的会话。                     2440      日志文件中没有请求的记录号。                     2450      用户帐户数据库没有正确配置。                     2451      当 Netlogon 服务正在运行时，不允许执行这项操作。                     2452      这项操作无法在最后的管理帐户上执行。                     2453      找不到此域的域控制器。                     2454      无法设置此用户的登录信息。                     2455      Netlogon 服务尚未启动。                     2456      无法添加到用户帐户数据库。                     2457      此服务器的时钟与主域控制器的时钟不一致。                     2458      检测到密码不匹配。                     2460      服务器识别码没有指定有效的服务器。                     2461      会话标识没有指定有效的会话。                     2462      连接识别码没有指定有效的连接。                     2463      可用服务器表中无法再加上其它项。                     2464      服务器已经到了支持的会话数目上限。                     2465      服务器已经到了支持的连接数目上限。                     2466      服务器打开的文件到了上限，无法打开更多文件。                     2467      这台服务器没有登记替换的服务器。                     2470      请用低级的 API (远程管理协议)。                     2480      UPS 服务无法访问 UPS 驱动程序。                     2481      UPS 服务设置错误。                     2482      UPS 服务无法访问指定通讯端口 (Comm Port)。                     2483      UPS 显示线路中断或电池不足，服务没有启动。                     2484      UPS 服务无法执行系统关机的操作。                     2500      下面的程序返回一个 MS-DOS 错误码。                     2501      下面的程序需要更多的内存。                     2502      下面程序调用了不支持的 MS-DOS 函数。                     2503      工作站无法启动。                     2504      下面的文件已损坏。                     2505      启动块定义文件中没有指定引导程序。                     2506      NetBIOS 返回错误: NCB 及 SMB 数据转储。                     2507      磁盘 I/O 错误。                     2508      无法替换映像参数。                     2509      跨越磁盘扇区范围的映像参数太多。                     2510      不是从用 /S 格式化的 MS-DOS软盘产生的映像。                     2511      稍后会从远程重新启动。                     2512      无法调用远程启动服务器。                     2513      无法连接到远程启动服务器。                     2514      无法打开远程启动服务器上的映像文件。                     2515      正在连接到远程启动服务器…                     2516      正在连接到远程启动服务器…                     2517      远程启动服务已经停止，请检测错误记录文件，查明出错的原因。                     2518      远程启动失败，请检查错误日志文件，查明出错的原因。                     2519      不允许第二个远程启动 (Remoteboot) 资源连接。                     2550      浏览服务设置成 MaintainServerList=No。                     2610      因为没有网卡与这项服务一起启动，所以无法启动服务。                     2611      因为注册表中的启动信息不正确，所以无法启动服务。                     2612      无法启动服务，原因是它的数据库找不到或损坏。                     2613      因为找不到 RPLFILES 共享的资源，所以无法启动服务。                     2614      因为找不到 RPLUSER 组，所以无法启动服务。                     2615      无法枚举服务记录。                     2616      工作站记录信息已损坏。                     2617      工作站记录找不到。                     2618      其它的工作站正在使用此工作站名。                     2619      配置文件记录已损坏。                     2620      配置文件记录找不到。                     2621      其它的配置文件正在使用此名称。                     2622      有很多工作站正在使用此配置文件。                     2623      配置记录已损坏。                     2624      配置记录找不到。                     2625      适配器识别记录已损坏。                     2626      内部服务出错。                     2627      供应商识别记录已损坏。                     2628      启动块记录已损坏。                     2629      找不到此工作站的用户帐户记录。                     2630      RPLUSER 本地组找不到。                     2631      找不到启动块记录。                     2632      所选的配置文件与此工作站不兼容。                     2633      其它的工作站正在使用所选的网卡。                     2634      有些配置文件正在使用此配置。                     2635      有数个工作站、配置文件或配置正在使用此启动块。                     2636      服务无法制作远程启动数据库的备份。                     2637      找不到适配器记录。                     2638      找不到供应商记录。                     2639      其它供应商记录正在使用此供应商名称。                     2640      其它的启动区记录正在使用启动名称或供应商识别记录。                     2641      其它的配置正在使用此配置名称。                     2660      由 Dfs 服务所维护的内部数据库已损坏                     2661      内部数据库中的一条记录已 损坏                     2662      输入项路径与卷路径不匹配                     2663      给定卷名已存在                     2664      指定的服务器共享已在 Dfs 中共享                     2665      所显示的服务器共享不支持所显示的 Dfs 卷                     2666      此操作在非叶卷上无效。                     2667      此操作在叶卷上无效。                     2668      此操作不明确，因为该卷存在多服务器。                     2669      无法创建连接点                     2670      该服务器不是 Dfs 可识别的                     2671      指定的重命名目标路径无效。                     2672      指定 Dfs 卷脱线                     2673      指定的服务器不为此卷服务                     2674      检测到 Dfs 名中的环路                     2675      在基于服务器的 Dfs 上不支持该操作                     2676      这个卷已经受该指定服务器共享支持                     2677      无法删除这个卷的上一个服务器共享支持                     2678      Inter-Dfs 卷不支持该操作                     2679      Dfs 服务的内部状态已经变得不一致                     2680      Dfs 服务已经安装在指定的服务器上                     2681      被协调的 Dfs 数据是一样的                     2682      无法删除 Dfs 根目录卷 - 如需要请卸载 Dfs                     2683      该共享的子目录或父目录已经存在在一个 Dfs 中                     2690      Dfs 内部错误                     2691      这台机器已经加入域 。                     2692      这个机器目前未加入域。                     2693      这台机器是域控制器，而且无法从域中退出。                     2694      目标域控制器不支持在 OU 中创建的机器帐户。                     2695      指定的工作组名无效                     2696      指定的计算机名与域控制器上使用的默认语言不兼容。                     2697      找不到指定的计算机帐户。                     2999      这是 NERR 范围内的最后一个错误。                     3000      指定了未知的打印监视器。                     3001      指定的打印机驱动程序当前正在使用。                     3002      找不到缓冲文件。                     3003      未发送 StartDocPrinter 调用。                     3004      未发送 AddJob 调用。                     3005      指定的打印处理器已经安装。                     3006      指定的打印监视器已经安装。                     3007      该指定的打印监视器不具备所要求的功能。　                     3008      该指定的打印监视器正在使用中。                     3009      当打印机有作业排成队列时此操作请求是不允许的。                     3010      请求的操作成功。直到重新启动系统前更改将不会生效。                     3011      请求的操作成功。直到重新启动服务前更改将不会生效。                     3012      找不到打印机。                     3023      用户指定的关机命令文件，它的配置有问题。 不过 UPS 服务已经启动。                     3029      因为用户帐户数据库 (NET.ACC) 找不到或损坏， 而且也没有可用的备份数据库， 所以不能启动本地安全机制。 系统不安全！                     3037      @I *登录小时数                     3039      已经超过一个目录中文件的副本复制的限制。                     3040      已经超过副本复制的目录树深度限制。                     3046      无法登录。用户当前已经登录，同时参数 TRYUSER 设置为 NO。                     3052      命令行或配置文件中 没有提供必要的参数。                     3054      无法满足资源的请求。                     3055      系统配置有问题。                     3056      系统出错。                     3057      发生内部一致性的错误。                     3058      配置文件或命令行的选项不明确。                     3059      配置文件或命令行的参数重复。                     3060      服务没有响应控制， DosKillProc 函数已经停止服务。                     3061      运行服务程序时出错。                     3062      无法启动次级服务。                     3064      文件有问题。                     3070      内存                     3071      磁盘空间                     3072      线程                     3073      过程                     3074      安全性失败。                     3075      LAN Manager 根目录不正确或找不到。                     3076      未安装网络软件。                     3077      服务器未启动。                     3078      服务器无法访问用户帐户数据库 (NET.ACC)。                     3079      LANMAN 树中安装的文件不兼容。                     3080      LANMAN\LOGS 目录无效。                     3081      指定的域无法使用。                     3082      另一计算机正将此计算机名当作消息别名使用。                     3083      宣布服务器名失败。                     3084      用户帐户数据库没有正确配置。                     3085      服务器没有运行用户级安全功能。                     3087      工作站设置不正确。                     3088      查看您的错误日志文件以了解详细信息。                     3089      无法写入此文件。                     3090      ADDPAK 文件损坏。请删除 LANMAN\NETPROG\ADDPAK.SER 后重新应用所有的 ADDPAK。                     3091      因为没有运行 CACHE.EXE，所以无法启动 LM386 服务器。                     3092      安全数据库中找不到这台计算机的帐户。                     3093      这台计算机不是 SERVERS 组的成员。                     3094      SERVERS 组没有在本地安全数据库中。                     3095      此 Windows NT 计算机被设置为某个组的成员， 并不是域的成员。 此种配置下不需要运行 Netlogon 服务。                     3096      找不到此域的 Windows NT 域控制器。                     3098      服务无法与主域控制器进行验证。                     3099      安全数据库文件创建日期或序号有问题。                     3100      因为网络软件出错，所以无法执行操作。                     3102      这项服务无法长期锁定网络控制块 (NCB) 的段。 错误码就是相关数据。                     3103      这项服务无法解除网络控制块 (NCB) 段的长期锁定。 错误码就是相关数据。                     3106      收到意外的网络控制块 (NCB)。NCB 就是相关数据。                     3107      网络没有启动。                     3108      NETWKSTA.SYS 的 DosDevIoctl 或 DosFsCtl 调用失败。 显示的数据为以下格式: DWORD 值代表调用 Ioctl 或 FsCtl 的 CS:IP WORD 错误代码 WORD Ioctl 或 FsCtl 号                     3111      发生意外的 NetBIOS 错误。 错误码就是相关数据。                     3112      收到的服务器消息块 (SMB) 无效。 SMB 就是相关数据。                     3114      因为缓冲区溢出， 所以错误日志文件中部份的项目丢失。                     3120      控制网络缓冲区以外资源用量的初始化参数被设置大小， 因此需要的内存太多。                     3121      服务器无法增加内存段的大小。                     3124      服务器启动失败。三个 chdev 参数必须同时为零或者同时不为零。                     3129      服务器无法更新 AT 计划文件。 文件损坏。                     3130      服务器调用 NetMakeLMFileName 时出错。 错误码就是相关数据。                     3132      无法长期锁定服务器缓冲区。 请检查交换磁盘的可用空间，然后重新启动系统以启动服务器。                     3140      因为多次连续出现网络控制块 (NCB) 错误，所以停止服务。 最后一个坏的 NCB 以原始数据形式出现。                     3141      因为消息服务器共享的数据段被锁住， 所以消息服务器已经停止运行。                     3151      因为 VIO 调用出错，所以无法弹出显示消息。 错误码就是相关数据。                     3152      收到的服务器消息块 (SMB) 无效。SMB 就是相关数据。                     3160      工作站信息段大于 64K。 大小如下(以 DWORD 值的格式):                     3161      工作站无法取得计算机的名称号码。                     3162      工作站无法初始化 Async NetBIOS 线程。 错误码就是相关数据。                     3163      工作站无法打开最前面的共享段。 错误码就是相关数据。                     3164      工作站主机表已满。                     3165      收到的邮筒服务器消息块 (SMB) 有问题，SMB 就是相关数据。                     3166      工作站启动用户帐户数据库时出错。 错误码就是相关数据。                     3167      工作站响应 SSI 重新验证请求时出错。 函数码及错误码就是相关数据。                     3174      服务器无法读取 AT 计划文件。                     3175      服务器发现错误的 AT 计划记录。                     3176      服务器找不到 AT 计划文件，所以创建一个计划文件。                     3185      因为用户帐户数据库 (NET.ACC) 找不到或损坏， 而且也没有可用的备份数据库， 所以不能启动本地安全机制。 系统不安全！                     3204      服务器无法创建线程。 CONFIG.SYS 中的 THREADS 参数必须加大。                     3213      已经超过一个目录中文件的副本复制的限制。                     3214      已经超过副本复制的目录树深度限制。                     3215      邮筒中收到的消息无法识别。                     3217      无法登录。用户当前已经登录，同时参数 TRYUSER 设置为 NO。                     3230      检测到服务器的电源中断。                     3231      UPS 服务已经关掉服务器。                     3232      UPS 服务没有完成执行用户指定的 关机命令文件。                     3233      无法打开 UPS 驱动程序。 错误码就是相关数据。                     3234      电源已经恢复。                     3235      用户指定的关机命令文件 有问题。                     3256      该项服务的动态链接库 发生无法修复的错误。                     3257      系统返回意外的错误码。 错误码就是相关数据。                     3258      容错错误日志文件 - LANROOT\LOGS\FT.LOG 超过 64K。                     3259      容错错误日志文件 - LANROOT\LOGS\FT.LOG，在被打开时就已设置 更新进度位，这表示上次使用错误日志时， 系统死机。                     3301      Remote IPC                     3302      Remote Admin                     3303      Logon server share                     3304      网络出错。                     3400      内存不足，无法启动工作站服务。                     3401      读取 LAMAN.INI 文件的 NETWORKS 项目出错。                     3404      LAMAN.INI 文件中的 NETWORKS 项目太多。                     3408      程序无法用在此操作系统。                     3409      已经安装转发程序。                     3411      安装 NETWKSTA.SYS 时出错。 请按 ENTER 继续。                     3412      求解程序链接问题。                     3419      您已经打开文件或设备， 强制断开会造成数据丢失。                     3420      内部用的默认共享                     3421      信使服务                     3500      命令成功完成。                     3501      使用的选项无效。                     3503      命令包含无效的参数个数。                     3504      命令运行完毕，但发生一个或多个错误。                     3505      使用的选项数值不正确。                     3510      命令使用了冲突的选项。                     3512      软件需要新版的 操作系统。                     3513      数据多于 Windows 2000 所能够返回的。                     3515      此命令只能用在 Windows 2000 域控制器。                     3516      这个指令不能用于一个 Windows 2000 域控制器。                     3520      已经启动以下 Windows 2000 服务:                     3525      停止工作站服务也会同时停止服务器服务 。                     3526      工作站有打开的文件。                     3533      服务正在启动或停止中，请稍候片刻后再试一次。                     3534      服务没有报告任何错误。                     3535      正在控制设备时出错。                     3660      这些工作站在这台服务器上有会话:                     3661      这些工作站有会话打开了此台服务器上的文件:                     3666      消息别名已经转发出去。                     3670      您有以下的远程连接:                     3671      继续运行会取消连接。                     3676      会记录新的网络连接。                     3677      不记录新的网络连接。                     3678      保存配置文件时出错，原先记录的网络连接状态没有更改。                     3679      读取配置文件时出错。                     3682      没有启动任何网络服务。                     3683      清单是空的。                     3689      工作站服务已经在运行中，Windows 2000 会忽略工作站的命令选项。                     3694      在打印作业正在后台处理到队列时，无法删除共享的队列。                     3710      打开帮助文件时出错。                     3711      帮助文件是空的。                     3712      帮助文件已经损坏。                     3714      这是专为那些安装旧版软件的系统 提供的操作。                     3716      设备类型未知。                     3717      日志文件已经损坏。                     3718      程序文件名后必须以 .EXE 结束。                     3719      找不到匹配的共享，因此没有删除。                     3720      用户记录中的 “单位/星期” 的值不正确。                     3725      删除共享时出错。                     3726      用户名无效。                     3727      密码无效。                     3728      密码不匹配。                     3729      永久连接没有完全还原。                     3730      计算机名或域名错误。                     3732      无法设置该资源的默认权限。                     3734      没有输入正确的密码。                     3735      没有输入正确的名称。                     3736      该资源无法共享。                     3737      权限字符串包含无效的权限。                     3738      您只能在打印机或通讯设备上执行这项操作。                     3743      服务器没有设置远程管理的功能。                     3752      这台服务器上没有用户的会话。                     3756      响应无效。                     3757      没有提供有效的响应。                     3758      提供的目标清单与打印机队列目标清单不匹配。                     3761      指定的时间范围中结束的时间比开始的时间早。                     3764      提供的时间不是整点。                     3765      12 与 24 小时格式不能混用。                     3767      提供的日期格式无效。                     3768      提供的日期范围无效。                     3769      提供的时间范围无效。                     3770      NET USER 的参数无效。请检查最短的密码长度 和/或提供参数。                     3771      ENABLESCRIPT 的值必须是 YES。                     3773      提供的国家(地区)代码无效。                     3774      用户已经创建成功，但是无法添加到 USERS 本地组中。                     3775      提供的用户上下文无效。                     3777      文件发送功能已不再支持。                     3778      您可能没有指定 ADMIN$ 及 IPC$ 共享的路径。                     3784      只有磁盘共享可以标记为可以缓存。                     3802      此计划日期无效。                     3803      LANMAN 根目录无法使用。                     3804      SCHED.LOG 文件无法打开。                     3805      服务器服务尚未启动。                     3806      AT 作业标识不存在。                     3807      AT 计划文件已损坏。                     3808      因为 AT 计划文件发生问题，所以无法运行删除操作。                     3809      命令行不得超过 259 个字符。                     3810      因为磁盘已满，所以 AT 计划文件无法更新。                     3812      AT 计划文件无效。请删除此文件并创建新的文件。                     3813      AT 计划文件已经删除。                     3814      此命令的语法是: AT [id] [/Delete] AT 时间 [/EVERY:日期      /NEXT:日期] 命令 AT 命令会在以后的 指定日期及时间，安排程序在服务器上运行。 它也会显示安排运行的程序及命令的清单。 您可以将日期指定为M、T、W、Th、F、Sa、Su 或 1-31 的格式。 您可以将时间指定为HH:3814              3815      AT 命令已经超时。 请稍后再试一次。                     3816      用户帐户的密码使用最短期限不得 大于密码最长使用期限。                     3817      指定的数值与安装下层软件的服务器不兼容。 请指定较小的值。                     3902      意外到达消息的结尾                     3905      请按 ESC 退出                     3912      找不到时间服务器。                     3915      无法判断用户的主目录。                     3916      没有指定用户的主目录。                     3920      已经没有可用的驱动器号。                     3936      这台计算机目前没有配置成使用一个指定的 SNTP 服务器。                     3953      语法错误。                     3960      指定的文件号码无效。                     3961      指定的打印作业号码无效。                     3963      指定的用户或组帐户找不到。                     3965      已添加用户，但 NetWare 的文件和打印服务无法启用。                     3966      没有安装 NetWare 的文件和打印服务。                     3967      无法为 NetWare 的文件和打印服务设置用户属性。                     3969      NetWare 兼容登录                     4000      WINS 在处理命令时遇到错误。                     4001      本地的 WINS 不能删除。                     4002      文件导入操作失败。                     4003      备份操作失败。是否先前已作过完整备份?                     4004      备份操作失败。请检查您备份数据库的目录。                     4005      WINS 数据库中没有这个名称。                     4006      不允许复制一个尚未配置的伙伴。                     4100      DHCP 客户获得一个在网上已被使用的 IP 地址。 直到 DHCP 客户可以获得新的地址前，本地接口将被禁用。                     4200      无法识别传来的 GUID 是否为有效的 WMI 数据提供程序。                     4201      无法识别传来的实例名是否为有效的 WMI 数据提供程序。                     4202      无法识别传来的数据项目标识符是否为有效的 WMI 数据提供程序。                     4203      无法完成 WMI 请求，应该重试一次。                     4204      找不到 WMI 数据提供程序。                     4205      WMI 数据提供程序引用到一个未注册的实例组。                     4206      WMI 数据块或事件通知已启用。                     4207      WMI 数据块不再可用。                     4208      WMI 数据服务无法使用。                     4209      WMI 数据提供程序无法完成要求。                     4210      WMI MOF 信息无效。                     4211      WMI 注册信息无效。                     4212      WMI 数据块或事件通知已禁用。                     4213      WMI 数据项目或数据块为只读。                     4214      WMI 数据项目或数据块不能更改。                     4300      媒体标识符没有表示一个有效的媒体。                     4301      库标识符没有表示一个有效的库。                     4302      媒体缓冲池标识符没有表示一个有效的媒体缓冲池。                     4303      驱动器和媒体不兼容或位于不同的库中。                     4304      媒体目前在脱机库中，您必须联机才能运行这个操作。                     4305      操作无法在脱机库中运行。                     4306      库、驱动器或媒体缓冲池是空的。                     4307      库、磁盘或媒体缓冲池必须是空的，才能运行这个操作。                     4308      在这个媒体缓冲池或库中目前没有可用的媒体。                     4309      这个操作所需的资源已禁用。                     4310      媒体标识符没有表示一个有效的清洗器。                     4311      无法清洗驱动器或不支持清洗。                     4312      对象标识符没有表示一个有效的对象。                     4313      无法读取或写入数据库。                     4314      数据库已满。                     4315      媒体与设备或媒体缓冲池不兼容。                     4316      这个操作所需的资源不存在。                     4317      操作标识符不正确。                     4318      媒体未被安装，或未就绪。                     4319      设备未就绪。                     4320      操作员或系统管理员拒绝了请求。                     4321      驱动器标识符不代表一个有效的驱动器。                     4322      程序库已满。没有可使用的插槽。                     4323      传输程序不能访问媒体。                     4324      无法将媒体加载到驱动器中。                     4325      无法检索有关驱动器的状态。                     4326      无法检索有关插槽的状态。                     4327      无法检索传输的状态。                     4328      因为传输已在使用中，所以无法使用。                     4329      无法打开或关闭弹入/弹出端口。                     4330      因为媒体在驱动器中，无法将其弹出。                     4331      清洗器插槽已被保留。                     4332      没有保留清洗器插槽。                     4333      清洗器墨盒已进行了最大次数的驱动器清洗。                     4334      意外媒体标识号。                     4335      在这个组或源中最后剩下的项目不能被删除。                     4336      提供的消息超过了这个参数所允许的最大尺寸。                     4337      该卷含有系统和页面文件。                     4338      由于库中至少有一个驱动器可以支持该媒体类型，不能从库中删除媒体类型。                     4339      由于没有可以使用的已被启动的驱动器，无法将该脱机媒体装入这个系统。                     4350      远程存储服务无法撤回文件。                     4351      远程存储服务此时不可操作。                     4352      远程存储服务遇到一个媒体错误。                     4354      请键入密码                     4358      请键入用户的密码                     4359      请键入共享资源的密码                     4360      请键入您的密码                     4361      请再键入一次密码以便确认                     4362      请键入用户的旧密码                     4363      请键入用户的新密码                     4364      请键入您的新密码                     4365      请键入复制器服务密码                     4368      请键入您的用户名                     4372      打印作业详细信息                     4378      控制下列正在运行的服务                     4379      统计数据可用于正在运行的下列服务                     4381      此命令的语法是                     4382      此命令的选项是                     4383      请键入主域控制器的名称                     4385      Sunday                     4386      Monday                     4387      Tuesday                     4388      Wednesday                     4389      Thursday                     4390      此文件或目录不是一个重解析点。                     4391      重解析点的属性不能被设置，因为它与已有的属性冲突。                     4392      在重解析点缓冲区中的数据无效。                     4393      在重解析点缓冲区中的标签无效。                     4394      请求中指定的标签和重解析点中的不匹配。                     4395      W                     4396      Th                     4397      F                     4398      S                     4399      Sa                     4401      组名                     4402      注释                     4403      成员                     4406      别名                     4407      注释                     4408      成员                     4411      用户名                     4412      全名                     4413      注释                     4414      用户的注释                     4415      参数                     4416      国家(地区)代码                     4417      权限等级                     4418      操作员权限                     4419      帐户启用                     4420      帐户到期                     4421      上次设置密码                     4422      密码到期                     4423      密码可更改                     4424      允许的工作站                     4425      磁盘空间上限                     4426      无限制                     4427      本地组会员                     4428      域控制器                     4429      登录脚本                     4430      上次登录                     4431      全局组成员                     4432      可允许的登录小时数                     4433      全部                     4434      无                     4436      主目录                     4437      需要密码                     4438      用户可以更改密码                     4439      用户配置文件                     4440      已锁定                     4450      计算机名                     4451      用户名                     4452      软件版本                     4453      工作站活动在                     4454      Windows NT 根目录                     4455      工作站域                     4456      登录域                     4457      其它域                     4458      COM 打开超时 (秒)                     4459      COM 发送计数 (字节)                     4460      COM 发送超时 (毫秒)                     4461      DOS 会话打印超时 (秒)                     4462      错误日志文件大小上限 (K)                     4463      高速缓存上限 (K)                     4464      网络缓冲区数                     4465      字符缓冲区数                     4466      域缓冲区大小                     4467      字符缓冲区大小                     4468      计算机全名                     4469      工作站域 DNS 名称                     4470      Windows 2000                     4481      服务器名称                     4482      服务器注释                     4483      发送管理警报到                     4484      软件版本                     4485      对等服务器                     4486      Windows NT                     4487      服务器等级                     4488      Windows NT Server                     4489      服务器正运行于                     4492      服务器已隐藏                     4500      零备份存储在这个卷上不可用。                     4506      登录的用户数量上限                     4507      同时可并存的管理员数量上限                     4508      资源共享数量上限                     4509      资源连接数量上限                     4510      服务器打开的文件数量上限                     4511      每个会话打开的文件数量上限                     4512      文件锁定数量上限                     4520      空闲的会话时间 (分)                     4526      共享等级                     4527      用户等级                     4530      未限制的服务器                     4570      强制用户在时间到期之后多久必须注销?:                     4571      多少次密码不正确后锁住帐户?:                     4572      密码最短使用期限 (天):                     4573      密码最长使用期限 (天):                     4574      密码长度下限:                     4575      保持的密码历史记录长度:                     4576      计算机角色:                     4577      工作站域的主域控制器:                     4578      锁定阈值:                     4579      锁定持续时间(分):                     4580      锁定观测窗口(分):                     4600      统计开始于                     4601      接受的会话                     4602      会话超时                     4603      会话出错                     4604      发送的 KB                     4605      接收的 KB                     4606      平均响应时间 (毫秒)                     4607      网络错误                     4608      访问的文件                     4609      后台处理的打印作业                     4610      系统出错                     4611      密码违规                     4612      权限违规                     4613      访问的通讯设备                     4614      会话已启动                     4615      重新连接的会话                     4616      会话启动失败                     4617      断开的会话                     4618      网络 I/O 执行                     4619      文件及管道被访问                     4620      时间缓冲区耗尽                     4621      大缓冲区                     4622      请求缓冲区                     4626      已做连接                     4627      连接失败                     4630      接收的字节数                     4631      接收的服务器消息块 (SMB)                     4632      传输的字节数                     4633      传输的服务器消息块 (SMB)                     4634      读取操作                     4635      写入操作                     4636      拒绝原始读取                     4637      拒绝原始写入                     4638      网络错误                     4639      已做连接                     4640      重新连接                     4641      服务器断开                     4642      会话已启动                     4643      会话挂起                     4644      失败的会话                     4645      操作失败                     4646      使用计数                     4647      使用计数失败                     4655      消息名称转发已经取消。                     4661      密码已经更改成功。                     4664      消息已经发给网络上所有的用户。                     4666      消息已经送到此服务器上的所有用户。                     4696      Windows NT Server                     4697      Windows NT Workstation                     4698      MS-DOS 增强型工作站                     4700      服务器名称 注释                     4701      资源共享名 类型 用途 注释                     4706      其它可用的网络                     4710      Disk                     4711      Print                     4712      Comm                     4713      IPC                     4714      状态 本地 远程 网络                     4715      OK                     4716      休止                     4717      已暂停                     4718      断开                     4719      错误                     4720      正在连接                     4721      正在重新连接                     4722      状态                     4723      本地名称                     4724      远程名称                     4725      资源类型                     4726      打开                     4727      连接                     4728      不可用                     4730      共享名 资源 注释                     4731      共享名                     4732      资源                     4733      后台处理                     4734      权限                     4735      最多用户                     4736      无限制                     4737      用户                     4740      识别码 路径 用户名 # 锁定                     4741      文件识别码                     4742      锁定                     4743      权限                     4750      计算机 用户名 客户类型 打开空闲时间                     4751      计算机                     4752      会话时间                     4753      空闲时间                     4754      资源共享名 类型 # 打开                     4755      客户类型                     4756      来宾登录                     4770      脱机缓存被启用:手动恢复                     4771      脱机缓存被启用:自动恢复                     4772      脱机缓存被启用:用户之间没有共享                     4773      脱机缓存被停用                     4774      自动                     4775      手动                     4800      名称                     4801      转发到                     4802      已经从下列位置转发给您                     4803      这台服务器的用户                     4804      用户已经按 Ctrl+Break 中断网络发送。                     4810      名称 作业编号 大小 状态                     4811      作业                     4812      打印                     4815      大小                     4816      状态                     4817      分隔文件                     4818      注释                     4819      优先级                     4820      打印后于                     4821      打印直到                     4822      打印处理程序                     4823      附加信息                     4824      参数                     4825      打印设备                     4826      打印机活动中                     4827      打印机搁置                     4828      打印机出错                     4829      正在删除打印机                     4830      打印机状态未知                     4842      正在提交用户                     4843      通知                     4844      作业数据类型                     4845      作业参数                     4846      正在等候                     4847      搁置于队列                     4848      正在后台处理                     4849      已暂停                     4850      脱机                     4851      错误                     4852      缺纸                     4853      需要干预                     4854      正在打印                     4855      on                     4862      驱动程序                     4930      用户名 类型 日期                     4931      锁定                     4932      服务                     4933      服务器                     4934      服务器已启动                     4935      服务器已暂停                     4936      服务器已继续操作                     4937      服务器已停止                     4938      会话                     4939      登录来宾                     4940      登录用户                     4941      登录管理员                     4942      正常注销                     4943      登录                     4944      注销错误                     4945      注销自动断开                     4946      注销管理员断开                     4947      注销受登录限制                     4948      服务                     4957      帐户                     4964      已修改帐户系统设置                     4965      登录限制                     4966      超过限制: 未知                     4967      超过限制: 登录时间                     4968      超过限制: 帐户过期                     4969      超过限制: 工作站识别码无效                     4970      超过限制: 帐户停用                     4971      超过限制: 帐户已删除                     4972      资源                     4978      密码不正确                     4979      需要管理员特权                     4980      访问                     4984      拒绝访问                     4985      未知                     4986      其它                     4987      持续时间:                     4988      持续时间: 无效                     4989      持续时间: 1 秒以下                     4994      访问结束                     4995      登录到网络                     4996      拒绝登录                     4997      程序 消息 时间                     4999      管理员已解除帐户的锁定状态                     5000      注销网络             更多错误编码请参看 《下篇》。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> debug </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SQL Server 错误代码和解释 (上篇)]]></title>
      <url>/blog/sql-server-state-code-list-1/</url>
      <content type="text"><![CDATA[SQL Server 是高校专业在教学数据库时一定会选用的案例之一，这个数据库是结合微软产品一起使用的，不仅贵，而且不好用。这是在使用之后的心得体会。在代码层面来说，这个是很难使用的。但是，老师说这个以后工作了都会使用到，所以，还是要好好学的。文中罗列了各种状态码的解释，这些对调试SQL Server数据库程序是很有帮助的。            错误码      错误原因说明                  0      操作成功完成。              1      功能错误。              2      系统找不到指定的文件。              3      系统找不到指定的路径。              4      系统无法打开文件。              5      拒绝访问。              6      句柄无效。              7      存储控制块被损坏。              8      存储空间不足，无法处理此命令。              9      存储控制块地址无效。              10      环境错误。              11      试图加载格式错误的程序。              12      访问码无效。              13      数据无效。              14      存储器不足，无法完成此操作。              15      系统找不到指定的驱动器。              16      无法删除目录。              17      系统无法将文件移到不同的驱动器。              18      没有更多文件。              19      介质受写入保护。              20      系统找不到指定的设备。              21      设备未就绪。              22      设备不识别此命令。              23      数据错误 (循环冗余检查)。              24      程序发出命令，但命令长度不正确。              25      驱动器无法找出磁盘上特定区域或磁道的位置。              26      无法访问指定的磁盘或软盘。              27      驱动器找不到请求的扇区。              28      打印机缺纸。              29      系统无法写入指定的设备。              30      系统无法从指定的设备上读取。              31      连到系统上的设备没有发挥作用。              32      进程无法访问文件，因为另一个程序正在使用此文件。              33      进程无法访问文件，因为另一个程序已锁定文件的一部分。              36      用来共享的打开文件过多。              38      到达文件结尾。              39      磁盘已满。              50      不支持网络请求。              51      远程计算机不可用 。              52      在网络上已有重复的名称。              53      找不到网络路径。              54      网络忙。              55      指定的网络资源或设备不再可用。              56      已到达网络 BIOS 命令限制。              57      网络适配器硬件出错。              58      指定的服务器无法运行请求的操作。              59      发生意外的网络错误。              60      远程适配器不兼容。              61      打印机队列已满。              62      无法在服务器上获得用于保存待打印文件的空间。              63      删除等候打印的文件。              64      指定的网络名不再可用。              65      拒绝网络访问。              66      网络资源类型错误。              67      找不到网络名。              68      超过本地计算机网卡的名称限制。              69      超出网络 BIOS 会话限制。              70      远程服务器已暂停，或正在启动过程中。              71      当前已无法再同此远程计算机连接，因为已达到计算机的连接数目极限。              72      已暂停指定的打印机或磁盘设备。              80      文件存在。              82      无法创建目录或文件。              83      INT 24 失败。              84      无法取得处理此请求的存储空间。              85      本地设备名已在使用中。              86      指定的网络密码错误。              87      参数错误。              88      网络上发生写入错误。              89      系统无法在此时启动另一个进程。              100      无法创建另一个系统信号灯。              101      另一个进程拥有独占的信号灯。              102      已设置信号灯且无法关闭。              103      无法再设置信号灯。              104      无法在中断时请求独占的信号灯。              105      此信号灯的前一个所有权已结束。              107      程序停止，因为替代的软盘未插入。              108      磁盘在使用中，或被另一个进程 锁定。              109      管道已结束。              110      系统无法打开指定的 设备或文件。              111      文件名太长。              112      磁盘空间不足。              113      无法再获得内部文件的标识。              114      目标内部文件的标识不正确。              117      应用程序制作的 IOCTL 调用错误。              118      验证写入的切换参数值错误。              119      系统不支持请求的命令。              120      此功能只被此系统支持。              121      信号灯超时时间已到。              122      传递到系统调用的数据区太小。              123      文件名、目录名或卷标语法不正确。              124      系统调用级别错误。              125      磁盘没有卷标。              126      找不到指定的模块。              127      找不到指定的程序。              128      没有等候的子进程。              130      试图使用操作(而非原始磁盘 I/O)的已打开磁盘分区的文件句柄。              131      试图移动文件指针到文件开头之前。              132      无法在指定的设备或文件上设置文件指针。              133      包含先前加入驱动器的驱动器无法使用 JOIN 或 SUBST 命令。              134      试图在已被合并的驱动器上使用 JOIN 或 SUBST 命令。              135      试图在已被合并的驱动器上使用 JOIN 或 SUBST 命令。              136      系统试图解除未合并驱动器的 JOIN。              137      系统试图解除未替代驱动器的 SUBST。              138      系统试图将驱动器合并到合并驱动器上的目录。              139      系统试图将驱动器替代为替代驱动器上的目录。              140      系统试图将驱动器合并到替代驱动器上的目录。              141      系统试图替代驱动器为合并驱动器上的目录。              142      系统无法在此时运行 JOIN 或 SUBST。              143      系统无法将驱动器合并到或替代为相同驱动器上的目录。              144      目录并非根目录下的子目录。              145      目录非空。              146      指定的路径已在替代中使用。              147      资源不足，无法处理此命令。              148      指定的路径无法在此时使用。              149      企图将驱动器合并或替代为驱动器上目录是上一个替代的目标的驱动器。              150      系统跟踪信息未在 CONFIG.SYS 文件中指定，或不允许跟踪。              151      为 DosMuxSemWait 指定的信号灯事件个数错误。              152      DosMuxSemWait 不可运行。已设置过多的信号灯。              153      DosMuxSemWait 清单错误。              154      输入的卷标超过目标文件系统的 长度限制              155      无法创建另一个线程。              156      接收进程已拒绝此信号。              157      段已被放弃且无法锁定。              158      段已解除锁定。              159      线程标识的地址错误。              160      传递到 DosExecPgm 的参数字符串错误。              161      指定的路径无效。              162      信号已暂停。              164      无法在系统中创建更多的线程。              167      无法锁定文件区域。              170      请求的资源在使用中。              173      对于提供取消区域进行锁定的请求不明显。              174      文件系统不支持锁定类型的最小单元更改。              180      系统检测出错误的段号。              183      当文件已存在时，无法创建该文件。              186      传递的标志错误。              187      找不到指定的系统信号灯名称。              196      操作系统无法运行此应用程序。              197      操作系统当前的配置不能运行此应用程序。              199      操作系统无法运行此应用程序。              200      代码段不可大于或等于 64K。              203      操作系统找不到已输入的 环境选项。              205      命令子树中的进程 没有信号处理程序。              206      文件名或扩展名太长。              207      第 2 环堆栈已被占用。              208      没有正确输入文件名通配符 * 或 ?，或指定过多的文件名通配符。              209      正在发送的信号错误。              210      无法设置信号处理程序。              212      段已锁定且无法重新分配。              214      连到该程序或动态链接模块的动态链接模块太多。              215      无法嵌套调用 LoadModule。              230      管道状态无效。              231      所有的管道实例都在使用中。              232      管道正在关闭中。              233      管道的另一端上无任何进程。              234      更多数据可用。              240      取消会话。              254      指定的扩展属性名无效。              255      扩展属性不一致。              258      等待的操作过时。              259      没有可用的数据了。              266      无法使用复制功能。              267      目录名无效。              275      扩展属性在缓冲区中不适用。              276      装在文件系统上的扩展属性文件已损坏。              277      扩展属性表格文件已满。              278      指定的扩展属性句柄无效。              282      装入的文件系统不支持扩展属性。              288      企图释放并非呼叫方所拥有的多用户终端运行程序。              298      发向信号灯的请求过多。              299      仅完成部分的 ReadProcessMemoty 或 WriteProcessMemory 请求。              300      操作锁定请求被拒绝。              301      系统接收了一个无效的操作锁定确认。              487      试图访问无效的地址。              534      算术结果超过 32 位。              535      管道的另一端有一进程。              536      等候打开管道另一端的进程。              994      拒绝访问扩展属性。              995      由于线程退出或应用程序请求，已放弃 I/O 操作。              996      重叠 I/O 事件不在信号状态中。              997      重叠 I/O 操作在进行中。              998      内存分配访问无效。              999      错误运行页内操作。              1001      递归太深；栈溢出。              1002      窗口无法在已发送的消息上操作。              1003      无法完成此功能。              1004      无效标志。              1005      此卷不包含可识别的文件系统。 请确定所有请求的文件系统驱动程序已加载，且此卷未损坏。              1006      文件所在的卷已被外部改变，因此打开的文件不再有效。              1007      无法在全屏幕模式下运行请求的操作。              1008      试图引用不存在的令牌。              1009      配置注册表数据库损坏。              1010      配置注册表项无效。              1011      无法打开配置注册表项。              1012      无法读取配置注册表项。              1013      无法写入配置注册表项。              1014      注册表数据库中的某一文件必须使用记录或替代复制来恢复。恢复成功完成。              1015      注册表损坏。包含注册表数据的某一文件结构损坏，或系统的文件内存映像损坏，或因为替代副本、日志缺少或损坏而无法恢复文件。              1016      由注册表启动的 I/O 操作恢复失败。注册表无法读入、写出或清除任意一个包含注册表系统映像的文件。              1017      系统试图加载或还原文件到注册表，但指定的文件并非注册表文件格式。              1018      试图在标记为删除的注册表项上运行不合法的操作。              1019      系统无法配置注册表日志中所请求的空间。              1020      无法在已有子项或值的注册表项中创建符号链接。              1021      无法在易变父项下创建稳定子项。              1022      通知更改请求正在完成中，且信息并未返回到呼叫方的缓冲区中。当前呼叫方必须枚举文件来查找更改。              1051      已发送停止控制到服务，该服务被其它正在运行的服务所依赖。              1052      请求的控件对此服务无效              1053      服务并未及时响应启动或控制请求。              1054      无法创建此服务的线程。              1055      锁定服务数据库。              1056      服务的实例已在运行中。              1057      帐户名无效或不存在，或者密码对于指定的帐户名无效。              1058      无法启动服务，原因可能是它被禁用或与它相关联的设备没有启动。              1059      指定了循环服务依存。              1060      指定的服务并未以已安装的服务存在。              1061      服务无法在此时接受控制信息。              1062      服务未启动。              1063      服务进程无法连接到服务控制器上。              1064      当处理控制请求时，在服务中发生异常。              1065      指定的数据库不存在。              1066      服务已返回特定的服务错误码。              1067      进程意外终止。              1068      依存服务或组无法启动。              1069      由于登录失败而无法启动服务。              1070      启动后，服务停留在启动暂停状态。              1071      指定的服务数据库锁定无效。              1072      指定的服务已标记为删除。              1073      指定的服务已存在。              1074      系统当前以最新的有效配置运行。              1075      依存服务不存在，或已被标记为删除。              1076      已接受使用当前引导作为最后的有效控制设置。              1077      上次启动之后，仍未尝试引导服务。              1078      名称已用作服务名或服务显示名。              1079      此服务的帐户不同于运行于同一进程上的其它服务的帐户。              1080      只能为 Win32 服务设置失败操作，不能为驱动程序设置。              1081      这个服务所运行的处理和服务控制管理器相同。 所以，如果服务处理程序意外中止的话，服务控制管理器无法进行任何操作。              1082      这个服务尚未设置恢复程序。              1083      配置成在该可执行程序中运行的这个服务不能执行该服务。              1100      已达磁带的实际结尾。              1101      磁带访问已达文件标记。              1102      已达磁带或磁盘分区的开头。              1103      磁带访问已达一组文件的结尾。              1104      磁带上不再有任何数据。              1105      磁带无法分区。              1106      在访问多卷分区的新磁带时，当前的块大小不正确。              1107      当加载磁带时，找不到分区信息。              1108      无法锁定媒体弹出功能。              1109      无法卸载介质。              1110      驱动器中的介质可能已更改。              1111      复位 I/O 总线。              1112      驱动器中没有媒体。              1113      在多字节的目标代码页中，没有此 Unicode 字符可以映射到的字符。              1114      动态链接库 (DLL) 初始化例程失败。              1115      系统关机正在进行。              1116      因为没有任何进行中的关机过程，所以无法中断系统关机。              1117      因为 I/O 设备错误，所以无法运行此项请求。              1118      没有串行设备被初始化成功。串行驱动程序将卸载。              1119      无法打开正在与其他设备共享中断请求(IRQ)的设备。至少有一个使用该 IRQ 的其他设备已打开。              1120      序列 I/O 操作已由另一个串行口的写入完成。 (IOCTL_SERIAL_XOFF_COUNTER 已达零。)              1121      因为已过超时时间，所以串行 I/O 操作完成。 (IOCTL_SERIAL_XOFF_COUNTER 未达零。)              1122      在软盘上找不到 ID 地址标记。              1123      软盘扇区 ID 字符域与软盘控制器磁道地址不相符。              1124      软盘控制器报告软盘驱动程序不能识别的错误。              1125      软盘控制器返回与其寄存器中不一致的结果。              1126      当访问硬盘时，重新校准操作失败，重试仍然失败。              1127      当访问硬盘时，磁盘操作失败，重试仍然失败。              1128      当访问硬盘时，即使失败，仍须复位磁盘控制器。              1129      已达磁带结尾。              1130      服务器存储空间不足，无法处理此命令。              1131      检测出潜在的死锁状态。              1132      指定的基址或文件偏移量没有适当对齐。              1140      改变系统供电状态的尝试被另一应用程序或驱动程序否决。              1141      系统 BIOS 改变系统供电状态的尝试失败。              1142      试图在一文件上创建超过系统允许数额的链接。              1150      指定程序要求更新的 Windows 版本。              1151      指定程序不是 Windows 或 MS-DOS 程序。              1152      只能启动该指定程序的一个实例。              1153      该指定程序适用于旧的 Windows 版本。              1154      执行该应用程序所需的库文件之一被损坏。              1155      没有应用程序与此操作的指定文件有关联。              1156      在输送指令到应用程序的过程中出现错误。　              1157      执行该应用程序所需的库文件之一无法找到。              1158      当前程序已使用了 Window 管理器对象的系统允许的所有句柄。              1159      消息只能与同步操作一起使用。              1160      指出的源元素没有媒体。              1161      指出的目标元素已包含媒体。              1162      指出的元素不存在。              1163      指出的元素是未显示的存储资源的一部分。              1164      显示设备需要重新初始化，因为硬件有错误。              1165      设备显示在尝试进一步操作之前需要清除。              1166      设备显示它的门仍是打开状态。              1167      设备没有连接。              1168      找不到元素。              1169      索引中没有同指定项相匹配的项。              1170      在对象上不存在指定的属性集。              1171      传递到 GetMouseMovePoints 的点不在缓冲区中。              1172      跟踪(工作站)服务没运行。              1173      找不到卷 ID。              1175      无法删除要被替换的文件。              1176      无法将替换文件移到要被替换的文件。要被替换的文件保持原来的名称。              1177      无法将替换文件移到要被替换的文件。要被替换的文件已被重新命名为备份名称。              1178      卷更改记录被删除。              1179      卷更改记录服务不处于活动中。              1180      找到一份文件，但是可能不是正确的文件。              1181      日志项从日志中被删除。              1200      指定的设备名无效。              1201      设备当前未连接上，但其为一个记录连接。              1202      企图记录先前已被记录的设备。              1203      无任何网络提供程序接受指定的网络路径。              1204      指定的网络提供程序名称无效。              1205      无法打开网络连接配置文件。              1206      网络连接配置文件损坏。              1207      无法枚举空载体。              1208      发生扩展错误。              1209      指定的组名格式无效。              1210      指定的计算机名格式无效。              1211      指定的事件名格式无效。              1212      指定的域名格式无效。              1213      指定的服务名格式无效。              1214      指定的网络名格式无效。              1215      指定的共享名格式无效。              1216      指定的密码格式无效。              1217      指定的消息名格式无效。              1218      指定的消息目标格式无效。              1219      提供的凭据与已存在的凭据集冲突。              1220      企图创建网络服务器的会话，但已对该服务器创建过多的会话。              1221      工作组或域名已由网络上的另一部计算机使用。              1222      网络未连接或启动。              1223      操作已被用户取消。              1224      请求的操作无法在使用用户映射区域打开的文件上执行。              1225      远程系统拒绝网络连接。              1226      网络连接已被适当地关闭了。              1227      网络传输终结点已有与其关联的地址。              1228      地址仍未与网络终结点关联。              1229      企图在不存在的网络连接上进行操作。              1230      企图在使用中的网络连接上进行无效的操作。              1231      不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。              1232      不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。              1233      不能访问网络位置。有关网络排除故障的信息，请参阅 Windows 帮助。              1234      没有任何服务正在远程系统上的目标网络终结点上操作。              1235      请求被终止。              1236      由本地系统终止网络连接。              1237      操作无法完成。应该重试。              1238      因为已达到此帐户的最大同时连接数限制，所以无法连接服务器。              1239      试图在这个帐户未被授权的时间内登录。              1240      此帐户并未得到从这个工作站登录的授权。              1241      请求的操作不能使用这个网络地址。              1242      服务器已经注册。              1243      指定的服务不存在。              1244      因为用户还未被验证，不能执行所要求的操作。              1245      因为用户还未登录网络，不能执行所要求的操作。 指定的服务不存在。              1246      正在继续工作。              1247      试图进行初始操作，但是初始化已完成。              1248      没有更多的本地设备。　              1249      指定的站点不存在。              1250      具有指定名称的域控制器已经存在。              1251      只有连接到服务器上时，该操作才受支持。              1252      即使没有改动，组策略框架也应该调用扩展。              1253      指定的用户没有一个有效的配置文件。              1254      Microsoft Small Business Server 不支持此操作。              1300      并非所有被引用的特权都指派给呼叫方。              1301      帐户名和安全标识间的某些映射未完成。              1302      没有为该帐户特别设置系统配额限制。              1303      没有可用的加密密钥。返回了一个已知加密密钥。              1304      密码太复杂，无法转换成 LAN Manager 密码。返回的 LAN Manager 密码为空字符串。              1305      修订级别未知。              1306      表明两个修订级别是不兼容的。              1307      这个安全标识不能指派为此对象的所有者。              1308      这个安全标识不能指派为对象的主要组。              1309      当前并未模拟客户的线程试图操作模拟令牌。              1310      组可能未被禁用。              1311      当前没有可用的登录服务器来服务登录请求。              1312      指定的登录会话不存在。可能已被终止。              1313      指定的特权不存在。              1314      客户没有所需的特权。              1315      提供的名称并非正确的帐户名形式。              1316      指定的用户已存在。              1317      指定的用户不存在。              1318      指定的组已存在。              1319      指定的组不存在。              1320      指定的用户帐户已是指定组的成员，或是因为组包含成员所以无法删除指定的组。              1321      指定的用户帐户不是指定组帐户的成员。              1322      无法禁用或删除最后剩余的系统管理帐户。              1323      无法更新密码。提供作为当前密码的值不正确。              1324      无法更新密码。提供给新密码的值包含密码中不允许的值。              1325      无法更新密码。为新密码提供的值不符合字符域的长度、复杂性或历史要求。              1326      登录失败: 未知的用户名或错误密码。              1327      登录失败: 用户帐户限制。              1328      登录失败: 违反帐户登录时间限制。              1329      登录失败: 不允许用户登录到此计算机。              1330      登录失败: 指定的帐户密码已过期。              1331      登录失败: 禁用当前的帐户。              1332      帐户名与安全标识间无任何映射完成。              1333      一次请求过多的本地用户标识符(LUIDs)。              1334      无更多可用的本地用户标识符(LUIDs)。              1335      对于该特别用法，安全 ID 的次级授权部分无效。              1336      访问控制列表(ACL)结构无效。              1337      安全 ID 结构无效。              1338      安全描述符结构无效。              1340      无法创建固有的访问控制列表(ACL)或访问控制项目(ACE)。              1341      服务器当前已禁用。              1342      服务器当前已启用。              1343      提供给识别代号颁发机构的值为无效值。              1344      无更多可用的内存以更新安全信息。              1345      指定属性无效，或与整个群体的属性不兼容。              1346      指定的模拟级别无效， 或所提供的模拟级别无效。              1347      无法打开匿名级安全令牌。              1348      请求的验证信息类别无效。              1349      令牌的类型对其尝试使用的方法不适当。              1350      无法在与安全性无关联的对象上运行安全性操作。              1351      未能从域控制器读取配置信息，或者是因为机器不可使用，或者是访问被拒绝。              1352      安全帐户管理器(SAM)或本地安全颁发机构(LSA)服务器处于运行安全操作的错误状态。              1353      域处于运行安全操作的错误状态。              1354      此操作只对域的主要域控制器可行。              1355      指定的域不存在，或无法联系。              1356      指定的域已存在。              1357      试图超出每服务器域个数的限制。              1358      无法完成请求操作，因为磁盘上的严重介质失败或数据结构损坏。              1359      出现了内部错误。              1360      通用访问类型包含于已映射到非通用类型的访问掩码中。              1361      安全描述符格式不正确 (绝对或自相关的)。              1362      请求操作只限制在登录进程中使用。调用进程未注册为一个登录进程。              1363      无法使用已在使用中的标识启动新的会话。              1364      未知的指定验证数据包。              1365      登录会话并非处于与请求操作一致的状态中。              1366      登录会话标识已在使用中。              1367      登录请求包含无效的登录类型值。              1368      在使用命名管道读取数据之前，无法经由该管道模拟。              1369      注册表子树的事务处理状态与请求状态不一致。              1370      安全性数据库内部出现损坏。              1371      无法在内置帐户上运行此操作。              1372      无法在内置特殊组上运行此操作。              1373      无法在内置特殊用户上运行此操作。              1374      无法从组中删除用户，因为当前组为用户的主要组。              1375      令牌已作为主要令牌使用。              1376      指定的本地组不存在。              1377      指定的帐户名不是本地组的成员。              1378      指定的帐户名已是本地组的成员。              1379      指定的本地组已存在。              1380      登录失败: 未授予用户在此计算机上的请求登录类型。              1381      已超过在单一系统中可保存机密的最大个数。              1382      机密的长度超过允许的最大长度。              1383      本地安全颁发机构数据库内部包含不一致性。              1384      在尝试登录的过程中，用户的安全上下文积累了过多的安全标识。              1385      登录失败: 未授予用户在此计算机上的请求登录类型。              1386      更改用户密码时需要交叉加密密码。              1387      由于成员不存在，无法将成员添加到本地组中，也无法从本地组将其删除。              1388      无法将新成员加入到本地组中，因为成员的帐户类型错误。              1389      已指定过多的安全标识。              1390      更改此用户密码时需要交叉加密密码。              1391      表明 ACL 未包含任何可承继的组件。              1392      文件或目录损坏且无法读取。              1393      磁盘结构损坏且无法读取。              1394      无任何指定登录会话的用户会话项。              1395      正在访问的服务有连接数目标授权限制。 这时候已经无法再连接，原因是已经到达可接受的连接数目上限。              1396      登录失败: 该目标帐户名称不正确。              1397      相互身份验证失败。该服务器在域控制器的密码过期。              1398      在客户机和服务器之间有一个时间差。              1400      无效的窗口句柄。              1401      无效的菜单句柄。              1402      无效的光标句柄。              1403      无效的加速器表句柄。              1404      无效的挂钩句柄。              1405      无效的多重窗口位置结构句柄。              1406      无法创建最上层子窗口。              1407      找不到窗口类别。              1408      无效窗口；它属于另一线程。              1409      热键已注册。              1410      类别已存在。              1411      类别不存在。              1412      类别仍有打开的窗口。              1413      无效索引。              1414      无效的图标句柄。              1415      使用专用 DIALOG 窗口字。              1416      找不到列表框标识。              1417      找不到通配字符。              1418      线程没有打开的剪贴板。              1419      没有注册热键。              1420      窗口不是合法的对话窗口。              1421      找不到控件 ID。              1422      因为没有编辑控制，所以组合框的消息无效。              1423      窗口不是组合框。              1424      高度必须小于 256。              1425      无效的设备上下文(DC)句柄。              1426      无效的挂接程序类型。              1427      无效的挂接程序。              1428      没有模块句柄无法设置非本机的挂接。              1429      此挂接程序只可整体设置。              1430      Journal Hook 程序已安装。              1431      挂接程序尚未安装。              1432      单一选择列表框的无效消息。              1433      LB_SETCOUNT 发送到非被动的列表框。              1434      此列表框不支持 Tab 键宽度。              1435      无法毁坏由另一个线程创建的对象。              1436      子窗口没有菜单。              1437      窗口没有系统菜单。              1438      无效的消息对话框样式。              1439      无效的系统范围内的 (SPI_*) 参数。              1440      已锁定屏幕。              1441      多重窗口位置结构中窗口的所有句柄必须具有相同的上层。              1442      窗口不是子窗口。              1443      无效的 GW_* 命令。              1444      无效的线程标识。              1445      无法处理非多重文档界面 (MDI) 窗口中的消息。              1446      弹出式菜单已经激活。              1447      窗口没有滚动条。              1448      滚动条范围不可大于 MAXLONG。              1449      无法以指定的方式显示或删除窗口。              1450      系统资源不足，无法完成请求的服务。              1451      系统资源不足，无法完成请求的服务。              1452      系统资源不足，无法完成请求的服务。              1453      配额不足，无法完成请求的服务。              1454      配额不足，无法完成请求的服务。              1455      页面文件太小，无法完成操作。              1456      找不到菜单项。              1457      键盘布局句柄无效。              1458      不允许使用挂钩类型。              1459      该操作需要交互式窗口工作站。              1460      由于超时时间已过，该操作返回。              1461      无效监视器句柄。              1500      事件日志文件损坏。              1501      无法打开事件日志文件，事件日志服务没有启动。              1502      事件日志文件已满。              1503      事件日志文件已在读取间更改。              1601      无法访问 Windows 安装服务。请与技术支持人员联系，确认 Windows 安装服务是否注册正确。              1602      用户取消了安装。              1603      安装时发生严重错误              1604      安装已挂起，未完成。              1605      这个操作只对当前安装的产品有效。              1606      功能 ID 未注册。              1607      组件 ID 并未注册。              1608      未知属性。              1609      句柄处于不正确的状态。              1610      这个产品的配置数据已损坏。请与技术支持人员联系。              1611      组件限制语不存在。              1612      这个产品的安装来源无法使用。请验证来源是否存在，是否可以访问。              1613      Windows 安装服务无法安装这个安装程序包。您必须安装含有 Windows 安装服务新版本的 Windows Service Park。              1614      没有卸载产品。              1615      SQL 查询语法不正确或不被支持。              1616      记录字符域不存在。              1617      设备已被删除.              1618      正在进行另一个安装操作。请在继续这个安装操作之前完成那个操作。              1619      未能打开这个安装程序包。请验证程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是有效的 Windows 安装服务程序包。              1620      未能打开这个安装程序包。请与应用程序供应商联系，验证这是否是有效的 Windows 安装服务程序包。              1621      启动 Windows 安装服务用户界面时有错误。请与技术支持人员联系。              1622      打开安装日志文件的错误。请验证指定的日志文件位置是否存在，是否可以写入。              1623      安装程序包的语言不受系统支持。              1624      应用变换时的错误。请验证指定的变换路径是否有效。              1625      系统策略禁止这个安装。请与系统管理员联系。              1626      无法执行函数。              1627      执行期间，函数出了问题。              1628      指定了无效的或未知的表格。              1629      提供的数据类型不对。              1630      这个类型的数据不受支持。              1631      Windows 安装服务未能启动。请与技术支持人员联系。              1632      临时文件夹已满或无法使用。请验证临时文件夹是否存在，是否可以写入。              1633      这个处理器类型不支持该安装程序包。请与产品供应商联系。              1634      组件没有在这台计算机上使用。              1635      无法打开修补程序包。请验证修补程序包是否存在，是否可以访问；或者与应用程序供应商联系，验证这是否是 Windows 安装服务的修补程序包。              1636      无法打开修补程序包。请与应用程序供应商联系，验证这是否是 Windows 安装服务的修补程序包。              1637      Windows 安装服务无法处理这个插入程序包。您必须安装含有 Windows 安装服务新版本的 Windows Service Pack。              1638      已安装这个产品的另一个版本。这个版本的安装无法继续。要配置或删除这个产品的现有版本，请用“控制面板”上的“添加/删除程序”。              1639      无效的命令行参数。有关详细的命令行帮助，请查阅 Windows 安装服务的 SDK。              1640      在终端服务远程会话期间，只有管理员有添加、删除或配置服务器软件的权限。如果您要在服务器上安装或配置软件，请与网络管理员联系。              1641      要求的操作已成功结束。要使改动生效，必须重新启动系统。              1642      Windows 安装服务无法安装升级修补程序，因为被升级的程序可能会丢失或是升级修补程序可能更新此程序的一个不同版本。请确认要被升级的程序在您的计算机上且您的升级修补程序是正确的。              1700      串绑定无效。              1701      绑定句柄类型不正确。              1702      绑定句柄无效。              1703      不支持 RPC 协议序列。              1704      RPC 协议序列无效。              1705      字符串通用唯一标识 (UUID) 无效。              1706      终结点格式无效。              1707      网络地址无效。              1708      找不到终结点。              1709      超时值无效。              1710      找不到对象通用唯一标识(UUID)。              1711      对象通用唯一标识 (UUID)已注册。              1712      类型通用唯一标识(UUID)已注册。              1713      RPC 服务器已在侦听。              1714      未登记任何协议序列。              1715      RPC 服务器未在侦听。              1716      未知的管理器类型。              1717      未知的界面。              1718      没有任何链接。              1719      无任何协议顺序。              1720      无法创建终结点。              1721      资源不足，无法完成此操作。              1722      RPC 服务器不可用。              1723      RPC 服务器过忙以致无法完成此操作。              1724      网络选项无效。              1725      在此线程中，没有使用中的远程过程调用。              1726      远程过程调用失败。              1727      远程过程调用失败且未运行。              1728      远程过程调用(RPC)协议出错。              1730      RPC 服务器不支持传送语法。              1732      不支持通用唯一标识(UUID)类型。              1733      标记无效。              1734      数组边界无效。              1735      链接不包含项目名称。              1736      名称语法无效。              1737      不支持名称语法。              1739      没有可用来创建通用唯一标识 (UUID)的网络地址。              1740      终结点是一份备份。              1741      未知的验证类型。              1742      调用的最大个数太小。              1743      字符串太长。              1744      找不到 RPC 协议顺序。              1745      过程号超出范围。              1746      绑定不包含任何验证信息。              1747      未知的验证服务。              1748      未知的验证级别。              1749      安全上下文无效。              1750      未知的授权服务。              1751      项目无效。              1752      服务器终结点无法运行操作。              1753      终结点映射表中无更多的可用终结点。              1754      未导出任何界面。              1755      项目名称不完整。              1756      版本选项无效。              1757      没有其他成员。              1758      没有内容未导出。              1759      接口没有找到。              1760      项目已存在。              1761      找不到项目。              1762      无可用的名称服务。              1763      网络地址族无效。              1764      不支持请求的操作。              1765      无可用的安全上下文以允许模拟。              1766      远程过程调用(RPC)中发生内部错误。              1767      RPC 服务器试图以零除整数。              1768      RPC 服务器中发生地址错误。              1769      RPC 服务器上的浮点操作导至以零做除数。              1770      RPC 服务器上发生浮点下溢。              1771      RPC 服务器上发生浮点上溢。              1772      自动句柄绑定的可用 RPC 服务器列表已用完。              1773      无法打开字符翻译表文件。              1774      包含字符翻译表的文件少于512 字节。              1775      在远程过程调用时，将空的上下文句柄从客户传递到主机。              1777      在远程过程调用时，上下文句柄已更改。              1778      传递到远程过程调用的绑定句柄不相符。              1779      承接体无法获得远程过程调用句柄。              1780      传递空引用指针到承接体。              1781      列举值超出范围。              1782      字节计数太小。              1783      承接体接收到坏数据。              1784      提供给请求操作的用户缓冲区无效。              1785      磁盘媒体无法识别。可能未被格式化。              1786      工作站没有信任机密。              1787      服务器上的安全数据库没有此工作站信任关系的计算机帐户。              1788      主域和受信域间的信任关系失败。              1789      此工作站和主域间的信任关系失败。              1790      网络登录失败。              1791      此线程的远程过程调用已在进行中。              1792      试图登录，但是网络登录服务没有启动。              1793      用户帐户到期。              1794      转发程序已被占用且无法卸载。              1795      指定的打印机驱动程序已安装。              1796      指定的端口未知。              1797      未知的打印机驱动程序。              1798      未知的打印机处理器。              1799      指定的分隔页文件无效。              1800      指定的优先级无效。              1801      打印机名无效。              1802      打印机已存在。              1803      打印机命令无效。              1804      指定的数据类型无效。              1805      指定的环境无效。              1806      没有更多的绑定。              1807      所用帐户为域间信任帐户。请使用您的全局用户帐户或本地用户帐户来访问这台服务器。              1808      所用帐户是一个计算机帐户。使用您的全局用户帐户或本地用户帐户来访问此服务器。              1809      已使用的帐户为服务器信任帐户。使用您的全局用户帐户或本地用户帐户来访问此服务器。              1810      指定域的名称或安全标识(SID)与该域的信任信息不一致。              1811      服务器在使用中且无法卸载。              1812      指定的映像文件不包含资源区域。              1813      找不到映像文件中指定的资源类型。              1814      找不到映像文件中指定的资源名。              1815      找不到映像文件中指定的资源语言标识。              1816      配额不足，无法处理此命令。              1817      未登记任何界面。              1818      远程过程调用被取消。              1819      绑定句柄不包含所有需要的信息。              1820      在远程过程调用过程中通讯失败。              1821      不支持请求的验证级别。              1822      未登记任何主名称。              1823      指定的错误不是有效的 Windows RPC 错误码。              1824      已配置一个只在这部计算机上有效的 UUID。              1825      发生一个安全包特有的错误。              1826      线程未取消。              1827      无效的编码/解码句柄操作。              1828      序列化包装的版本不兼容。              1829      RPC 承接体的版本不兼容。              1830      RPC 管道对象无效或已损坏。              1831      试图在 RPC 管道物件上进行无效操作。              1832      不被支持的 RPC 管道版本。              1898      找不到该组成员。              1899      无法创建终结点映射表数据库项。              1900      对象通用唯一标识 (UUID) 为 nil UUID。              1901      指定的时间无效。              1902      指定的格式名称无效。              1903      指定的格式大小无效。              1904      指定的打印机句柄正等候在              1905      已删除指定的打印机。              1906      打印机的状态无效。              1907      在第一次登录之前，必须更改用户密码。              1908      找不到此域的域控制器。              1909      引用的帐户当前已锁定，且可能无法登录。              1910      没有发现指定的此对象导出者              1911      没有发现指定的对象。              1912      没有发现指定的对象解析器。              1913      一些待发数据仍停留在请求缓冲区内。              1914      无效的异步远程过程调用句柄。              1915      这个操作的异步 RPC 调用句柄不正确。              1916      RPC 管道对象已经关闭。              1917      在 RPC 调用完成之前全部的管道都已处理完成。              1918      没有其他可用的数据来自 RPC 管道。              1919      这个机器没有可用的站点名。              1920      系统无法访问此文件。              1921      系统无法辨识文件名。              1922      项目不是所要的类型。              1923      无法将所有对象的 UUID 导出到指定的项。              1924      无法将界面导出到指定的项。              1925      无法添加指定的配置文件项。              1926      无法添加指定的配置文件元素。              1927      无法删除指定的配置文件元素。              1928      无法添加组元素。              1929      无法删除组元素。              2000      无效的像素格式。      更多错误编码请参看 《中篇》、《下篇》。]]></content>
      <categories>
        
          <category> code </category>
        
      </categories>
      <tags>
        
          <tag> database </tag>
        
          <tag> debug </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[操作系统 32位和64位]]></title>
      <url>/blog/os-32-64-bit/</url>
      <content type="text"><![CDATA[两者之间存在的“五大不同”。与此同时，着重说明Microsoft Windows64位（x64）操作系统，相对于32位（x86）操作系统的最大优势和劣势是什么？第一，设计初衷不同64位操作系统的设计初衷是：满足机械设计和分析、三维动画、视频编辑和创作，以及科学计算和高性能计算应用程序等领域中需要大量内存和浮点性能的客户需求。换句简明的话说就是：它们是高科技人员使用本行业特殊软件的运行平台。而32位操作系统是为普通用户设计的。第二，要求配置不同64位操作系统只能安装在64位电脑上(CPU必须是64位的)。同时需要安装64位常用软件以发挥64位（x64）的最佳性能。32位操作系统则可以安装在32位(32位CPU)或64位(64位CPU)电脑上。当然，32位操作系统安装在64位电脑上，其硬件恰似“大马拉小车”：64位效能就会大打折扣。第三，运算速度不同64位CPU GPRs(General-Purpose Registers，通用寄存器)的数据宽度为64位，64位指令集可以运行64位数据指令，也就是说处理器一次可提取64位数据(只要两个指令，一次提取8个字节的数据)，比32位(需要四个指令,一次提取4个字节的数据)提高了一倍，理论上性能会相应提升1倍。第四，寻址能力不同64位处理器的优势还体现在系统对内存的控制上。由于地址使用的是特殊的整数，因此一个ALU（算术逻辑运算器）和寄存器可以处理更大的整数，也就是更大的地址。比如，Windows Vista x64 Edition支持多达128 GB的内存和多达16 TB的虚拟内存，而32位CPU和操作系统最大只可支持4G内存。第五，软件普及不同目前，64位常用软件比32位常用软件，要少得多的多。道理很简单：使用64位操作系统的用户相对较少。因此，软件开发商必须考虑“投入产出比”，将有限资金投入到更多使用群体的软件之中。这也是为什么64位软件价格相对昂贵的重要原因(将成本摊入较少的发售之中)。总而言之，Microsoft Windows 64位操作系统，必须“上”靠64位主机硬件的支撑，“下”靠64位常用软件的协助，才能将64位的优势发挥到极致，“三位一体”缺一不可(道理很简单：操作系统只是承上启下的运行平台)。至于64位电脑可以安装32位操作系统，64位操作系统可以安装32位软件，那是设计上的“向下兼容”，不是64位设计初衷的本来含义(如上所述)。附言1、64位电脑虽然可以安装32位操作系统，但是32位电脑绝对不能安装64位操作系统。这点至关重要务必牢记，以避免盲目下载和安装。2、在64位电脑运行的32位操作系统上，不能采取硬盘安装方式安装64位操作系统。如若安装，首选光盘格式化安装方式，也可采用比较繁琐的DOS安装方式。3、使用虚拟机安装操作系统，实际上就是在目前运行的操作系统上安装软件。因此，在32位操作系统上不能虚拟安装64位操作系统。即便采取“曲线”方式勉强安装，其实已经脱离了底层设备的支持，是毫无疑义的。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
          <tag> windows </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[VC++6.0 MFC编程心得小结]]></title>
      <url>/blog/vc-6-mfc-develop-summary/</url>
      <content type="text"><![CDATA[作为一个正经的科班出身软件工程专业者，想必都知道什么是VC++6.0。这个充满神奇的工具。而作为专业教学课的首选编程IDE，它有着不可撼动的地位。博主不知道别家院系使用何种启蒙工具，反正博主就是这个工具启蒙的。对它，有着又爱又恨得情怀。数据库一个程序的最基本功能有输入、查询、修改、删除、保存、打印，均与数据库有关。而对数据库的基本操作使用最频繁，以Access 为例：1、用程序创建Access 数据库文件：手工创建数据文件的方法大家并不陌生，如果用程序创建有时候也需要，下面就是其中一种方法，可以使用ADOX::CatalogPtr来创建mdb文件。用下面“配置设置文件”文件方法设置数据库的参数，配置数据文件的名称、密码、ID和路径，在有安装程序的情况下需要它。ADOX的建库，它是在没有数据库文件的情况下，用ADOX的目录指针CatalogPtr来创建ACCESS数据库文件，如下：BOOL CRecord::UseADOXCatalogPtrCreatAccessDB(){       CString str=DBPath + DBName;         //数据库的路径和名称       CString strPassword=DBPasswd;         //数据库的密码       CString strcnn=_T("Provider=Microsoft.JET.OLEDB.4.0;Data source ="+str+";\              Jet OLEDB:DatabasePassword="+strPassword); //数据库的字串                    //使用ADOX::CatalogPtr来创建mdb文件：       HRESULT hr = S_OK;       hr=::CoInitialize(NULL);       if(SUCCEEDED(hr))       {              HRESULT hr = S_OK;              try              {                     ADOX::_CatalogPtrm_pCatalog = NULL;                     hr=m_pCatalog.CreateInstance(__uuidof(ADOX::Catalog));                     if(FAILED(hr))                     {                            _com_issue_error(hr);						}						else{                            m_pCatalog-&gt;Create(_bstr_t(strcnn));//Create MDB                     }              }catch(_com_error e)  //异常处理			{//错误显示}       }       ::CoUninitialize();       return TRUE;}2、用程序在系统中创建Access的数据源名称DSN：手工配置ODBC的数据源名称，大家也不陌生。而通过程序动态建立ODBC的DSN，在有安装程序的情况下也需要它。它是在已有数据库文件的情况下建立数据源名称。BOOL CRecord::CreatAccessDSN(){              CString DBID ,lpszFile=DBPath+DBName;              int mlen;              char* szDesc=new char[512];              sprintf(szDesc,"DSN=%s?UID=%s?;PWD=%s?;DESCRIPTION=;?DBQ=%s?\FIL=MicrosoftAccess?DEFAULTDIR=%s??"\                     ,DBName,DBID,DBPasswd,lpszFile,DBPath);              mlen=strlen(szDesc);              for(int i=0;i&lt;mlen;i++)              {                     if(szDesc[i]=='?')    szDesc[i]='\0';              }              if(SQLConfigDataSource(NULL,ODBC_ADD_DSN,"MicrosoftAccess\                    Driver (*.mdb)\0", (LPCSTR)szDesc)) return TRUE;              ……}3、动态建数据库表一种方法可以通过一个配置数据库表的txt文件，它包括创建数据表的SQL语句，程序读入该文件的，并分析该文件的内容，得到一SQL字串，进行创建，这种方法建表比较灵活；另一种方法也可以通过有包括创建Access数据表SQL语句的程序代码创建。两种创建方法都要注意在字段名与它的字段类型之间必需用tab键隔开。如下，采用后者：try{      VARIANT* RecordsAffected=0;      CString strSQL=\"CREATE TABLE accesstable(ID  longinteger ID ENTITY(1,1) not null,";      strPSW=strPSW+"name        text(10)not null,";      strPSW=strPSW+"cash  DOUBLE,remark   text(100));";   //SQL字串      m_pCon-&gt;Execute((_bstr_t)(LPCTSTR)strSQL,NULL,adExecuteNoRecords);}catch(_com_error&amp;e)    { …… }用VC++程序来动态建库很多数据类型不支持，但表名、字段名可以是变量。4、数据库的连接和关闭bool CRecordSonPrg::CreatConnect()   //数据库的连接{CString str="Provider=MSDASQL.1;Password='"+DBPasswd+"';\              PersistSecurity Info=True;Data Source="+DBName;  //连接字串              try              {                     m_pCon.CreateInstance(__uuidof(Connection));                     m_strConnection = _T(str);                       intbCon=m_pCon-&gt;Open(_bstr_t(m_strConnection),"","",adConnectUnspecified);              }              catch(_com_error &amp;e)    { ……    }              return true;}void CRecordSonPrg::CloseConnect()  //数据库的关闭{       try       {              m_pCon-&gt;Close();  //关闭连接              m_pCon.Release(); //释放       }       catch(_com_error &amp;e){ ……       }}5、用ADO对数据库记录的增、删、改、存、查、排序、过滤、打印//打开一个数据表DBtablem_pRs.CreateInstance(__uuidof(Recordset));m_strCmdText= _T("DBtable");m_pRs-&gt;Open((LPCTSTR)m_strCmdText,(LPCTSTR)m_strConnection,adOpenStatic,adLockOptimistic,adCmdTable);①增加记录：try{      if(!m_pRs-&gt;Supports(adAddNew))return false;      m_pRs-&gt;AddNew();m_pRs-&gt;Fields-&gt;GetItem("user")-&gt;Value=(_variant_t)strm_newuser;      ……     m_pRs-&gt;Update();}②删除记录：try{          m_pRs-&gt;Delete(adAffectCurrent );      //删除当前记录}③改动、保存记录：void CRsCgDlg::SaveModifiedRecord()       //记录修改后保存{      ……       //拷贝对话框数据到ADOC++ 绑定成员      //调用ADO数据绑定更新模式的接口      HRESULT hr = m_piAdoRecordBinding-&gt;Update( (CADORecordBinding*)this );}④查找记录：CString temp ="user='"+m_FindUserName+"'";  //查找字串_bstr_ttemp1=(_bstr_t)temp;                                  //类型转换为_bstr_tm_pRs-&gt;Find(temp1,0,adSearchForward,"");⑤排序记录：CString temp="’user,"+m_FindUserName+"'";  //排序字串_bstr_ttemp1=(_bstr_t)temp;                                  //类型转换为_bstr_tm_pRs-&gt;Sort=(temp1);m_pRs-&gt;Sort=("");                                          //取消排序⑥过滤记录：CString strfilter = _T("name = '"+m_strFilter+"'");    //过滤字串m_pRs-&gt;Filter= (_variant_t)strfilter;m_pRs-&gt;Filter= (long) adFilterNone;        //取消过滤⑦打印记录：打印记录可以采用CDocument类的serialize()文档类的方式，也可以借助显示控件实现。这里是用FlexGrid控件编写的打印代码。void CMyApp::PrintToText(){      CString cFilePath = "C:\\Documents and Settings\\Administrator\\";      CString cFileName = "打印统计表.txt";      CString cFile = cFilePath+cFileName;CStdioFile file; //CStdioFile类是CFile类的派生类,它是以流方式操作文本      file.Open(cFile,CFile::modeCreate|CFile::modeWrite|CFile::typeText)CString str;      str.Format("%s\n\n",cFileName);      //格式化文件主题      file.WriteString(str);                   //写入文件主题      int RowCount = m_MSFGrid.GetRows();   //从FlexGrid控件表取行数      int ColCount = m_MSFGrid.GetCol();       //从FlexGrid控件表取列数      for(long r=0;r&lt;RowCount;r++)     //行循环      {             for(long c=0;c&lt;ColCount;c++)     //列循环             {                    CString Matrix =m_MSFGrid.GetTextMatrix(r,c);//得到r行c列的文本                    switch(c)                    { str.Format( …… );//产生打印格式 }                    file.WriteString(str);             }      }      file.SetLength(file.GetPosition());     //设置文件长度      file.Close();                      //关闭文件      str="notepad "+cFile;      WinExec(str,SW_SHOW);            //利用记事本打开生成的文本文件}6、配置设置文件：为了增加程序的灵活性，对配置文件的读、写也是必要的。Windows操作系统专门为此提供了6个API函数来对配置设置文件进行读、写：GetPrivateProfileInt()               //从私有初始化文件获取整型数值  GetPrivateProfileString()  //从私有初始化文件获取字符串型值  GetProfileInt                    //从win.ini获取整数值  GetProfileString                      //从win.ini获取字符串值  WritePrivateProfileString  //写字符串到私有初始化文件  WriteProfileString      //写字符串到win.ini 下面采用私有初始化文件获取或写入字符串型值的函数来读写配置文件：读文件：CString CMyApp::GetOneIniData(CString sFilePath){      CString str;      char buf[256] =NULL;      int len=0;      len = GetPrivateProfileString(             "Custom",      //节名             "UserName"   //项名             "No",             //没找到此项时的返回值             buf,               //目标缓冲区地址             256,               //目标缓冲区长度             sFilePath        //配置文件的准确路径      );      str=buf;      return str;}写文件：BOOL CKaApp::WriteIniData(CString cstr,CString strUserName){       CString sFile = cstr;       CFileStatus status;         BOOL RetUser=WritePrivateProfileString(              "Custom",             //节名              "UserName",         //项名              strUserName,         //内容              sFile                            //配置文件的准确路径              );      return TRUE;}对于SQL Server的操作类似。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[毕业论文摘要的书写方法和技巧]]></title>
      <url>/blog/college-thesis-summary-skill/</url>
      <content type="text"><![CDATA[摘要也就是内容提要，是论文中不可缺少的一部分。论文摘要是一篇具有独立性的短文，有其特别的地方。它是建立在对论文进行总结的基础之上，用简单、明确、易懂、精辟的语言对全文内容加以概括，留主干去枝叶，提取论文的主要信息。作者的观点、论文的主要内容、研究成果、独到的见解，这些都应该在摘要中体现出来。好的摘要便于索引与查找，易于收录到大型资料库中并为他人提供信息。因此摘要在资料交流方面承担着至关重要的作用。书写摘要的基本规范和原则（1）论文摘要分为中文摘要和外文（一般为英文）摘要。摘要在篇幅方面的限定，不同的学校和机构有不同的要求，通常中文摘要不超过300字，英文摘要不超过250个实词，中英文摘要应一致。毕业论文摘要可适当增加篇幅。（2）多向指导教师请教，并根据提供的意见及时修改，以期达到更高水平。（3）摘要是完整的短文，具有独立性，可以单独使用。即使不看论文全文的内容，仍然可以理解论文的主要内容、作者的新观点和想法、课题所要实现的目的、采取的方法、研究的结果与结论。（4）叙述完整，突出逻辑性，短文结构要合理。（5）要求文字简明扼要，不容赘言，提取重要内容，不含前言、背景等细节部分，去掉旧结论、原始数据，不加评论和注释。采用直接表述的方法，删除不必要的文学修饰。摘要中不应包括作者将来的计划以及与此课题无关的内容，做到用最少的文字提供最大的信息量。（6）摘要中不使用特殊字符，也不使用图表和化学结构式，以及由特殊字符组成的数学表达式，不列举例证。摘要的四要素目的、方法、结果和结论称为摘要的四要素。（1）目的：指出研究的范围、目的、重要性、任务和前提条件，不是主题的简单重复。（2）方法：简述课题的工作流程，研究了哪些主要内容，在这个过程中都做了哪些工作，包括对象、原理、条件、程序、手段等。（3）结果：陈述研究之后重要的新发现、新成果及价值，包括通过调研、实验、观察取得的数据和结果，并剖析其不理想的局限部分。（4）结论：通过对这个课题的研究所得出的重要结论，包括从中取得证实的正确观点，进行分析研究，比较预测其在实际生活中运用的意义，理论与实际相结合的价值。撰写步骤摘要作为一种特殊的陈述性短文，书写的步骤也与普通类型的文章有所不同。摘要的写作时间通常在论文的完成之后，但也可以采用提早写的方式，然后再边写论文边修改摘要。首先，从摘要的四要素出发，通读论文全文，仔细将文中的重要内容一一列出，特别是每段的主题句和论文结尾的归纳总结，保留梗概与精华部分，提取用于编写摘要的关键信息。然后，看这些信息能否完全、准确的回答摘要的四要素所涉及的问题，并要求语句精炼。若不足以回答这些问题，则重新阅读论文，摘录相应的内容进行补充。最后，将这些零散信息，组成符合语法规则和逻辑规则的完整句子，再进一步组成通畅的短文，通读此短文，反复修改，达到摘要的要求。关于英文摘要（1）英文摘要的写作方法要依据公认的写作规范。（2）尽量使用简单句，避免句型单调，表达要求准确完整。（3）正确使用冠词。（4）使用标准英语书写，避免使用口语，应使用易于理解的常用词，不用生僻词汇。（5）作者所做工作用过去时，结论用现在时。（6）多使用主动语态。关键词关键词是为了文献标引工作从报告、论文中选出来用以表示全文主题内容信息目的单词术语。每篇报告、论文选取3～8个词作为关键词，以显著的字符另起一行，排在摘要的左方。如有可能，尽量用《汉语主题词表》等词表提供的规范词。为了国际交流，应标注与中文对应的英文关键词。关键词是主题词中的一类。主题词是一种新型检索词汇，多用于计算机网络检索。关键词分为中文关键词和与之对应的英文关键词，分别置于中文摘要和英文摘要之下。为便于他人的检索，不能使用过于宽泛的词语。选择关键词既可以从论文的各级标题入手，也可以从论文本身的内容选取，将选出的关键词按照所涉及领域的范围从大到小顺序列出。]]></content>
      <categories>
        
          <category> talk </category>
        
      </categories>
      <tags>
        
          <tag> 碎碎念 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
