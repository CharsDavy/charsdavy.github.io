<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Chars Davy]]></title>
  <subtitle><![CDATA[无所谓的态度，过着随遇而安的生活]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://charsdavy.github.io/"/>
  <updated>2016-04-10T15:53:03.000Z</updated>
  <id>http://charsdavy.github.io/</id>
  
  <author>
    <name><![CDATA[Chars Davy]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[设计模式简介]]></title>
    <link href="http://charsdavy.github.io/2016/04/10/design-pattern-brief/"/>
    <id>http://charsdavy.github.io/2016/04/10/design-pattern-brief/</id>
    <published>2016-04-10T15:53:03.000Z</published>
    <updated>2016-04-10T15:53:03.000Z</updated>
    <content type="html"><![CDATA[
      <p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p> 
      <p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码 可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用 设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决 方案，这也是设计模式能被广泛应用的原因。</p> 
      <h1 id="什么是gofgang-of-four">什么是GOF（Gang of Four）</h1> 
      <p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为《 Design Patterns - Elements of Reusable Object-Oriented Software》（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。</p> 
      <p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。</p> 
      <ul> 
       <li>对接口编程而不是对实现编程。</li> 
       <li>优先使用对象组合而不是继承。</li> 
     </ul> 
     <h1 id="设计模式的使用">设计模式的使用</h1> 
     <p>设计模式在软件开发中的两个主要用途。 ##开发人员的共同平台 设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。 ##最佳的实践 设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。 #设计模式的类型 根据设计模式的参考书《 Design Patterns - Elements of Reusable Object-Oriented Software》（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 ##创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用新的运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p> 
     <ul> 
       <li>工厂模式（Factory Pattern）</li> 
       <li>抽象工厂模式（Abstract Factory Pattern）</li> 
       <li>单例模式（Singleton Pattern）</li> 
       <li>建造者模式（Builder Pattern）</li> 
       <li>原型模式（Prototype Pattern）</li> 
     </ul> 
     <h2 id="结构型模式">结构型模式</h2> 
     <p>这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p> 
     <ul> 
       <li>适配器模式（Adapter Pattern）</li> 
       <li>桥接模式（Bridge Pattern）</li> 
       <li>过滤器模式（Filter Pattern）</li> 
       <li>组合模式（Composite Pattern）</li> 
       <li>装饰器模式（Decorator Pattern）</li> 
       <li>外观模式（Facade Pattern）</li> 
       <li>享元模式（Flyweight Pattern）</li> 
       <li>代理模式（Proxy Pattern）</li> 
     </ul> 
     <h2 id="行为型模式">行为型模式</h2> 
     <p>这些设计模式特别关注对象之间的通信。</p> 
     <ul> 
       <li>责任链模式（Chain Responsibility Pattern）</li> 
       <li>命令模式（Command Pattern）</li> 
       <li>解释器模式（Interpreter Pattern）</li> 
       <li>迭代器模式（Iterator Pattern）</li> 
       <li>中介者模式（Mediator Pattern）</li> 
       <li>备忘录模式（Memento Pattern）</li> 
       <li>观察者模式（Observer Pattern）</li> 
       <li>状态模式（State Pattern）</li> 
       <li>空对象模式（Null Object Pattern）</li> 
       <li>策略模式（Strategy Pattern）</li> 
       <li>模板模式（Template Pattern）</li> 
       <li>访问者模式（Visitor Pattern）</li> 
     </ul> 
     <h2 id="j2ee模式">J2EE模式</h2> 
     <p>这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</p> 
     <ul> 
       <li>MVC模式（MVC Pattern）</li> 
       <li>业务代表模式（Business Delegate Pattern）</li> 
       <li>组合实体模式（Composite Entity Pattern）</li> 
       <li>数据访问对象模式（Data Access Object Pattern）</li> 
       <li>前端控制器模式（Front Controller Pattern）</li> 
       <li>拦截过滤器模式（Intercepting Filter Pattern）</li> 
       <li>服务定位器模式（Service Locator Pattern）</li> 
       <li>传输对象模式（Transfer Object Pattern）</li> 
     </ul> 
     <h1 id="设计模式的六大原则">设计模式的六大原则</h1> 
     <p>1、开闭原则（Open Close Principle）</p> 
     <p>开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p> 
     <p>2、里氏代换原则（Liskov Substitution Principle）</p> 
     <p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代 换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤 的规范。</p> 
     <p>3、依赖倒转原则（Dependence Inversion Principle）</p> 
     <p>这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。</p> 
     <p>4、接口隔离原则（Interface Segregation Principle）</p> 
     <p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p> 
     <p>5、迪米特法则，又称最少知道原则（Demeter Principle）</p> 
     <p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p> 
     <p>6、合成复用原则（Composite Reuse Principle）</p> 
     <p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p> 
     ]]></content>
     <summary type="html">
      <![CDATA[<p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>]]>
    </summary>
    
  </entry>

  <entry>
    <title><![CDATA[Xcode插件开发教程指南]]></title>
    <link href="http://charsdavy.github.io/2016/04/08/iOS-Xcode-Plugin/"/>
    <id>http://charsdavy.github.io/2016/04/08/iOS-Xcode-Plugin/</id>
    <published>2016-04-08T01:53:03.000Z</published>
    <updated>2016-04-08T01:53:03.000Z</updated>
    <content type="html"><![CDATA[
      <p>在平时开发过程中我们使用了很多的Xcode插件，虽然官方对于插件制作没有提供任何支持，但是加载三方的插件，默认还是被允许的。第三方的插件，存放在 ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中，后缀名必须是.xcplugin ，其实际上是一种bundle。所以我们创建一个插件工程，直接创建bundle工程即可。然后通过修改后缀名为.xcplugin，将其放到~/Library/Application Support/Developer/Shared/Xcode/Plug-ins目录中即可。</p> 
        <p>Xcode插件开发现在主要通过两种方式实现，其实也就是一种，只不过其中一种是使用别人提供的开发模板来省去很多中间步骤而已。文章会依次详细介绍两种的实现方法。</p> 
        <h1>准备工作</h1> 
        <h2>方式一：通过Bundle实现</h2> 
        <p>&nbsp;1.创建Bundle工程</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201603/490781-20160330144728207-192574452.png" alt="" /></p> 
        <p>2.工程设置</p> 
        <p id="首先是工程的plist文件">插件工程和普通的bundle工程还是有区别的,所以需要进行特殊的设置。</p> 
        <p>1）工程的plist文件</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201603/490781-20160330144905629-871612988.png" alt="" /></p> 
        <p>添加三项： <br /> XCPluginHasUI = NO <br /> XC4Compatible = YES <br /> DVTPlugInCompatibilityUUIDs 这是一个数组。数组内容字符串，指示了该插件兼容的Xcode版本，只有对应版本的Xcode的UIID加入这个数组，插件才能被加载。否则，即使将插件放入Xcode的插件文件夹，插件也不会被加载。<br /> 获取当前版本的Xcode的UUID方式：</p> 
        <p>在terminal中输入命令：</p> 
        <p> defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID </p> 
        <p>terminal会返回一串字符串，这就是Xcode的DVTPlugInCompatibilityUUID。</p> 
        <p id="接下来是-build-setting了">2）Build Setting</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201603/490781-20160330145158129-342161810.png" alt="" /></p> 
        <p>&nbsp;</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201603/490781-20160330145210144-303815379.png" alt="" /></p> 
        <p>Installation Build Products Location 设置为 ${HOME} [显示的时候,显示的是你的用户目录]，这个是products的根目录。</p> 
        <p>Installation Directory 设置为 /Library/Application Support/Developer/Shared/Xcode/Plug-ins，这个是指定你的插件安装的目录。 注意，这里填入的其实是相对目录。插件的绝对目录是这样的，例如 /Users/yohunl/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin ，最后的绝对目录是 Installation Build Products Location和Installation Directory的结合，这也是为什么两者都要设置的原因。</p> 
        <p>Deployment Location 设置为 YES，这个是指示该工程不使用设置里的build location，而是用Installation Directory来确定build后放置的位置。</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201603/490781-20160330145434019-1733725866.png" alt="" /></p> 
        <p>默认工程生成的相关文件位置都是 Build Locations指定的，通过Deployment Location 设置为 YES告诉工程，我们不使用这个默认的设置，而是我们自定义的。</p> 
        <p>Wrapper extension 设置为 xcplugin，后缀名必须为xcplugin，否则不会被加载。</p> 
        <h2>方式二：通过模板实现</h2> 
        <p>&nbsp;1）下载Xcode插件开发模板</p> 
        <p>地址：<a href="https://github.com/kattrali/Xcode-Plugin-Template" target="_blank">https://github.com/kattrali/Xcode-Plugin-Template</a><br /><br />2）将下载下来的template复制到 ~/Library/Developer/Xcode/Templates/Project Templates/Application Plug-in/Xcode Plugin.xctemplate文件夹中，如果没有对应的文件夹就自己手动创建一个。<br /><br />3）重启Xcode，当你新建一个工程的时候就可以在OS X中看到一个Application Plug-in的选项，里面有一个Xcode Plug-in模板。</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201603/490781-20160330150045894-1159966575.png" alt="" /></p> 
        <h1>实现</h1> 
        <p>通过以上的两种准备方式，我们已可以创建Xcode插件工程，接下来就是如何实现插件功能。</p> 
        <p>&nbsp;1.功能需求</p> 
        <p>在当前选中文件中实现代码风格重构，目前主要实现setter方法这一风格重构。例如，</p> 
        <p>[self setName:@&quot;Davy&quot;]; ==&gt; self.name = @&quot;Davy&quot;;</p> 
        <p>2.思路分析</p> 
        <p>1）找到当前文件中符合setter方法命名风格的方法调用。</p> 
        <p>2）替换找到的符合重构风格的代码，提醒用户保存。</p> 
        <p>3.技术难点</p> 
        <p>1）Xcode代码编辑框文件内容操作。</p> 
        <p>2）正则表达式书写。</p> 
        <p>3）Xcode代码编辑框提醒用户保存文件。</p> 
        <p>关于最后一点，因为Xcode对于没有保存的已修改过的文件会显灰以提示用户该文件需要保存，我们可以借鉴这种方式。另外，在查找时，如果能够实现高亮并且跟随滚动，效果会更佳。</p> 
        <p>4.关键代码</p> 
        <p>&nbsp;以上这些问题，本人在“Refactor Code”插件中全部实现，现在放上关键方法。</p> 
        <p>1）添加菜单</p> 
        <div class="cnblogs_code"> 
         <pre>-(<span>void</span><span>) setupMenuItem
{
    </span><span>//</span><span> Menu Item:</span>
<span>    
    NSMenuItem </span>*editMenuItem = [[NSApp mainMenu] itemWithTitle:<span>@&quot;</span><span>Edit</span><span>&quot;</span><span>];
    
    </span><span>if</span><span> (editMenuItem) {
        [[editMenuItem submenu] addItem:[NSMenuItem separatorItem]];
        
        NSMenu </span>*refactorCodeMenu = [[NSMenu alloc] initWithTitle:<span>@&quot;</span><span>Refactor Code</span><span>&quot;</span><span>];
        
        NSMenuItem </span>*<span>menuItem;
        menuItem </span>= [[NSMenuItem alloc] initWithTitle:<span>@&quot;</span><span>Refactor Method Style</span><span>&quot;</span> action:@selector(refactorMethodStyleMenuAction) keyEquivalent:<span>@&quot;&quot;</span><span>];
        [menuItem setTarget:self];
        [refactorCodeMenu addItem:menuItem];
        
        NSMenuItem </span>*refactorCodeMenuItem = [[NSMenuItem alloc] initWithTitle:<span>@&quot;</span><span>Refactor Code</span><span>&quot;</span> action:nil keyEquivalent:<span>@&quot;&quot;</span><span>];
        [refactorCodeMenuItem setSubmenu:refactorCodeMenu];
        [[editMenuItem submenu] addItem:refactorCodeMenuItem];
    }
}</span></pre> 
        </div> 
        <p>效果图如下：</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201604/490781-20160401135707035-2105407027.png" alt="" width="390" height="417" /></p> 
        <p>2）显示操作面板</p> 
        <div class="cnblogs_code"> 
         <pre>- (<span>void</span><span>)refactorMethodStyleMenuAction
{
    [self.operateController showWindow:nil];
    
    NSURL </span>*url = [[NSBundle bundleForClass:[self <span>class</span>]] URLForResource:<span>@&quot;</span><span>DZOperateController</span><span>&quot;</span> withExtension:<span>@&quot;</span><span>nib</span><span>&quot;</span><span>];
    
    </span><span>if</span> (!<span>url) {
        NSAlert </span>*alert =<span> [[NSAlert alloc] init];
        alert.messageText </span>= <span>@&quot;</span><span>Refactor Method Style could not be shown because the plugin is corrupted.</span><span>&quot;</span><span>;
        alert.informativeText </span>= <span>@&quot;</span><span>If you build the plugin from sources using Xcode, make sure to perform “Clean Build Folder“ in <br />　　　　　　　　Xcode and then build the plugin again.\n\nIf you installed the plugin via Alctraz, there is a pending issue causing <br />　　　　　　　　some files to be missing in the plugin. Prefer to install it via the plugin webpage.</span><span>&quot;</span><span>;
        [alert addButtonWithTitle:</span><span>@&quot;</span><span>Download Latest</span><span>&quot;</span><span>];
        [alert addButtonWithTitle:</span><span>@&quot;</span><span>Cancel</span><span>&quot;</span><span>];
        NSModalResponse result </span>=<span> [alert runModal];
        
        </span><span>if</span> (result ==<span> NSAlertFirstButtonReturn) {
            [[NSWorkspace sharedWorkspace] openURL:[NSURL URLWithString:</span><span>@&quot;</span><span>https://github.com/CharsDavy/RefactorCodePlugin-Xcode</span><span>&quot;</span><span>]];
        }
    }
}</span></pre> 
        </div> 
        <p>效果图如下：</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201604/490781-20160401135950379-1172628646.png" alt="" /></p> 
        <p>3）查找替换代码风格</p> 
        <p>这一部分是重点部分，包括如何书写正则表达式，并且利用正则表达式生成替换字符。还包括高亮代码，具体可以参见本人源码：<a href="https://github.com/CharsDavy/RefactorCodePlugin-Xcode" target="_blank">https://github.com/CharsDavy/RefactorCodePlugin-Xcode</a></p> 
        <p>4）最终效果图</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201604/490781-20160401140322598-323202767.png" alt="" /></p> 
        <h1>提交插件至Alcatraz</h1> 
        <p>1.打开Alcatraz的插件包仓库，地址：<a href="https://github.com/supermarin/alcatraz-packages" target="_blank">https://github.com/supermarin/alcatraz-packages</a></p> 
        <p>2.在简介里可以看到Alcatraz的包分为三类，分别为：插件(plugins)，配色方案(color schemes)和模板(templates)。<br /> 每个包都必须包含”name”、”url”和”description”字段，还有一个可选的”screenshot”字段。</p> 
        <p>3.Fork这个仓库，再克隆到本地。</p> 
        <p>4.以添加”Refactor Code”插件为例，打开packages.json文件，在”plugins”数组里加入：</p> 
        <div class="cnblogs_code"> 
         <pre><span>    {
        </span><span>&quot;</span><span>name</span><span>&quot;</span>: <span>&quot;</span><span>Refactor Code</span><span>&quot;</span><span>,
        </span><span>&quot;</span><span>url</span><span>&quot;</span>: <span>&quot;</span><span>https://github.com/CharsDavy/RefactorCodePlugin-Xcode.git</span><span>&quot;</span><span>,
        </span><span>&quot;</span><span>description</span><span>&quot;</span>: <span>&quot;</span><span>Refactor code style,such as setter method.</span><span>&quot;</span><span>,
        </span><span>&quot;</span><span>screenshot</span><span>&quot;</span>: <span>&quot;</span><span>https://github.com/CharsDavy/RefactorCodePlugin-Xcode/raw/master/Screenshots/window.png</span><span>&quot;</span><span>
    }</span></pre> 
        </div> 
        <p>5.提交代码到Fork的地址，再提交一个pull request到Master即可。</p> 
        <p>6.merged成功之后，即可看见以下效果图</p> 
        <p><img src="http://images2015.cnblogs.com/blog/490781/201604/490781-20160401092906176-1572332699.png" alt="" /></p> 
        <p>&nbsp;希望对大家有所帮助。</p> 
     ]]></content>
     <summary type="html">
      <![CDATA[<p>在平时开发过程中我们使用了很多的Xcode插件，虽然官方对于插件制作没有提供任何支持，但是加载三方的插件，默认还是被允许的。第三方的插件，存放在 ~/Library/Application Support/Developer/Shared/Xcode/Plug-ins文件夹中，后缀名必须是.xcplugin ，其实际上是一种bundle。所以我们创建一个插件工程，直接创建bundle工程即可。然后通过修改后缀名为.xcplugin，将其放到~/Library/Application Support/Developer/Shared/Xcode/Plug-ins目录中即可。</p>]]>
    </summary>
    
  </entry>
  
  
</feed>
