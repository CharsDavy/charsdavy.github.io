<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chars&#39;s Tech Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://charsdavy.github.io/"/>
  <updated>2016-08-05T00:16:03.000Z</updated>
  <id>http://charsdavy.github.io/</id>
  
  <author>
    <name>Chars Davy</name>
    <email>chars_d@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Core Animation (四) 视觉效果</title>
    <link href="http://charsdavy.github.io/2016/08/03/core-animation-vision-effect/"/>
    <id>http://charsdavy.github.io/2016/08/03/core-animation-vision-effect/</id>
    <published>2016-08-02T23:53:40.000Z</published>
    <updated>2016-08-05T00:16:03.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;嗯，圆和椭圆还不错，但如果是带圆角的矩形呢？&lt;/p&gt;
&lt;p&gt;我们现在能做到那样了么？&lt;/p&gt;
&lt;p&gt;史蒂芬·乔布斯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在第三章&lt;a href=&quot;http://charsdavy.github.io/2016/08/01/core-animation-geometry-layer/&quot;&gt;『图层几何学』&lt;/a&gt;中讨论了图层的frame，第二章&lt;a href=&quot;http://charsdavy.github.io/2016/07/30/core-aniamtion-host-layer/&quot;&gt;『寄宿图』&lt;/a&gt;则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;圆角&quot;&gt;&lt;a href=&quot;#圆角&quot; class=&quot;headerlink&quot; title=&quot;圆角&quot;&gt;&lt;/a&gt;圆角&lt;/h2&gt;&lt;p&gt;圆角矩形是iOS的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角矩形的方法。恭喜你，猜对了。&lt;/p&gt;
&lt;p&gt;CALayer有一个叫做&lt;code&gt;conrnerRadius&lt;/code&gt;的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把&lt;code&gt;masksToBounds&lt;/code&gt;设置成YES的话，图层里面的所有东西都会被截取。&lt;/p&gt;
&lt;p&gt;我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.1.png?imageView/2/w/700&quot; alt=&quot;图4.1&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.1 两个白色的大视图，他们都包含了小一些的红色视图。&lt;/p&gt;
&lt;p&gt;然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果&lt;/p&gt;
&lt;p&gt;清单4.1 设置&lt;code&gt;cornerRadius&lt;/code&gt;和&lt;code&gt;masksToBounds&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *layerView1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *layerView2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;￼￼￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set the corner radius on our layers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.cornerRadius = 20.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.cornerRadius = 20.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //enable clipping on the second layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.masksToBounds = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.2.png?imageView/2/w/700&quot; alt=&quot;图4.2&quot;&gt;&lt;/p&gt;
&lt;p&gt;右图中，红色的子视图沿角半径被裁剪了&lt;/p&gt;
&lt;p&gt;如你所见，右边的子视图沿边界被裁剪了。&lt;/p&gt;
&lt;p&gt;单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者是CAShapeLayer（见第六章『专用图层』）。&lt;/p&gt;
&lt;h2 id=&quot;图层边框&quot;&gt;&lt;a href=&quot;#图层边框&quot; class=&quot;headerlink&quot; title=&quot;图层边框&quot;&gt;&lt;/a&gt;图层边框&lt;/h2&gt;&lt;p&gt;CALayer另外两个非常有用属性就是&lt;code&gt;borderWidth&lt;/code&gt;和&lt;code&gt;borderColor&lt;/code&gt;。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的&lt;code&gt;bounds&lt;/code&gt;绘制，同时也包含图层的角。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;borderWidth&lt;/code&gt;是以点为单位的定义边框粗细的浮点数，默认为0.&lt;code&gt;borderColor&lt;/code&gt;定义了边框的颜色，默认为黑色。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;borderColor&lt;/code&gt;是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了&lt;code&gt;borderColor&lt;/code&gt;，虽然属性声明并不能证明这一点。&lt;code&gt;CGColorRef&lt;/code&gt;在引用/释放时候的行为表现得与&lt;code&gt;NSObject&lt;/code&gt;极其相似。但是Objective-C语法并不支持这一做法，所以&lt;code&gt;CGColorRef&lt;/code&gt;属性即便是强引用也只能通过assign关键字来声明。&lt;/p&gt;
&lt;p&gt;边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.&lt;/p&gt;
&lt;p&gt;清单4.2 加上边框&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set the corner radius on our layers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.cornerRadius = 20.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.cornerRadius = 20.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //add a border to our layers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.borderWidth = 5.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.borderWidth = 5.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //enable clipping on the second layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.masksToBounds = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.3.png?imageView/2/w/700&quot; alt=&quot;图4.3&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.3 给图层增加一个边框&lt;/p&gt;
&lt;p&gt;仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.4.png?imageView/2/w/700&quot; alt=&quot;图4.4&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.4 边框是跟随图层的边界变化的，而不是图层里面的内容&lt;/p&gt;
&lt;h2 id=&quot;阴影&quot;&gt;&lt;a href=&quot;#阴影&quot; class=&quot;headerlink&quot; title=&quot;阴影&quot;&gt;&lt;/a&gt;阴影&lt;/h2&gt;&lt;p&gt;iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。&lt;/p&gt;
&lt;p&gt;给&lt;code&gt;shadowOpacity&lt;/code&gt;属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。&lt;code&gt;shadowOpacity&lt;/code&gt;是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：&lt;code&gt;shadowColor&lt;/code&gt;，&lt;code&gt;shadowOffset&lt;/code&gt;和&lt;code&gt;shadowRadius&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;显而易见，&lt;code&gt;shadowColor&lt;/code&gt;属性控制着阴影的颜色，和&lt;code&gt;borderColor&lt;/code&gt;和&lt;code&gt;backgroundColor&lt;/code&gt;一样，它的类型也是&lt;code&gt;CGColorRef&lt;/code&gt;。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shadowOffset&lt;/code&gt;属性控制着阴影的方向和距离。它是一个&lt;code&gt;CGSize&lt;/code&gt;的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。&lt;code&gt;shadowOffset&lt;/code&gt;的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。&lt;/p&gt;
&lt;p&gt;为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，&lt;code&gt;shadowOffset&lt;/code&gt;的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.5.png?imageView/2/w/700&quot; alt=&quot;图4.5&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.5 在iOS（左）和Mac OS（右）上&lt;code&gt;shadowOffset&lt;/code&gt;的表现。&lt;/p&gt;
&lt;p&gt;苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shadowRadius&lt;/code&gt;属性控制着阴影的&lt;em&gt;模糊度&lt;/em&gt;，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。&lt;/p&gt;
&lt;p&gt;通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给&lt;code&gt;shadowRadius&lt;/code&gt;设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.6.png?imageView/2/w/700&quot; alt=&quot;图4.6&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.6 大一些的阴影位移和角半径会增加图层的深度即视感&lt;/p&gt;
&lt;h2 id=&quot;阴影裁剪&quot;&gt;&lt;a href=&quot;#阴影裁剪&quot; class=&quot;headerlink&quot; title=&quot;阴影裁剪&quot;&gt;&lt;/a&gt;阴影裁剪&lt;/h2&gt;&lt;p&gt;和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.7.png?imageView/2/w/700&quot; alt=&quot;图4.7&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.7 阴影是根据寄宿图的轮廓来确定的&lt;/p&gt;
&lt;p&gt;当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了&lt;code&gt;masksToBounds&lt;/code&gt;属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.8.png?imageView/2/w/700&quot; alt=&quot;图4.8&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.8 &lt;code&gt;maskToBounds&lt;/code&gt;属性裁剪掉了阴影和内容&lt;/p&gt;
&lt;p&gt;从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用&lt;code&gt;masksToBounds&lt;/code&gt;裁剪内容的内图层。&lt;/p&gt;
&lt;p&gt;如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.9.png?imageView/2/w/700&quot; alt=&quot;图4.9&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.9 右边，用额外的阴影转换视图包裹被裁剪的视图&lt;/p&gt;
&lt;p&gt;我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。&lt;/p&gt;
&lt;p&gt;清单4.3 用一个额外的视图来解决阴影裁切的问题&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *layerView1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *layerView2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *shadowView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set the corner radius on our layers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.cornerRadius = 20.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.cornerRadius = 20.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //add a border to our layers&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.borderWidth = 5.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.borderWidth = 5.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //add a shadow to layerView1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.shadowOpacity = 0.5f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.shadowRadius = 5.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //add same shadow to shadowView (not layerView2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.shadowView.layer.shadowOpacity = 0.5f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.shadowView.layer.shadowRadius = 5.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //enable clipping on the second layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.masksToBounds = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.10.png?imageView/2/w/700&quot; alt=&quot;图4.10&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.10 右边视图，不受裁切阴影的阴影视图。&lt;/p&gt;
&lt;h2 id=&quot;shadowPath属性&quot;&gt;&lt;a href=&quot;#shadowPath属性&quot; class=&quot;headerlink&quot; title=&quot;shadowPath属性&quot;&gt;&lt;/a&gt;&lt;code&gt;shadowPath&lt;/code&gt;属性&lt;/h2&gt;&lt;p&gt;我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。&lt;/p&gt;
&lt;p&gt;如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个&lt;code&gt;shadowPath&lt;/code&gt;来提高性能。&lt;code&gt;shadowPath&lt;/code&gt;是一个&lt;code&gt;CGPathRef&lt;/code&gt;类型（一个指向&lt;code&gt;CGPath&lt;/code&gt;的指针）。&lt;code&gt;CGPath&lt;/code&gt;是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。&lt;/p&gt;
&lt;p&gt;图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.11.png?imageView/2/w/700&quot; alt=&quot;图4.11&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.11 用&lt;code&gt;shadowPath&lt;/code&gt;指定任意阴影形状&lt;/p&gt;
&lt;p&gt;清单4.4 创建简单的阴影形状&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *layerView1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *layerView2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //enable layer shadows&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.shadowOpacity = 0.5f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.shadowOpacity = 0.5f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //create a square shadow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGMutablePathRef squarePath = CGPathCreateMutable();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGPathAddRect(squarePath, NULL, self.layerView1.bounds);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ￼//create a circular shadow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGMutablePathRef circlePath = CGPathCreateMutable();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是一个矩形或者是圆，用&lt;code&gt;CGPath&lt;/code&gt;会相当简单明了。但是如果是更加复杂一点的图形，&lt;code&gt;UIBezierPath&lt;/code&gt;类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。&lt;/p&gt;
&lt;h2 id=&quot;图层蒙板&quot;&gt;&lt;a href=&quot;#图层蒙板&quot; class=&quot;headerlink&quot; title=&quot;图层蒙板&quot;&gt;&lt;/a&gt;图层蒙板&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;masksToBounds&lt;/code&gt;属性，我们可以沿边界裁剪图形；通过&lt;code&gt;cornerRadius&lt;/code&gt;属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。&lt;/p&gt;
&lt;p&gt;使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。&lt;/p&gt;
&lt;p&gt;CALayer有一个属性叫做&lt;code&gt;mask&lt;/code&gt;可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，&lt;code&gt;mask&lt;/code&gt;图层定义了父图层的部分可见区域。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mask&lt;/code&gt;图层的&lt;code&gt;Color&lt;/code&gt;属性是无关紧要的，真正重要的是图层的轮廓。&lt;code&gt;mask&lt;/code&gt;属性就像是一个饼干切割机，&lt;code&gt;mask&lt;/code&gt;图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;mask&lt;/code&gt;图层比父图层要小，只有在&lt;code&gt;mask&lt;/code&gt;图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.12.png?imageView/2/w/700&quot; alt=&quot;图4.12&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.12 把图片和蒙板图层作用在一起的效果&lt;/p&gt;
&lt;p&gt;我们将代码演示一下这个过程，创建一个简单的项目，通过图层的&lt;code&gt;mask&lt;/code&gt;属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。&lt;/p&gt;
&lt;p&gt;清单4.5 应用蒙板图层&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIImageView *imageView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //create mask layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CALayer *maskLayer = [CALayer layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  maskLayer.frame = self.imageView.bounds;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIImage *maskImage = [UIImage imageNamed:@&amp;quot;Cone.png&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  maskLayer.contents = (__bridge id)maskImage.CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //apply mask to image layer￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.imageView.layer.mask = maskLayer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.13.png?imageView/2/w/700&quot; alt=&quot;图4.13&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.13 使用了&lt;code&gt;mask&lt;/code&gt;之后的UIImageView&lt;/p&gt;
&lt;p&gt;CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为&lt;code&gt;mask&lt;/code&gt;属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。&lt;/p&gt;
&lt;h2 id=&quot;拉伸过滤&quot;&gt;&lt;a href=&quot;#拉伸过滤&quot; class=&quot;headerlink&quot; title=&quot;拉伸过滤&quot;&gt;&lt;/a&gt;拉伸过滤&lt;/h2&gt;&lt;p&gt;最后我们再来谈谈&lt;code&gt;minificationFilter&lt;/code&gt;和&lt;code&gt;magnificationFilter&lt;/code&gt;属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够显示最好的画质，像素既没有被压缩也没有被拉伸。&lt;/li&gt;
&lt;li&gt;能更好的使用内存，因为这就是所有你要存储的东西。&lt;/li&gt;
&lt;li&gt;最好的性能表现，CPU不需要为此额外的计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。&lt;/p&gt;
&lt;p&gt;当图片需要显示不同的大小的时候，有一种叫做&lt;em&gt;拉伸过滤&lt;/em&gt;的算法就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。&lt;/p&gt;
&lt;p&gt;事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。&lt;code&gt;CALayer&lt;/code&gt;为此提供了三种拉伸过滤方法，他们是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAFilterLinear&lt;/li&gt;
&lt;li&gt;kCAFilterNearest&lt;/li&gt;
&lt;li&gt;kCAFilterTrilinear&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;minification（缩小图片）和magnification（放大图片）默认的过滤器都是&lt;code&gt;kCAFilterLinear&lt;/code&gt;，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kCAFilterTrilinear&lt;/code&gt;和&lt;code&gt;kCAFilterLinear&lt;/code&gt;非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。&lt;/p&gt;
&lt;p&gt;这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.14.png?imageView/2/w/700&quot; alt=&quot;图4.14&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.14 对于大图来说，双线性滤波和三线性滤波表现得更出色&lt;/p&gt;
&lt;p&gt;&lt;code&gt;kCAFilterNearest&lt;/code&gt;是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.15.png?imageView/2/w/700&quot; alt=&quot;图4.15&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.15 对于没有斜线的小图来说，最近过滤算法要好很多&lt;/p&gt;
&lt;p&gt;总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。&lt;/p&gt;
&lt;p&gt;让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.16.png?imageView/2/w/700&quot; alt=&quot;图4.16&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.16 一个简单的运用拼合技术显示的LCD数字风格的像素字体&lt;/p&gt;
&lt;p&gt;我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个&lt;code&gt;IBOutletCollection&lt;/code&gt;对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.17.png?imageView/2/w/700&quot; alt=&quot;图4.17&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.17 在Interface Builder中放置的六个视图&lt;/p&gt;
&lt;p&gt;清单4.6 显示一个LCD风格的时钟&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) NSTimer *timer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;￼￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad]; //get spritesheet image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIImage *digits = [UIImage imageNamed:@&amp;quot;Digits.png&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set up digit views&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  for (UIView *view in self.digitViews) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //set contents&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    view.layer.contents = (__bridge id)digits.CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    view.layer.contentsGravity = kCAGravityResizeAspect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set initial clock time&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self tick];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setDigit:(NSInteger)digit forView:(UIView *)view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //adjust contentsRect to select correct digit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)tick&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //convert time to hours, minutes and seconds&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set hours&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self setDigit:components.hour / 10 forView:self.digitViews[0]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self setDigit:components.hour % 10 forView:self.digitViews[1]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set minutes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self setDigit:components.minute / 10 forView:self.digitViews[2]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self setDigit:components.minute % 10 forView:self.digitViews[3]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set seconds&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self setDigit:components.second / 10 forView:self.digitViews[4]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self setDigit:components.second % 10 forView:self.digitViews[5]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如图4.18，这样做的确起了效果，但是图片看起来模糊了。看起来默认的&lt;code&gt;kCAFilterLinear&lt;/code&gt;选项让我们失望了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.18.png?imageView/2/w/700&quot; alt=&quot;图4.18&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.18 一个模糊的时钟，由默认的&lt;code&gt;kCAFilterLinear&lt;/code&gt;引起&lt;/p&gt;
&lt;p&gt;为了能像图4.19中那样，我们需要在for循环中加入如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.layer.magnificationFilter = kCAFilterNearest;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.19.png?imageView/2/w/700&quot; alt=&quot;图4.19&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.19 设置了最近过滤之后的清晰显示&lt;/p&gt;
&lt;h2 id=&quot;组透明&quot;&gt;&lt;a href=&quot;#组透明&quot; class=&quot;headerlink&quot; title=&quot;组透明&quot;&gt;&lt;/a&gt;组透明&lt;/h2&gt;&lt;p&gt;UIView有一个叫做&lt;code&gt;alpha&lt;/code&gt;的属性来确定视图的透明度。CALayer有一个等同的属性叫做&lt;code&gt;opacity&lt;/code&gt;，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了&lt;code&gt;opacity&lt;/code&gt;属性，那它的子图层都会受此影响。&lt;/p&gt;
&lt;p&gt;iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.20.png?imageView/2/w/700&quot; alt=&quot;图4.20&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.20 右边的渐隐按钮中，里面的标签清晰可见&lt;/p&gt;
&lt;p&gt;这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。&lt;/p&gt;
&lt;p&gt;在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。&lt;/p&gt;
&lt;p&gt;理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的&lt;code&gt;UIViewGroupOpacity&lt;/code&gt;为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果&lt;code&gt;UIViewGroupOpacity&lt;/code&gt;并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。&lt;/p&gt;
&lt;p&gt;另一个方法就是，你可以设置CALayer的一个叫做&lt;code&gt;shouldRasterize&lt;/code&gt;属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。&lt;/p&gt;
&lt;p&gt;为了启用&lt;code&gt;shouldRasterize&lt;/code&gt;属性，我们设置了图层的&lt;code&gt;rasterizationScale&lt;/code&gt;属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了&lt;code&gt;shouldRasterize&lt;/code&gt;属性，你就要确保你设置了&lt;code&gt;rasterizationScale&lt;/code&gt;属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。&lt;/p&gt;
&lt;p&gt;当&lt;code&gt;shouldRasterize&lt;/code&gt;和&lt;code&gt;UIViewGroupOpacity&lt;/code&gt;一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。&lt;/p&gt;
&lt;p&gt;清单4.7 使用&lt;code&gt;shouldRasterize&lt;/code&gt;属性解决组透明问题&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *containerView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UIButton *)customButton&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //create button&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGRect frame = CGRectMake(0, 0, 150, 50);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIButton *button = [[UIButton alloc] initWithFrame:frame];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  button.backgroundColor = [UIColor whiteColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  button.layer.cornerRadius = 10;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //add label&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  frame = CGRectMake(20, 10, 110, 30);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UILabel *label = [[UILabel alloc] initWithFrame:frame];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  label.text = @&amp;quot;Hello World&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  label.textAlignment = NSTextAlignmentCenter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [button addSubview:label];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return button;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //create opaque button&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIButton *button1 = [self customButton];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  button1.center = CGPointMake(50, 150);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self.containerView addSubview:button1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //create translucent button&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIButton *button2 = [self customButton];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  button2.center = CGPointMake(250, 150);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  button2.alpha = 0.5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self.containerView addSubview:button2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //enable rasterization for the translucent button&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  button2.layer.shouldRasterize = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  button2.layer.rasterizationScale = [UIScreen mainScreen].scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-vision-effect-4.21.png?imageView/2/w/700&quot; alt=&quot;图4.21&quot;&gt;&lt;/p&gt;
&lt;p&gt;图4.21 修正后的图&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。&lt;/p&gt;
&lt;p&gt;在第五章，『变换』中，我们将会研究图层变化和3D转换。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;嗯，圆和椭圆还不错，但如果是带圆角的矩形呢？&lt;/p&gt;
&lt;p&gt;我们现在能做到那样了么？&lt;/p&gt;
&lt;p&gt;史蒂芬·乔布斯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在第三章&lt;a href=&quot;http://charsdavy.github.io/2016/08/01/core-animation-geometry-layer/&quot;&gt;『图层几何学』&lt;/a&gt;中讨论了图层的frame，第二章&lt;a href=&quot;http://charsdavy.github.io/2016/07/30/core-aniamtion-host-layer/&quot;&gt;『寄宿图』&lt;/a&gt;则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="Animation" scheme="http://charsdavy.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation (三) 图层几何学</title>
    <link href="http://charsdavy.github.io/2016/08/01/core-animation-geometry-layer/"/>
    <id>http://charsdavy.github.io/2016/08/01/core-animation-geometry-layer/</id>
    <published>2016-08-01T14:21:38.000Z</published>
    <updated>2016-08-05T00:14:21.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;不熟悉几何学的人就不要来这里了&lt;/em&gt; –柏拉图学院入口的签名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第二章&lt;a href=&quot;http://charsdavy.github.io/2016/07/30/core-aniamtion-host-layer/&quot;&gt;『寄宿图』&lt;/a&gt;里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;布局&quot;&gt;&lt;a href=&quot;#布局&quot; class=&quot;headerlink&quot; title=&quot;布局&quot;&gt;&lt;/a&gt;布局&lt;/h2&gt;&lt;p&gt;&lt;code&gt;UIView&lt;/code&gt;有三个比较重要的布局属性：&lt;code&gt;frame&lt;/code&gt;，&lt;code&gt;bounds&lt;/code&gt;和&lt;code&gt;center&lt;/code&gt;，&lt;code&gt;CALayer&lt;/code&gt;对应地叫做&lt;code&gt;frame&lt;/code&gt;，&lt;code&gt;bounds&lt;/code&gt;和&lt;code&gt;position&lt;/code&gt;。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;frame&lt;/code&gt;代表了图层的外部坐标（也就是在父图层上占据的空间），&lt;code&gt;bounds&lt;/code&gt;是内部坐标（{0, 0}通常是图层的左上角），&lt;code&gt;center&lt;/code&gt;和&lt;code&gt;position&lt;/code&gt;都代表了相对于父图层&lt;code&gt;anchorPoint&lt;/code&gt;所在的位置。&lt;code&gt;anchorPoint&lt;/code&gt;的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.1.jpeg?imageView/2/w/700&quot; alt=&quot;图3.1&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.1 &lt;code&gt;UIView&lt;/code&gt;和&lt;code&gt;CALayer&lt;/code&gt;的坐标系&lt;/p&gt;
&lt;p&gt;视图的&lt;code&gt;frame&lt;/code&gt;，&lt;code&gt;bounds&lt;/code&gt;和&lt;code&gt;center&lt;/code&gt;属性仅仅是&lt;em&gt;存取方法&lt;/em&gt;，当操纵视图的&lt;code&gt;frame&lt;/code&gt;，实际上是在改变位于视图下方&lt;code&gt;CALayer&lt;/code&gt;的&lt;code&gt;frame&lt;/code&gt;，不能够独立于图层之外改变视图的&lt;code&gt;frame&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于视图或者图层来说，&lt;code&gt;frame&lt;/code&gt;并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据&lt;code&gt;bounds&lt;/code&gt;，&lt;code&gt;position&lt;/code&gt;和&lt;code&gt;transform&lt;/code&gt;计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值&lt;/p&gt;
&lt;p&gt;记住当对图层做变换的时候，比如旋转或者缩放，&lt;code&gt;frame&lt;/code&gt;实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说&lt;code&gt;frame&lt;/code&gt;的宽高可能和&lt;code&gt;bounds&lt;/code&gt;的宽高不再一致了（图3.2）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.2.jpeg?imageView/2/w/700&quot; alt=&quot;图3.2&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.2 旋转一个视图或者图层之后的&lt;code&gt;frame&lt;/code&gt;属性&lt;/p&gt;
&lt;h2 id=&quot;锚点&quot;&gt;&lt;a href=&quot;#锚点&quot; class=&quot;headerlink&quot; title=&quot;锚点&quot;&gt;&lt;/a&gt;锚点&lt;/h2&gt;&lt;p&gt;之前提到过，视图的&lt;code&gt;center&lt;/code&gt;属性和图层的&lt;code&gt;position&lt;/code&gt;属性都指定了&lt;code&gt;anchorPoint&lt;/code&gt;相对于父图层的位置。图层的&lt;code&gt;anchorPoint&lt;/code&gt;通过&lt;code&gt;position&lt;/code&gt;来控制它的&lt;code&gt;frame&lt;/code&gt;的位置，你可以认为&lt;code&gt;anchorPoint&lt;/code&gt;是用来移动图层的&lt;em&gt;把柄&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;默认来说，&lt;code&gt;anchorPoint&lt;/code&gt;位于图层的中点，所以图层的将会以这个点为中心放置。&lt;code&gt;anchorPoint&lt;/code&gt;属性并没有被&lt;code&gt;UIView&lt;/code&gt;接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的&lt;code&gt;anchorPoint&lt;/code&gt;可以被移动，比如你可以把它置于图层&lt;code&gt;frame&lt;/code&gt;的左上角，于是图层的内容将会向右下角的&lt;code&gt;position&lt;/code&gt;方向移动（图3.3），而不是居中了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.3.jpeg?imageView/2/w/700&quot; alt=&quot;图3.3&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.3 改变&lt;code&gt;anchorPoint&lt;/code&gt;的效果&lt;/p&gt;
&lt;p&gt;和第二章提到的&lt;code&gt;contentsRect&lt;/code&gt;和&lt;code&gt;contentsCenter&lt;/code&gt;属性类似，&lt;code&gt;anchorPoint&lt;/code&gt;用&lt;em&gt;单位坐标&lt;/em&gt;来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。&lt;code&gt;anchorPoint&lt;/code&gt;可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。&lt;/p&gt;
&lt;p&gt;注意在图3.3中，当改变了&lt;code&gt;anchorPoint&lt;/code&gt;，&lt;code&gt;position&lt;/code&gt;属性保持固定的值并没有发生改变，但是&lt;code&gt;frame&lt;/code&gt;却移动了。&lt;/p&gt;
&lt;p&gt;那在什么场合需要改变&lt;code&gt;anchorPoint&lt;/code&gt;呢？既然我们可以随意改变图层位置，那改变&lt;code&gt;anchorPoint&lt;/code&gt;不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。&lt;/p&gt;
&lt;p&gt;钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个&lt;code&gt;UIImageView&lt;/code&gt;实例（当然你也可以用正常的视图，设置他们图层的&lt;code&gt;contents&lt;/code&gt;图片）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.4.jpeg?imageView/2/w/700&quot; alt=&quot;图3.4&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.4 组成钟面和钟表的四张图片&lt;/p&gt;
&lt;p&gt;闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的&lt;code&gt;frame&lt;/code&gt;，而根据图3.2的演示，当视图旋转的时候，&lt;code&gt;frame&lt;/code&gt;是会发生改变的，这将会导致一些布局上的失灵。&lt;/p&gt;
&lt;p&gt;我们用&lt;code&gt;NSTimer&lt;/code&gt;来更新闹钟，使用视图的&lt;code&gt;transform&lt;/code&gt;属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.5.jpeg?imageView/2/w/700&quot; alt=&quot;图3.5&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.5 在Interface Builder中布局闹钟视图&lt;/p&gt;
&lt;p&gt;清单3.1 &lt;strong&gt;Clock&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIImageView *hourHand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIImageView *secondHand;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) NSTimer *timer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  ￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //set initial hand positions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self tick];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)tick&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //convert time to hours, minutes and seconds&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //calculate hour hand angle //calculate minute hand angle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //calculate second hand angle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //rotate hands&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.6.jpeg?imageView/2/w/700&quot; alt=&quot;图3.6&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.6 钟面，和不对齐的钟指针&lt;/p&gt;
&lt;p&gt;你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。&lt;/p&gt;
&lt;p&gt;也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。&lt;/p&gt;
&lt;p&gt;更好的方案是使用&lt;code&gt;anchorPoint&lt;/code&gt;属性，我们来在&lt;code&gt;-viewDidLoad&lt;/code&gt;方法中添加几行代码来给每个钟指针的&lt;code&gt;anchorPoint&lt;/code&gt;做一些平移（清单3.2），图3.7显示了正确的结果。&lt;/p&gt;
&lt;p&gt;清单3.2&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // adjust anchor points&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // start timer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.7.jpeg?imageView/2/w/700&quot; alt=&quot;图3.7&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.7 钟面，和正确对齐的钟指针&lt;/p&gt;
&lt;h2 id=&quot;坐标系&quot;&gt;&lt;a href=&quot;#坐标系&quot; class=&quot;headerlink&quot; title=&quot;坐标系&quot;&gt;&lt;/a&gt;坐标系&lt;/h2&gt;&lt;p&gt;和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的&lt;code&gt;position&lt;/code&gt;依赖于它父图层的&lt;code&gt;bounds&lt;/code&gt;，如果父图层发生了移动，它的所有子图层也会跟着移动。&lt;/p&gt;
&lt;p&gt;这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的&lt;em&gt;绝对&lt;/em&gt;位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CALayer&lt;/code&gt;给不同坐标系之间的图层转换提供了一些工具类方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; 
- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; 
- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;
- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形&lt;/p&gt;
&lt;h3 id=&quot;翻转的几何结构&quot;&gt;&lt;a href=&quot;#翻转的几何结构&quot; class=&quot;headerlink&quot; title=&quot;翻转的几何结构&quot;&gt;&lt;/a&gt;翻转的几何结构&lt;/h3&gt;&lt;p&gt;常规说来，在iOS上，一个图层的&lt;code&gt;position&lt;/code&gt;位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过&lt;code&gt;geometryFlipped&lt;/code&gt;属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个&lt;code&gt;BOOL&lt;/code&gt;类型。在iOS上通过设置它为&lt;code&gt;YES&lt;/code&gt;意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们的&lt;code&gt;geometryFlipped&lt;/code&gt;属性也设为&lt;code&gt;YES&lt;/code&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;Z坐标轴&quot;&gt;&lt;a href=&quot;#Z坐标轴&quot; class=&quot;headerlink&quot; title=&quot;Z坐标轴&quot;&gt;&lt;/a&gt;Z坐标轴&lt;/h3&gt;&lt;p&gt;和&lt;code&gt;UIView&lt;/code&gt;严格的二维坐标系不同，&lt;code&gt;CALayer&lt;/code&gt;存在于一个三维空间当中。除了我们已经讨论过的&lt;code&gt;position&lt;/code&gt;和&lt;code&gt;anchorPoint&lt;/code&gt;属性之外，&lt;code&gt;CALayer&lt;/code&gt;还有另外两个属性，&lt;code&gt;zPosition&lt;/code&gt;和&lt;code&gt;anchorPointZ&lt;/code&gt;，二者都是在Z轴上描述图层位置的浮点类型。&lt;/p&gt;
&lt;p&gt;注意这里并没有更&lt;em&gt;深&lt;/em&gt;的属性来描述由宽和高做成的&lt;code&gt;bounds&lt;/code&gt;了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;zPosition&lt;/code&gt;属性在大多数情况下其实并不常用。在第五章，我们将会涉及&lt;code&gt;CATransform3D&lt;/code&gt;，你会知道如何在三维空间移动和旋转图层，除了做变换之外，&lt;code&gt;zPosition&lt;/code&gt;最实用的功能就是改变图层的&lt;em&gt;显示顺序&lt;/em&gt;了。&lt;/p&gt;
&lt;p&gt;通常，图层是根据它们子图层的&lt;code&gt;sublayers&lt;/code&gt;出现的顺序来类绘制的，这就是所谓的&lt;em&gt;画家的算法&lt;/em&gt;–就像一个画家在墙上作画–后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的&lt;code&gt;zPosition&lt;/code&gt;，就可以把图层向相机方向&lt;em&gt;前置&lt;/em&gt;，于是它就在所有其他图层的&lt;em&gt;前面&lt;/em&gt;了（或者至少是小于它的&lt;code&gt;zPosition&lt;/code&gt;值的图层的前面）。&lt;/p&gt;
&lt;p&gt;这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。&lt;/p&gt;
&lt;p&gt;图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.8.jpeg?imageView/2/w/700&quot; alt=&quot;图3.8&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.8 在视图层级中绿色视图被绘制在红色视图的后面&lt;/p&gt;
&lt;p&gt;我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的&lt;code&gt;zPosition&lt;/code&gt;（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给&lt;code&gt;zPosition&lt;/code&gt;提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。&lt;/p&gt;
&lt;p&gt;清单3.3&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *greenView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *redView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //move the green view zPosition nearer to the camera&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.greenView.layer.zPosition = 1.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.9.jpeg?imageView/2/w/700&quot; alt=&quot;图3.9&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.9 绿色视图被绘制在红色视图的前面&lt;/p&gt;
&lt;h2 id=&quot;Hit-Testing&quot;&gt;&lt;a href=&quot;#Hit-Testing&quot; class=&quot;headerlink&quot; title=&quot;Hit Testing&quot;&gt;&lt;/a&gt;Hit Testing&lt;/h2&gt;&lt;p&gt;第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CALayer&lt;/code&gt;并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：&lt;code&gt;-containsPoint:&lt;/code&gt;和&lt;code&gt;-hitTest:&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-containsPoint:&lt;/code&gt;接受一个在本图层坐标系下的&lt;code&gt;CGPoint&lt;/code&gt;，如果这个点在图层&lt;code&gt;frame&lt;/code&gt;范围内就返回&lt;code&gt;YES&lt;/code&gt;。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用&lt;code&gt;-containsPoint:&lt;/code&gt;方法来判断到底是白色还是蓝色的图层被触摸了&lt;br&gt;（图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。&lt;/p&gt;
&lt;p&gt;清单3.4 使用containsPoint判断被点击的图层&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *layerView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) CALayer *blueLayer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //create sublayer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.blueLayer = [CALayer layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //add it to our view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.layerView.layer addSublayer:self.blueLayer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //get touch position relative to main view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGPoint point = [[touches anyObject] locationInView:self.view];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //convert point to the white layer&amp;apos;s coordinates&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //get layer using containsPoint:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([self.layerView.layer containsPoint:point]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //convert point to blueLayer’s coordinates&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ([self.blueLayer containsPoint:point]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [[[UIAlertView alloc] initWithTitle:@&amp;quot;Inside Blue Layer&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        message:nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       delegate:nil &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              cancelButtonTitle:@&amp;quot;OK&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              otherButtonTitles:nil] show];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [[[UIAlertView alloc] initWithTitle:@&amp;quot;Inside White Layer&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                        message:nil &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                       delegate:nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              cancelButtonTitle:@&amp;quot;OK&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              otherButtonTitles:nil] show];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-animation-geometry-layer-3.10.jpeg?imageView/2/w/700&quot; alt=&quot;图3.10&quot;&gt;&lt;/p&gt;
&lt;p&gt;图3.10 点击图层被正确标识&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-hitTest:&lt;/code&gt;方法同样接受一个&lt;code&gt;CGPoint&lt;/code&gt;类型参数，而不是&lt;code&gt;BOOL&lt;/code&gt;类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用&lt;code&gt;-containsPoint:&lt;/code&gt;那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用&lt;code&gt;-hitTest:&lt;/code&gt;方法被点击图层的代码如清单3.5所示。&lt;/p&gt;
&lt;p&gt;清单3.5 使用hitTest判断被点击的图层&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //get touch position&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGPoint point = [[touches anyObject] locationInView:self.view];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //get touched layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CALayer *layer = [self.layerView.layer hitTest:point];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //get layer using hitTest&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (layer == self.blueLayer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[[UIAlertView alloc] initWithTitle:@&amp;quot;Inside Blue Layer&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    message:nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                   delegate:nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          cancelButtonTitle:@&amp;quot;OK&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          otherButtonTitles:nil] show];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else if (layer == self.layerView.layer) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [[[UIAlertView alloc] initWithTitle:@&amp;quot;Inside White Layer&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                    message:nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                   delegate:nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          cancelButtonTitle:@&amp;quot;OK&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          otherButtonTitles:nil] show];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意当调用图层的&lt;code&gt;-hitTest:&lt;/code&gt;方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的&lt;code&gt;zPosition&lt;/code&gt;属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。&lt;/p&gt;
&lt;p&gt;这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的&lt;code&gt;zPosition&lt;/code&gt;值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。&lt;/p&gt;
&lt;h2 id=&quot;自动布局&quot;&gt;&lt;a href=&quot;#自动布局&quot; class=&quot;headerlink&quot; title=&quot;自动布局&quot;&gt;&lt;/a&gt;自动布局&lt;/h2&gt;&lt;p&gt;你可能用过&lt;code&gt;UIViewAutoresizingMask&lt;/code&gt;类型的一些常量，应用于当父视图改变尺寸的时候，相应&lt;code&gt;UIView&lt;/code&gt;的&lt;code&gt;frame&lt;/code&gt;也跟着更新的场景（通常用于横竖屏切换）。&lt;/p&gt;
&lt;p&gt;在iOS6中，苹果介绍了&lt;em&gt;自动排版&lt;/em&gt;机制，它和自动调整不同，并且更加复杂。&lt;/p&gt;
&lt;p&gt;在Mac OS平台，&lt;code&gt;CALayer&lt;/code&gt;有一个叫做&lt;code&gt;layoutManager&lt;/code&gt;的属性可以通过&lt;code&gt;CALayoutManager&lt;/code&gt;协议和&lt;code&gt;CAConstraintLayoutManager&lt;/code&gt;类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。&lt;/p&gt;
&lt;p&gt;当使用视图的时候，可以充分利用&lt;code&gt;UIView&lt;/code&gt;类接口暴露出来的&lt;code&gt;UIViewAutoresizingMask&lt;/code&gt;和&lt;code&gt;NSLayoutConstraint&lt;/code&gt;API，但如果想随意控制&lt;code&gt;CALayer&lt;/code&gt;的布局，就需要手工操作。最简单的方法就是使用&lt;code&gt;CALayerDelegate&lt;/code&gt;如下函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- (void)layoutSublayersOfLayer:(CALayer *)layer;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当图层的&lt;code&gt;bounds&lt;/code&gt;发生改变，或者图层的&lt;code&gt;-setNeedsLayout&lt;/code&gt;方法被调用的时候，这个函数将会被执行。这使得你可以手动地重新摆放或者重新调整子图层的大小，但是不能像&lt;code&gt;UIView&lt;/code&gt;的&lt;code&gt;autoresizingMask&lt;/code&gt;和&lt;code&gt;constraints&lt;/code&gt;属性做到自适应屏幕旋转。&lt;/p&gt;
&lt;p&gt;这也是为什么最好使用视图而不是单独的图层来构建应用程序的另一个重要原因之一。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本章涉及了&lt;code&gt;CALayer&lt;/code&gt;的集合结构，包括它的&lt;code&gt;frame&lt;/code&gt;，&lt;code&gt;position&lt;/code&gt;和&lt;code&gt;bounds&lt;/code&gt;，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。&lt;/p&gt;
&lt;p&gt;在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;不熟悉几何学的人就不要来这里了&lt;/em&gt; –柏拉图学院入口的签名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在第二章&lt;a href=&quot;http://charsdavy.github.io/2016/07/30/core-aniamtion-host-layer/&quot;&gt;『寄宿图』&lt;/a&gt;里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="Animation" scheme="http://charsdavy.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation (二) 寄宿图</title>
    <link href="http://charsdavy.github.io/2016/07/30/core-aniamtion-host-layer/"/>
    <id>http://charsdavy.github.io/2016/07/30/core-aniamtion-host-layer/</id>
    <published>2016-07-30T13:53:14.000Z</published>
    <updated>2016-08-05T00:12:32.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;图片胜过千言万语，界面抵得上千图片  ——Ben Shneiderman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在第一章&lt;a href=&quot;http://charsdavy.github.io/2016/07/28/core-aniamtion-layer-tree/&quot;&gt;『图层树』&lt;/a&gt;中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;contents属性&quot;&gt;&lt;a href=&quot;#contents属性&quot; class=&quot;headerlink&quot; title=&quot;contents属性&quot;&gt;&lt;/a&gt;contents属性&lt;/h2&gt;&lt;p&gt;CALayer 有一个属性叫做&lt;code&gt;contents&lt;/code&gt;，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给&lt;code&gt;contents&lt;/code&gt;属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给&lt;code&gt;contents&lt;/code&gt;赋的不是CGImage，那么你得到的图层将是空白的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contents&lt;/code&gt;这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在iOS平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。&lt;/p&gt;
&lt;p&gt;头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的&lt;code&gt;contents&lt;/code&gt;，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。&lt;/p&gt;
&lt;p&gt;尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），它们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;layer.contents = (__bridge id)image.CGImage;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！&lt;/p&gt;
&lt;p&gt;让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的&lt;code&gt;contents&lt;/code&gt;属性设置成图片。&lt;/p&gt;
&lt;p&gt;清单2.1 更新后的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad]; //load an image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIImage *image = [UIImage imageNamed:@&amp;quot;Snowman.png&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //add it directly to our view&amp;apos;s layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView.layer.contents = (__bridge id)image.CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;图表2.1 在UIView的宿主图层中显示一张图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.1.png?imageView/2/w/700&quot; alt=&quot;图2.1&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;contentGravity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把&lt;code&gt;contentMode&lt;/code&gt;属性设置成更合适的值，像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.contentMode = UIViewContentModeScaleAspectFit;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如&lt;code&gt;contentMode&lt;/code&gt;，对这些属性的操作其实是对对应图层的操作。&lt;/p&gt;
&lt;p&gt;CALayer与&lt;code&gt;contentMode&lt;/code&gt;对应的属性叫做&lt;code&gt;contentsGravity&lt;/code&gt;，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。&lt;code&gt;contentsGravity&lt;/code&gt;可选的常量值有以下一些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAGravityCenter&lt;/li&gt;
&lt;li&gt;kCAGravityTop&lt;/li&gt;
&lt;li&gt;kCAGravityBottom&lt;/li&gt;
&lt;li&gt;kCAGravityLeft&lt;/li&gt;
&lt;li&gt;kCAGravityRight&lt;/li&gt;
&lt;li&gt;kCAGravityTopLeft&lt;/li&gt;
&lt;li&gt;kCAGravityTopRight&lt;/li&gt;
&lt;li&gt;kCAGravityBottomLeft&lt;/li&gt;
&lt;li&gt;kCAGravityBottomRight&lt;/li&gt;
&lt;li&gt;kCAGravityResize&lt;/li&gt;
&lt;li&gt;kCAGravityResizeAspect&lt;/li&gt;
&lt;li&gt;kCAGravityResizeAspectFill&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;和&lt;code&gt;cotentMode&lt;/code&gt;一样，&lt;code&gt;contentsGravity&lt;/code&gt;的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.layerView.layer.contentsGravity = kCAGravityResizeAspect;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;图2.2 可以看到结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.2.png?imageView/2/w/700&quot; alt=&quot;图2.2&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.2 正确地设置&lt;code&gt;contentsGravity&lt;/code&gt;的值&lt;/p&gt;
&lt;h2 id=&quot;contentsScale&quot;&gt;&lt;a href=&quot;#contentsScale&quot; class=&quot;headerlink&quot; title=&quot;contentsScale&quot;&gt;&lt;/a&gt;contentsScale&lt;/h2&gt;&lt;p&gt;&lt;code&gt;contentsScale&lt;/code&gt;属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contentsScale&lt;/code&gt;的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为&lt;code&gt;contents&lt;/code&gt;由于设置了&lt;code&gt;contentsGravity&lt;/code&gt;属性，所以它已经被拉伸以适应图层的边界。&lt;/p&gt;
&lt;p&gt;如果你只是单纯地想放大图层的&lt;code&gt;contents&lt;/code&gt;图片，你可以通过使用图层的&lt;code&gt;transform&lt;/code&gt;和&lt;code&gt;affineTransform&lt;/code&gt;属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是&lt;code&gt;contentsScale&lt;/code&gt;的目的所在.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contentsScale&lt;/code&gt;属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设置&lt;code&gt;contentsGravity&lt;/code&gt;属性）。UIView有一个类似功能但是非常少用到的&lt;code&gt;contentScaleFactor&lt;/code&gt;属性。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;contentsScale&lt;/code&gt;设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。&lt;/p&gt;
&lt;p&gt;这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把&lt;code&gt;contentsGravity&lt;/code&gt;设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.3.png?imageView/2/w/700&quot; alt=&quot;图2.3&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.3 用错误的&lt;code&gt;contentsScale&lt;/code&gt;属性显示Retina图片&lt;/p&gt;
&lt;p&gt;如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，它读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置&lt;code&gt;contentsScale&lt;/code&gt;来修复这个问题（如2.2清单），图2.4是结果&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad]; //load an image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIImage *image = [UIImage imageNamed:@&amp;quot;Snowman.png&amp;quot;]; //add it directly to our view&amp;apos;s layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView.layer.contentsGravity = kCAGravityCenter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set the contentsScale to match image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  self.layerView.layer.contentsScale = image.scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.4.png?imageView/2/w/700&quot; alt=&quot;图2.4&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.4 同样的Retina图片设置了正确的&lt;code&gt;contentsScale&lt;/code&gt;之后&lt;/p&gt;
&lt;p&gt;当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的&lt;code&gt;contentsScale&lt;/code&gt;属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;layer.contentsScale = [UIScreen mainScreen].scale;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;maskToBounds&quot;&gt;&lt;a href=&quot;#maskToBounds&quot; class=&quot;headerlink&quot; title=&quot;maskToBounds&quot;&gt;&lt;/a&gt;maskToBounds&lt;/h2&gt;&lt;p&gt;现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：它超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。&lt;/p&gt;
&lt;p&gt;UIView有一个叫做&lt;code&gt;clipsToBounds&lt;/code&gt;的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做&lt;code&gt;masksToBounds&lt;/code&gt;，把它设置为YES，雪人就在边界里啦～（如图2.5）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.5.png?imageView/2/w/700&quot; alt=&quot;图2.5&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.5 使用&lt;code&gt;masksToBounds&lt;/code&gt;来修建图层内容&lt;/p&gt;
&lt;h2 id=&quot;contentsRect&quot;&gt;&lt;a href=&quot;#contentsRect&quot; class=&quot;headerlink&quot; title=&quot;contentsRect&quot;&gt;&lt;/a&gt;contentsRect&lt;/h2&gt;&lt;p&gt;CALayer的&lt;code&gt;contentsRect&lt;/code&gt;属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要比&lt;code&gt;contentsGravity&lt;/code&gt;灵活多了&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;bounds&lt;/code&gt;，&lt;code&gt;frame&lt;/code&gt;不同，&lt;code&gt;contentsRect&lt;/code&gt;不是按点来计算的，它使用了&lt;em&gt;单位坐标&lt;/em&gt;，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以它们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。&lt;/li&gt;
&lt;li&gt;像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，它们表现出来了不同的大小。&lt;/li&gt;
&lt;li&gt;单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认的&lt;code&gt;contentsRect&lt;/code&gt;是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.6.png?imageView/2/w/700&quot; alt=&quot;图2.6&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.6 一个自定义的&lt;code&gt;contentsRect&lt;/code&gt;（左）和之前显示的内容（右）&lt;/p&gt;
&lt;p&gt;事实上给&lt;code&gt;contentsRect&lt;/code&gt;设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contentsRect&lt;/code&gt;在app中最有趣的地方在于一个叫做&lt;em&gt;image sprites&lt;/em&gt;（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。&lt;/p&gt;
&lt;p&gt;典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等&lt;/p&gt;
&lt;p&gt;2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用&lt;code&gt;contentsRect&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.7.png?imageView/2/w/700&quot; alt=&quot;图2.7&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的&lt;code&gt;contents&lt;/code&gt;，然后设置每个图层的&lt;code&gt;contentsRect&lt;/code&gt;来去掉我们不想显示的部分。&lt;/p&gt;
&lt;p&gt;我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来访问它们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *coneView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *shipView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *iglooView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *anchorView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  layer.contents = (__bridge id)image.CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //scale contents to fit&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  layer.contentsGravity = kCAGravityResizeAspect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set contentsRect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  layer.contentsRect = rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad]; //load sprite sheet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIImage *image = [UIImage imageNamed:@&amp;quot;Sprites.png&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set igloo sprite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set cone sprite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set anchor sprite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set spaceship sprite&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.8.png?imageView/2/w/700&quot; alt=&quot;图2.8&quot;&gt;&lt;/p&gt;
&lt;p&gt;拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入得更快），但是如果有手动安排的话，它们还是有一些不方便的，如果你需要在一个已经创建好的拼合图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。&lt;/p&gt;
&lt;p&gt;Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置&lt;code&gt;contentsRect&lt;/code&gt;，这样开发者就不用手动写代码来摆放位置了。&lt;/p&gt;
&lt;p&gt;这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（&lt;a href=&quot;https://github.com/nicklockwood/LayerSprites&quot;&gt;https://github.com/nicklockwood/LayerSprites&lt;/a&gt;)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。&lt;/p&gt;
&lt;h2 id=&quot;contentsCenter&quot;&gt;&lt;a href=&quot;#contentsCenter&quot; class=&quot;headerlink&quot; title=&quot;contentsCenter&quot;&gt;&lt;/a&gt;contentsCenter&lt;/h2&gt;&lt;p&gt;本章我们介绍的最后一个和内容有关的属性是&lt;code&gt;contentsCenter&lt;/code&gt;，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。&lt;code&gt;contentsCenter&lt;/code&gt;其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变&lt;code&gt;contentsCenter&lt;/code&gt;的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;contentsCenter&lt;/code&gt;是{0, 0, 1, 1}，这意味着如果大小（由&lt;code&gt;conttensGravity&lt;/code&gt;决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了&lt;code&gt;contentsCenter&lt;/code&gt;设置为{0.25, 0.25, 0.5, 0.5}的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.9.png?imageView/2/w/700&quot; alt=&quot;图2.9&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.9 &lt;code&gt;contentsCenter&lt;/code&gt;的例子&lt;/p&gt;
&lt;p&gt;这意味着我们可以随意重设尺寸，边框仍然会是连续的。它工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.10.png?imageView/2/w/700&quot; alt=&quot;图2.10&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.10 同一图片使用不同的&lt;code&gt;contentsCenter&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11&lt;/p&gt;
&lt;p&gt;清单2.4 用&lt;code&gt;contentsCenter&lt;/code&gt;设置可拉伸视图&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *button1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) IBOutlet UIView *button2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)addStretchableImage:(UIImage *)image withContentCenter:(CGRect)rect toLayer:(CALayer *)layer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  layer.contents = (__bridge id)image.CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set contentsCenter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  layer.contentsCenter = rect;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad]; //load button image&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  UIImage *image = [UIImage imageNamed:@&amp;quot;Button.png&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set button 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button1.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set button 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self addStretchableImage:image withContentCenter:CGRectMake(0.25, 0.25, 0.5, 0.5) toLayer:self.button2.layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.11.png?imageView/2/w/700&quot; alt=&quot;图2.11&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.11 用Interface Builder 探测窗口控制&lt;code&gt;contentsCenter&lt;/code&gt;属性&lt;/p&gt;
&lt;h2 id=&quot;Custome-Drawing&quot;&gt;&lt;a href=&quot;#Custome-Drawing&quot; class=&quot;headerlink&quot; title=&quot;Custome Drawing&quot;&gt;&lt;/a&gt;Custome Drawing&lt;/h2&gt;&lt;p&gt;给&lt;code&gt;contents&lt;/code&gt;赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现&lt;code&gt;-drawRect:&lt;/code&gt;方法来自定义绘制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-drawRect:&lt;/code&gt; 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到&lt;code&gt;-drawRect:&lt;/code&gt; 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 &lt;code&gt;contentsScale&lt;/code&gt;的值。&lt;/p&gt;
&lt;p&gt;如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。&lt;/p&gt;
&lt;p&gt;当视图在屏幕上出现的时候 &lt;code&gt;-drawRect:&lt;/code&gt;方法就会被自动调用。&lt;code&gt;-drawRect:&lt;/code&gt;方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了&lt;code&gt;-setNeedsDisplay&lt;/code&gt;方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如&lt;code&gt;bounds&lt;/code&gt;属性）。虽然&lt;code&gt;-drawRect:&lt;/code&gt;方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。&lt;/p&gt;
&lt;p&gt;CALayer有一个可选的&lt;code&gt;delegate&lt;/code&gt;属性，实现了&lt;code&gt;CALayerDelegate&lt;/code&gt;协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（&lt;code&gt;delegate&lt;/code&gt;属性被声明为id类型，所有的代理方法都是可选的）。&lt;/p&gt;
&lt;p&gt;当需要被重绘时，CALayer会请求它的代理给它一个寄宿图来显示。它通过调用下面这个方法做到的:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)displayLayer:(CALayer *)layer;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;趁着这个机会，如果代理想直接设置&lt;code&gt;contents&lt;/code&gt;属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现&lt;code&gt;-displayLayer:&lt;/code&gt;方法，CALayer就会转而尝试调用下面这个方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由&lt;code&gt;bounds&lt;/code&gt;和&lt;code&gt;contentsScale&lt;/code&gt;决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，它作为ctx参数传入。&lt;/p&gt;
&lt;p&gt;让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是它的结果&lt;/p&gt;
&lt;p&gt;清单2.5 实现CALayerDelegate&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//objective-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ￼&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //create sublayer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CALayer *blueLayer = [CALayer layer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  blueLayer.backgroundColor = [UIColor blueColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //set controller as layer delegate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  blueLayer.delegate = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //ensure that layer backing image uses correct scale&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [self.layerView.layer addSublayer:blueLayer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //force layer to redraw&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [blueLayer display];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  //draw a thick red circle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGContextSetLineWidth(ctx, 10.0f); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  CGContextStrokeEllipseInRect(ctx, layer.bounds);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/core-aniamtion-host-layer-2.12.png?imageView/2/w/700&quot; alt=&quot;图2.12&quot;&gt;&lt;/p&gt;
&lt;p&gt;图2.12 实现CALayerDelegate来绘制图层&lt;/p&gt;
&lt;p&gt;注意一下一些有趣的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们在blueLayer上显式地调用了&lt;code&gt;-display&lt;/code&gt;。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。&lt;/li&gt;
&lt;li&gt;尽管我们没有用&lt;code&gt;masksToBounds&lt;/code&gt;属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个&lt;code&gt;-displayLayer:&lt;/code&gt;的实现，那所有的问题就都没了。&lt;/p&gt;
&lt;p&gt;当使用寄宿了视图的图层的时候，你也不必实现&lt;code&gt;-displayLayer:&lt;/code&gt;和&lt;code&gt;-drawLayer:inContext:&lt;/code&gt;方法来绘制你的寄宿图。通常做法是实现UIView的&lt;code&gt;-drawRect:&lt;/code&gt;方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用&lt;code&gt;-display&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。&lt;/p&gt;
&lt;p&gt;在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察它们是如何放置和改变相互的尺寸的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;图片胜过千言万语，界面抵得上千图片  ——Ben Shneiderman&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在第一章&lt;a href=&quot;http://charsdavy.github.io/2016/07/28/core-aniamtion-layer-tree/&quot;&gt;『图层树』&lt;/a&gt;中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="Animation" scheme="http://charsdavy.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>睡前谈谈 CAAnimation 动画相关</title>
    <link href="http://charsdavy.github.io/2016/07/29/animation-caanimation/"/>
    <id>http://charsdavy.github.io/2016/07/29/animation-caanimation/</id>
    <published>2016-07-29T11:55:33.000Z</published>
    <updated>2016-08-03T12:25:04.000Z</updated>
    
    <content type="html">&lt;p&gt;要让一个 CALayer 动起來，除了通过改变 layer 的 animanatable 的属性外，就是建立 CAAnimation 实例，然后 layer 调用 -addAnimation:forKey:。我们通常会选择一种 CALayer 的 subclass，制作我们想要的动画效果。&lt;/p&gt;
&lt;p&gt;这里我们来好好看看 CAAnimation 相关知识，以期使用它来完成我们想要的动画效果。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;CATransition&quot;&gt;&lt;a href=&quot;#CATransition&quot; class=&quot;headerlink&quot; title=&quot;CATransition&quot;&gt;&lt;/a&gt;CATransition&lt;/h1&gt;&lt;p&gt;我们先从 Core Animation 內的转场效果 CATransition 讲起（请不要跟 CATransaction 搞混），因为 CATransition 大概是最容易上手，而且可以马上有成就感的动画。CATransition 通常用在两个 view 之间的切换；UIView 本身就有定义一些跟转场有几个以 transition 开头的 class method，像是&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+ transitionWithView:duration:options:animations:completion:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ transitionFromView:toView:duration:options:completion:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而这些 method 可以设定的 tansition option 包括：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionNone&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionFlipFromLeft&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionFlipFromRight&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionCurlUp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionCurlDown&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionCrossDissolve&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionFlipFromTop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationOptionTransitionFlipFromBottom&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也就是说，UIView 本身就已经提供了四种方向的翻转（上下左右）、淡入淡出与翻页几种转场效果。其实这些效果都是用 Core Animation 实现的，而 CATransition 所提供的效果也远比这些多，只要我们知道怎样使用 CATransition，就可以使用更多的转场效果。&lt;/p&gt;
&lt;p&gt;我们来写一个简单的 view controller：这个 view controller 的 view 上面我们额外建立一个 CALayer，然后加了一个按钮，这个按钮按下去之后的 action 是让这个 layer 在红色与绿色之间切换。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//ViewController.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@import UIKit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@import QuartzCore;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController : UIViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)toggleColor:(id)sender;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//ViewController.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;ViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface ViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (strong, nonatomic) CALayer *aLayer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) BOOL isGreen;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation ViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.aLayer = [[CALayer alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.aLayer.frame = CGRectMake(50, 50, 100, 100);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.aLayer.backgroundColor = [UIColor redColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view.layer addSublayer:self.aLayer];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)toggleColor:(id)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.isGreen = !self.isGreen;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.aLayer.backgroundColor = self.isGreen ? [UIColor greenColor].CGColor : [UIColor redColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原本这个版本只会产生 0.25 秒的属性变化，使用的是淡入淡出效果。我们来加入 kCATransitionMoveIn 这个转场效果看看，就会变成新的画面从上方推入。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)toggleColor:(id)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.isGreen = !self.isGreen;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.aLayer.backgroundColor = self.isGreen ? [UIColor greenColor].CGColor : [UIColor redColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CATransition *transition = [[CATransition alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transition.type = kCATransitionMoveIn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    transition.subtype = kCATransitionFromRight;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.aLayer addAnimation:transition forKey:@&amp;quot;tansition&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CATransition 可以应用的地方不只是切换背景颜色而已，无论是改变这个 layer 的任何 animatable 的属性，像是改变 contents，或是在这个 layer 中增加或移除 sublayer，用 addAnimation:forKey: 加入了 CATransition 实例之后，都可以产生转场效果。&lt;/p&gt;
&lt;p&gt;如果我们想要像 UIView 的 &lt;code&gt;+transitionWithView:duration:options:animations:completion:&lt;/code&gt;那样，是在某个 view 上面增加或移除 subview 的时候产生转场效果，用 CATransition 的作法也差不多，我们先写好要某个 view A 新增或移除 subview，然后把 CATransition 加到 view A 的 layer 上即可。&lt;/p&gt;
&lt;p&gt;苹果在 iOS 上的 CATransition 的 public header 中定义了几个 type：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;kCATransitionFade：淡入淡出动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCATransitionMoveIn：新的画面从上方移入的效果&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCATransitionPush：推挤效果，很像 navigation controller 的换页&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCATransitionReveal：原本的画面从上方移出的效果&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不过…其实苹果有不少 private API 可以用。比方说，我们可以把 type 指定成立体块状翻转效果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transition.type = @&amp;quot;cube&amp;quot;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;http://iphonedevwiki.net/index.php/CATransition&quot;&gt;http://iphonedevwiki.net/index.php/CATransition&lt;/a&gt; 这一页上可以看到整理好的 private API 可以调用。虽然苹果的政策是禁止在上架的 app 中调用 private API，如果用了可能会被 reject…不过印象中其实有很多 app 都用到这些 private API。&lt;/p&gt;
&lt;p&gt;如果对內部的这些效果，甚至 private 的效果都不满意的話，iOS 5 之后， CATransition 还有一个叫做 filter 的属性，我们可以在这个属性上加上 CIFilter 实例，定义更多的转场效果。&lt;/p&gt;
&lt;p&gt;另外要注意，在我們调用 &lt;code&gt;addAnimation:forKey:&lt;/code&gt; 的时候，如果加入的是个 CATransition 动画，无论使用了怎样的名称当做 key，key 都会是 transition。&lt;/p&gt;
&lt;h1 id=&quot;CAPropertyAnimation&quot;&gt;&lt;a href=&quot;#CAPropertyAnimation&quot; class=&quot;headerlink&quot; title=&quot;CAPropertyAnimation&quot;&gt;&lt;/a&gt;CAPropertyAnimation&lt;/h1&gt;&lt;p&gt;CAPropertyAnimation 便是通过设定某个 CALayer 的属性产生动画。前面提到，只要修改 layer 的 animatable 属性会自动产生动画效果，不过，跟使用 CAPropertyAnimation 的状况不太一样，我们对某个 layer 加入了 CAPropertyAnimation 之后，虽然会产生动画，但是就只有产生动画而已， layer 属性原本的值并不会因此改变，用苹果的术语，这种动画叫做 Explicit Animations。&lt;/p&gt;
&lt;p&gt;CAPropertyAnimation 是一层 layer，我们通常使用的是 CAPropertyAnimation 的 subclass CABasicAnimation。设定 CABasicAnimation 的时候，主要会设定以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fromValue: 要让某个属性产生变化的动画时的初始值&lt;/li&gt;
&lt;li&gt;toValue: 要让某个属性产生变化的动画时结束的数值&lt;/li&gt;
&lt;li&gt;byValue: 要让某个属性产生变化的动画时，介于开始与结束的中间值，但是很多时候可以不用特別设定，设成 nil 即可&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后有一些设定是定义在 CAMediaTiming protocol 中，像是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;duration: 这个动画要花上多少时间&lt;/li&gt;
&lt;li&gt;repeatCount: 我们要执行这个动画几次，如果只要跑一次这个动画，设定成 1 即可；如果我们想要这个动画一直跑的话，不妨就把这个动画设成 NSNotFound，NSNotFound 就是整数的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比方说，当我们想要让某个 layer 一直不停的旋转，我们可以修改 transform.rotation.x、transform.rotation.y、transform.rotation.z 等，要求这个 layer 是按照 x、y 还是 z 轴旋转，我们可以让 fromValue 设成 0，代表是初始还没旋转的状态，至于 toValue 设成 M_PI * 2，代表要旋转 360 度。像以下这段代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.aLayer = [[CALayer alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.aLayer.frame = CGRectMake(50, 50, 100, 100);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.aLayer.backgroundColor = [UIColor redColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *rotateAnimation = [CABasicAnimation animationWithKeyPath:@&amp;quot;transform.rotation.z&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rotateAnimation.fromValue = @0.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rotateAnimation.toValue = @(M_PI * 2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rotateAnimation.autoreverses = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rotateAnimation.repeatCount = NSUIntegerMax;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;rotateAnimation.duration = 2.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.aLayer addAnimation:rotateAnimation forKey:@&amp;quot;x&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view.layer addSublayer:self.aLayer];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;CAKeyframeAnimation&quot;&gt;&lt;a href=&quot;#CAKeyframeAnimation&quot; class=&quot;headerlink&quot; title=&quot;CAKeyframeAnimation&quot;&gt;&lt;/a&gt;CAKeyframeAnimation&lt;/h1&gt;&lt;p&gt;关键帧动画就是在动画控制过程中开发者指定主要的动画状态，至于各个状态间动画如何进行则由系统自动运算补充（每两个关键帧之间系统形成的动画称为“补间动画”），这种动画的好处就是开发者不用逐个控制每个动画帧，而只要关心几个关键帧的状态即可。&lt;/p&gt;
&lt;p&gt;使用 CAKeyframeAnimation 与 CABasicAnimation 的主要差別在于，我们想要通过改变某个属性产生动画时，不是设定初始值与结束值，而是使用一个贝茲曲线描述（是 CGPath）。所以，当我们希望动画不只是直线前进，而是按照某种曲线移动的时候，就可以使用 CAKeyframeAnimation。&lt;/p&gt;
&lt;p&gt;关键帧动画和基本动画也很相似，通过keyPath设置动画类型，才对齐进行一组关键值的设定。数据变化也有2种形式，一种是关键点，一种是路径，比如实例中的按一个贝塞尔弧移动view。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//关键帧动画&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//keyPath和animationWithKeyPath的类型相同&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let keyframeAnimation = CAKeyframeAnimation(keyPath: &amp;quot;position&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//线段的位置移动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        keyframeAnimation.values = [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 10, y: 100)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 30, y: 100)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 30, y: 120)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 60, y: 120)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 60, y: 100)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 106, y: 210)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 106, y: 410)),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                        NSValue(CGPoint: CGPoint(x: 300, y: 310))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//                                   ]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//弧线位置移动&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;let path = CGPathCreateMutable()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGPathMoveToPoint(path, nil, 50, 50)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGPathAddCurveToPoint(path, nil, 50, 50, 700, 300, 30, 500)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;keyframeAnimation.path = path&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//设置其他属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;keyframeAnimation.duration = 1.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        keyframeAnimation.beginTime = CACurrentMediaTime() + 2;//设置延迟2秒执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tapGesture.view?.layer.addAnimation(keyframeAnimation, forKey: &amp;quot;keyframeAnimation1&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;关键帧动画其他可以设置的参数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//keyTimes：各个关键帧的时间控制&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//caculationMode：动画计算模式。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCAAnimationLinear: 线性模式，默认值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCAAnimationDiscrete: 离散模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCAAnimationPaced:均匀处理，会忽略keyTimes&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCAAnimationCubic:平滑执行，对于位置变动关键帧动画运行轨迹更平滑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCAAnimationCubicPaced:平滑均匀执行&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;CAAnimationGroup&quot;&gt;&lt;a href=&quot;#CAAnimationGroup&quot; class=&quot;headerlink&quot; title=&quot;CAAnimationGroup&quot;&gt;&lt;/a&gt;CAAnimationGroup&lt;/h1&gt;&lt;p&gt;一个 CALayer 可以同时执行多个 CAAnimation，当我们加入了一个 CAAnimation 之后，就会立刻执行这个动画。而我们也可以把很多个 animation 实例包装成群组（像是 layer 一边移动位置一边翻转），方法就是创建 CAAnimationGroup 实例，然后把想要变成群组的其他动画，变成 array，设定成 CAAnimationGroup 的 animations property。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CAAnimationGroup *group = [CAAnimationGroup animation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;group.duration = 0.5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;group.animations = @[positionAnimation, flipAnimation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;group.delegate = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[aLayer addAnimation:group forKey:@&amp;quot;group&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;CABasicAnimation&quot;&gt;&lt;a href=&quot;#CABasicAnimation&quot; class=&quot;headerlink&quot; title=&quot;CABasicAnimation&quot;&gt;&lt;/a&gt;CABasicAnimation&lt;/h1&gt;&lt;p&gt;CABasicAnimation 能够设定基础动画。&lt;/p&gt;
&lt;h2 id=&quot;实例化&quot;&gt;&lt;a href=&quot;#实例化&quot; class=&quot;headerlink&quot; title=&quot;实例化&quot;&gt;&lt;/a&gt;实例化&lt;/h2&gt;&lt;p&gt;使用方法&lt;code&gt;animationWithKeyPath:&lt;/code&gt;对 CABasicAnimation进行实例化，并指定Layer的属性作为关键路径进行注册。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//围绕y轴旋转&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *transformAnima = [CABasicAnimation animationWithKeyPath:@&amp;quot;transform.rotation.y&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;设定动画&quot;&gt;&lt;a href=&quot;#设定动画&quot; class=&quot;headerlink&quot; title=&quot;设定动画&quot;&gt;&lt;/a&gt;设定动画&lt;/h2&gt;&lt;p&gt;设定动画的属性和说明&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;duration&lt;/td&gt;
&lt;td&gt;动画的时长&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeatCount&lt;/td&gt;
&lt;td&gt;重复的次数。不停重复设置为 HUGE_VALF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;repeatDuration&lt;/td&gt;
&lt;td&gt;设置动画的时间。在该时间内动画一直执行，不计次数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;beginTime&lt;/td&gt;
&lt;td&gt;指定动画开始的时间。从开始延迟几秒的话，设置为【CACurrentMediaTime() + 秒数】 的方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;timingFunction&lt;/td&gt;
&lt;td&gt;设置动画的速度变化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;autoreverses&lt;/td&gt;
&lt;td&gt;动画结束时是否执行逆动画&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;fromValue&lt;/td&gt;
&lt;td&gt;所改变属性的起始值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toValue&lt;/td&gt;
&lt;td&gt;所改变属性的结束时的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;byValue&lt;/td&gt;
&lt;td&gt;所改变属性相同起始值的改变量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.fromValue = @(M_PI_2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.toValue = @(M_PI);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.autoreverses = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.repeatCount = HUGE_VALF;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.beginTime = CACurrentMediaTime() + 2;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;防止动画结束后回到初始状态&lt;br&gt;只需设置&lt;code&gt;removedOnCompletion&lt;/code&gt;、&lt;code&gt;fillMode&lt;/code&gt;两个属性就可以了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.removedOnCompletion = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.fillMode = kCAFillModeForwards;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;为什么动画结束后返回原状态？&lt;/p&gt;
&lt;p&gt;首先我们需要搞明白一点的是，layer动画运行的过程是怎样的？其实在我们给一个视图添加layer动画时，真正移动并不是我们的视图本身，而是 presentation layer 的一个缓存。动画开始时 presentation layer开始移动，原始layer隐藏，动画结束时，presentation layer从屏幕上移除，原始layer显示。这就解释了为什么我们的视图在动画结束后又回到了原来的状态，因为它根本就没动过。&lt;/p&gt;
&lt;p&gt;这个同样也可以解释为什么在动画移动过程中，我们为何不能对其进行任何操作。&lt;/p&gt;
&lt;p&gt;所以在我们完成layer动画之后，最好将我们的layer属性设置为我们最终状态的属性，然后将presentation layer 移除掉。&lt;/p&gt;
&lt;h2 id=&quot;添加动画&quot;&gt;&lt;a href=&quot;#添加动画&quot; class=&quot;headerlink&quot; title=&quot;添加动画&quot;&gt;&lt;/a&gt;添加动画&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView.layer addAnimation:transformAnima forKey:@&amp;quot;A&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;需要注意:&lt;/p&gt;
&lt;p&gt;1)一个 CABasicAniamtion 的实例对象只是一个数据模型，和它绑定到哪一个layer上是没有关系的。&lt;/p&gt;
&lt;p&gt;2)方法&lt;code&gt;addAnimation:forKey:&lt;/code&gt;是将 CABasicAniamtion 对象进行了 copy 操作的。所以在将其添加到一个layer上之后，我们还可以将其再次添加到另一个layer上的。&lt;/p&gt;
&lt;h2 id=&quot;fillMode属性的理解&quot;&gt;&lt;a href=&quot;#fillMode属性的理解&quot; class=&quot;headerlink&quot; title=&quot;fillMode属性的理解&quot;&gt;&lt;/a&gt;fillMode属性的理解&lt;/h2&gt;&lt;p&gt;该属性定义了你的动画在开始和结束时的动作。默认值是 kCAFillModeRemoved。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAFillModeRemoved 设置为该值，动画将在设置的 beginTime 开始执行（如没有设置beginTime属性，则动画立即执行），动画执行完成后将会layer的改变恢复原状。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-1.png?imageView/2/w/500&quot; alt=&quot;kCAFillModeRemoved&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAFillModeForwards 设置为该值，动画即使之后layer的状态将保持在动画的最后一帧，而removedOnCompletion的默认属性值是 YES，所以为了使动画结束之后layer保持结束状态，应将removedOnCompletion设置为NO。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-2.png?imageView/2/w/500&quot; alt=&quot;kCAFillModeForwards&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAFillModeBackwards 设置为该值，将会立即执行动画的第一帧，不论是否设置了 beginTime属性。观察发现，设置该值，刚开始视图不见，还不知道应用在哪里。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-3.png?imageView/2/w/500&quot; alt=&quot;kCAFillModeBackwards&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAFillModeBoth 该值是 kCAFillModeForwards 和 kCAFillModeBackwards的组合状态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-4.png?imageView/2/w/500&quot; alt=&quot;kCAFillModeBoth&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Animation-Easing的使用&quot;&gt;&lt;a href=&quot;#Animation-Easing的使用&quot; class=&quot;headerlink&quot; title=&quot;Animation Easing的使用&quot;&gt;&lt;/a&gt;Animation Easing的使用&lt;/h2&gt;&lt;p&gt;即属性timingFunction值的设定，有种方式来获取属性值&lt;/p&gt;
&lt;p&gt;（1）使用方法&lt;code&gt;functionWithName:&lt;/code&gt;&lt;br&gt;这种方式很简单，这里只是简单说明一下取值的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAMediaTimingFunctionLinear 传这个值，在整个动画时间内动画都是以一个相同的速度来改变。也就是匀速运动。&lt;/li&gt;
&lt;li&gt;kCAMediaTimingFunctionEaseIn 使用该值，动画开始时会较慢，之后动画会加速。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-5.png?imageView/2/w/500&quot; alt=&quot;kCAMediaTimingFunctionEaseIn&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAMediaTimingFunctionEaseOut 使用该值，动画在开始时会较快，之后动画速度减慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-6.png?imageView/2/w/500&quot; alt=&quot;kCAMediaTimingFunctionEaseOut&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCAMediaTimingFunctionEaseInEaseOut 使用该值，动画在开始和结束时速度较慢，中间时间段内速度较快。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-7.png?imageView/2/w/500&quot; alt=&quot;kCAMediaTimingFunctionEaseInEaseOut&quot;&gt;&lt;/p&gt;
&lt;p&gt;(2)使用方法&lt;code&gt;functionWithControlPoints: : : :&lt;/code&gt; 实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/annimation-caanimation-0.png&quot; alt=&quot;动画类型效果&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他的一些设置属性&quot;&gt;&lt;a href=&quot;#其他的一些设置属性&quot; class=&quot;headerlink&quot; title=&quot;其他的一些设置属性&quot;&gt;&lt;/a&gt;其他的一些设置属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;repeatCount 设置动画的执行次数&lt;/li&gt;
&lt;li&gt;autoreverses 默认值为 NO，将其设置为 YES&lt;/li&gt;
&lt;li&gt;speed 改变动画的速度 可以直接设置动画上的speed属性，这样只有这个动画速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;animation.speed = 2;&lt;/code&gt;或者在layer上设置speed属性，这样在该视图上的所有动画都提速，该视图上的所有子视图上的动画也会提速。&lt;/p&gt;
&lt;p&gt;speed需注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果设置动画时间为4s，speed设置为2，则动画只需2s即可执行完。&lt;/li&gt;
&lt;li&gt;如果同时设置了动画的speed和layer 的speed，则实际的speed为两者相乘。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用总结&quot;&gt;&lt;a href=&quot;#使用总结&quot; class=&quot;headerlink&quot; title=&quot;使用总结&quot;&gt;&lt;/a&gt;使用总结&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在动画执行完成之后，最好还是将动画移除掉。也就是尽量不要设置removedOnCompletion属性为NO&lt;/li&gt;
&lt;li&gt;fillMode尽量取默认值就好了，不要去设置它的值。只有在极个别的情况下我们会修改它的值。&lt;/li&gt;
&lt;li&gt;解决有时视图会闪动一下的问题，我们可以将layer的属性值设置为我们的动画最后要达到的值，然后再给我们的视图添加layer动画。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;移动动画实现示例&quot;&gt;&lt;a href=&quot;#移动动画实现示例&quot; class=&quot;headerlink&quot; title=&quot;移动动画实现示例&quot;&gt;&lt;/a&gt;移动动画实现示例&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *positionAnima = [CABasicAnimation animationWithKeyPath:@&amp;quot;position.y&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.duration = 0.8;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.fromValue = @(self.imageView.center.y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.toValue = @(self.imageView.center.y-30);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.repeatCount = HUGE_VALF;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.repeatDuration = 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.removedOnCompletion = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.fillMode = kCAFillModeForwards;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView.layer addAnimation:positionAnima forKey:@&amp;quot;AnimationMoveY&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;组合动画的实现&quot;&gt;&lt;a href=&quot;#组合动画的实现&quot; class=&quot;headerlink&quot; title=&quot;组合动画的实现&quot;&gt;&lt;/a&gt;组合动画的实现&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *positionAnima = [CABasicAnimation animationWithKeyPath:@&amp;quot;position.y&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.fromValue = @(self.imageView.center.y);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.toValue = @(self.imageView.center.y-30);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CABasicAnimation *transformAnima = [CABasicAnimation animationWithKeyPath:@&amp;quot;transform.rotation.y&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.fromValue = @(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.toValue = @(M_PI);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;transformAnima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CAAnimationGroup *animaGroup = [CAAnimationGroup animation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;animaGroup.duration = 2.0f;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;animaGroup.fillMode = kCAFillModeForwards;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;animaGroup.removedOnCompletion = NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;animaGroup.animations = @[positionAnima,transformAnima];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView.layer addAnimation:animaGroup forKey:@&amp;quot;Animation&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;动画开始和结束时的事件&quot;&gt;&lt;a href=&quot;#动画开始和结束时的事件&quot; class=&quot;headerlink&quot; title=&quot;动画开始和结束时的事件&quot;&gt;&lt;/a&gt;动画开始和结束时的事件&lt;/h3&gt;&lt;p&gt;为了获取动画的开始和结束事件，需要实现协议&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;positionAnima.delegate = self;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;代理方法实现&quot;&gt;&lt;a href=&quot;#代理方法实现&quot; class=&quot;headerlink&quot; title=&quot;代理方法实现&quot;&gt;&lt;/a&gt;代理方法实现&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//动画开始时&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)animationDidStart:(CAAnimation *)anim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;开始了&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//动画结束时&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //方法中的flag参数表明了动画是自然结束还是被打断,比如调用了removeAnimationForKey:方法或removeAnimationForKey方法，flag为NO，如果是正常结束，flag为YES。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;结束了&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实比较重要的是有多个动画的时候如何在代理方法中区分不同的动画&lt;br&gt;两种方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;br&gt;如果我们添加动画的视图是全局变量，可使用该方法。&lt;/p&gt;
&lt;p&gt;添加动画时，我们使用了&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView.layer addAnimation:animaGroup forKey:@&amp;quot;Animation&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以，可根据key来区分不同的动画&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//动画开始时&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)animationDidStart:(CAAnimation *)anim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([anim isEqual:[self.imageView.layer animationForKey:@&amp;quot;Animation&amp;quot;]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;动画组执行了&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;把动画存储为一个属性然后再回调中比较，用来判定是哪个动画是不可行的。应为委托传入的动画参数是原始值的一个深拷贝，不是同一个值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式二：&lt;/strong&gt;&lt;br&gt;添加动画的视图是局部变量时，可使用该方法&lt;/p&gt;
&lt;p&gt;添加动画给动画设置key-value对&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[positionAnima setValue:@&amp;quot;PositionAnima&amp;quot; forKey:@&amp;quot;AnimationKey&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[transformAnima setValue:@&amp;quot;TransformAnima&amp;quot; forKey:@&amp;quot;AnimationKey&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所以，可以根据key中不同的值来进行区分不同的动画&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//动画结束时&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([[anim valueForKey:@&amp;quot;AnimationKey&amp;quot;]isEqualToString:@&amp;quot;PositionAnima&amp;quot;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;位置移动动画执行结束&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else if ([[anim valueForKey:@&amp;quot;AnimationKey&amp;quot;]isEqualToString:@&amp;quot;TransformAnima&amp;quot;])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;旋转动画执行结束&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/charsdavy/CAAnimationDemo.git&quot;&gt;Demo on Github&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用的animationWithKeyPath值&quot;&gt;&lt;a href=&quot;#常用的animationWithKeyPath值&quot; class=&quot;headerlink&quot; title=&quot;常用的animationWithKeyPath值&quot;&gt;&lt;/a&gt;常用的animationWithKeyPath值&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;使用形式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;transform.scale&lt;/td&gt;
&lt;td&gt;比例转化&lt;/td&gt;
&lt;td&gt;@(0.8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transform.scale.x&lt;/td&gt;
&lt;td&gt;宽的比例&lt;/td&gt;
&lt;td&gt;@(0.8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transform.scale.y&lt;/td&gt;
&lt;td&gt;高的比例&lt;/td&gt;
&lt;td&gt;@(0.8)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transform.rotation.x&lt;/td&gt;
&lt;td&gt;围绕x轴旋转&lt;/td&gt;
&lt;td&gt;@(M_PI)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transform.rotation.y&lt;/td&gt;
&lt;td&gt;围绕y轴旋转&lt;/td&gt;
&lt;td&gt;@(M_PI)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;transform.rotation.z&lt;/td&gt;
&lt;td&gt;围绕z轴旋转&lt;/td&gt;
&lt;td&gt;@(M_PI)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cornerRadius&lt;/td&gt;
&lt;td&gt;圆角的设置&lt;/td&gt;
&lt;td&gt;@(50)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;backgroundColor&lt;/td&gt;
&lt;td&gt;背景颜色的变化&lt;/td&gt;
&lt;td&gt;(id)[UIColor purpleColor].CGColor&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bounds&lt;/td&gt;
&lt;td&gt;大小，中心不变&lt;/td&gt;
&lt;td&gt;[NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)];&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;position&lt;/td&gt;
&lt;td&gt;位置(中心点的改变)&lt;/td&gt;
&lt;td&gt;[NSValue valueWithCGPoint:CGPointMake(300, 300)];&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contents&lt;/td&gt;
&lt;td&gt;内容，比如UIImageView的图片&lt;/td&gt;
&lt;td&gt;imageAnima.toValue = (id)[UIImage imageNamed:@”to”].CGImage;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;opacity&lt;/td&gt;
&lt;td&gt;透明度&lt;/td&gt;
&lt;td&gt;@(0.7)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;contentsRect.size.width&lt;/td&gt;
&lt;td&gt;横向拉伸缩放&lt;/td&gt;
&lt;td&gt;@(0.4)最好是0~1之间的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;附图&quot;&gt;&lt;a href=&quot;#附图&quot; class=&quot;headerlink&quot; title=&quot;附图&quot;&gt;&lt;/a&gt;附图&lt;/h1&gt;&lt;p&gt;CALayer Animatable Properties&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/CAAnimation-CABasicAnimation-8.png?imageView/2/w/800&quot; alt=&quot;CALayer Animatable Properties&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;推荐&quot;&gt;&lt;a href=&quot;#推荐&quot; class=&quot;headerlink&quot; title=&quot;推荐&quot;&gt;&lt;/a&gt;推荐&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://objccn.io/issue-12-2/&quot;&gt;Layer 中自定义属性的动画&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/mjios/archive/2013/04/15/3021343.html&quot;&gt;Core Animation2-CABasicAnimation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/cocoarannie/article/details/10413301&quot;&gt;CAAnimation——基本动画，关键帧动画和贝塞尔路径&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/iosevanhuang/article/details/14488239&quot;&gt;CABasicAnimation的基本使用方法（移动·旋转·放大·缩小）&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;要让一个 CALayer 动起來，除了通过改变 layer 的 animanatable 的属性外，就是建立 CAAnimation 实例，然后 layer 调用 -addAnimation:forKey:。我们通常会选择一种 CALayer 的 subclass，制作我们想要的动画效果。&lt;/p&gt;
&lt;p&gt;这里我们来好好看看 CAAnimation 相关知识，以期使用它来完成我们想要的动画效果。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="UI" scheme="http://charsdavy.github.io/tags/UI/"/>
    
      <category term="Animation" scheme="http://charsdavy.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Core Animation (一) 图层的树状结构</title>
    <link href="http://charsdavy.github.io/2016/07/28/core-aniamtion-layer-tree/"/>
    <id>http://charsdavy.github.io/2016/07/28/core-aniamtion-layer-tree/</id>
    <published>2016-07-28T12:21:10.000Z</published>
    <updated>2016-08-04T13:48:51.000Z</updated>
    
    <content type="html">&lt;p&gt;Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做&lt;em&gt;Layer Kit&lt;/em&gt;这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。&lt;/p&gt;
&lt;p&gt;Core Animation是一个&lt;em&gt;复合引擎&lt;/em&gt;，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的&lt;em&gt;图层&lt;/em&gt;，存储在一个叫做&lt;em&gt;图层树&lt;/em&gt;的体系之中。于是这个树形成了&lt;strong&gt;UIKit&lt;/strong&gt;以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;巨妖有图层，洋葱也有图层，你有吗？我们都有图层 – 史莱克&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在我们讨论动画之前，我们将从图层树开始，涉及一下Core Animation的&lt;em&gt;静态&lt;/em&gt;组合以及布局特性。&lt;/p&gt;
&lt;h2 id=&quot;图层和视图&quot;&gt;&lt;a href=&quot;#图层和视图&quot; class=&quot;headerlink&quot; title=&quot;图层和视图&quot;&gt;&lt;/a&gt;图层和视图&lt;/h2&gt;&lt;p&gt;如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对&lt;em&gt;视图&lt;/em&gt;的概念比较熟悉。一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。图1.1显示了一种典型的视图层级关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/layer-tree-1.1.jpeg?imageView/2/w/700&quot; alt=&quot;图1.1&quot;&gt;&lt;/p&gt;
&lt;p&gt;图1.1 一种典型的iOS屏幕（左边）和形成视图的层级关系（右边）&lt;/p&gt;
&lt;p&gt;在iOS当中，所有的视图都从一个叫做&lt;code&gt;UIVIew&lt;/code&gt;的基类派生而来，&lt;code&gt;UIView&lt;/code&gt;可以处理触摸事件，可以支持基于&lt;em&gt;Core Graphics&lt;/em&gt;绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。&lt;/p&gt;
&lt;h3 id=&quot;CALayer&quot;&gt;&lt;a href=&quot;#CALayer&quot; class=&quot;headerlink&quot; title=&quot;CALayer&quot;&gt;&lt;/a&gt;CALayer&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CALayer&lt;/code&gt;类在概念上和&lt;code&gt;UIView&lt;/code&gt;类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和&lt;code&gt;UIView&lt;/code&gt;最大的不同是&lt;code&gt;CALayer&lt;/code&gt;不处理用户的交互。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CALayer&lt;/code&gt;并不清楚具体的&lt;em&gt;响应链&lt;/em&gt;（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内（具体见第三章，“图层的几何学”）&lt;/p&gt;
&lt;h3 id=&quot;平行的层级关系&quot;&gt;&lt;a href=&quot;#平行的层级关系&quot; class=&quot;headerlink&quot; title=&quot;平行的层级关系&quot;&gt;&lt;/a&gt;平行的层级关系&lt;/h3&gt;&lt;p&gt;每一个&lt;code&gt;UIview&lt;/code&gt;都有一个&lt;code&gt;CALayer&lt;/code&gt;实例的图层属性，也就是所谓的&lt;em&gt;backing layer&lt;/em&gt;，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作（见图1.2）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/layer-tree-1.2.jpeg?imageView/2/w/700&quot; alt=&quot;图1.2&quot;&gt;&lt;/p&gt;
&lt;p&gt;图1.2 图层的树状结构（左边）以及对应的视图层级（右边）&lt;/p&gt;
&lt;p&gt;实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，&lt;code&gt;UIView&lt;/code&gt;仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。&lt;/p&gt;
&lt;p&gt;但是为什么iOS要基于&lt;code&gt;UIView&lt;/code&gt;和&lt;code&gt;CALayer&lt;/code&gt;提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和&lt;code&gt;UIView&lt;/code&gt;，但是Mac OS有AppKit和&lt;code&gt;NSView&lt;/code&gt;的原因。他们功能上很相似，但是在实现上有着显著的区别。&lt;/p&gt;
&lt;p&gt;绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。&lt;/p&gt;
&lt;p&gt;实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在&lt;em&gt;呈现树&lt;/em&gt;和&lt;em&gt;渲染树&lt;/em&gt;，将在第七章“隐式动画”和第十二章“性能调优”分别讨论。&lt;/p&gt;
&lt;h2 id=&quot;图层的能力&quot;&gt;&lt;a href=&quot;#图层的能力&quot; class=&quot;headerlink&quot; title=&quot;图层的能力&quot;&gt;&lt;/a&gt;图层的能力&lt;/h2&gt;&lt;p&gt;如果说&lt;code&gt;CALayer&lt;/code&gt;是&lt;code&gt;UIView&lt;/code&gt;内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的&lt;code&gt;UIView&lt;/code&gt;接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？&lt;/p&gt;
&lt;p&gt;某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理&lt;code&gt;CALayer&lt;/code&gt;，因为苹果已经通过&lt;code&gt;UIView&lt;/code&gt;的高级API间接地使得动画变得很简单。&lt;/p&gt;
&lt;p&gt;但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在&lt;code&gt;UIView&lt;/code&gt;上实现的接口功能，这时除了介入Core Animation底层之外别无选择。&lt;/p&gt;
&lt;p&gt;我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些&lt;code&gt;UIView&lt;/code&gt;没有暴露出来的CALayer的功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阴影，圆角，带颜色的边框&lt;/li&gt;
&lt;li&gt;3D变换&lt;/li&gt;
&lt;li&gt;非矩形范围&lt;/li&gt;
&lt;li&gt;透明遮罩&lt;/li&gt;
&lt;li&gt;多级非线性动画&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们将会在后续章节中探索这些功能，首先我们要关注一下在应用程序当中&lt;code&gt;CALayer&lt;/code&gt;是怎样被利用起来的。&lt;/p&gt;
&lt;h2 id=&quot;使用图层&quot;&gt;&lt;a href=&quot;#使用图层&quot; class=&quot;headerlink&quot; title=&quot;使用图层&quot;&gt;&lt;/a&gt;使用图层&lt;/h2&gt;&lt;p&gt;首先我们来创建一个简单的项目，来操纵一些&lt;code&gt;layer&lt;/code&gt;的属性。打开Xcode，使用&lt;em&gt;Single View Application&lt;/em&gt;模板创建一个工程。&lt;/p&gt;
&lt;p&gt;在屏幕中央创建一个小视图（大约200 X 200的尺寸），当然你可以手工编码，或者使用Interface Builder（随你方便）。确保你的视图控制器要添加一个视图的属性以便可以直接访问它。我们把它称作&lt;code&gt;layerView&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;运行项目，应该能在浅灰色屏幕背景中看见一个白色方块（图1.3），如果没看见，可能需要调整一下背景window或者view的颜色&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/layer-tree-1.3.jpeg?imageView/2/w/700&quot; alt=&quot;图1.3&quot;&gt;&lt;/p&gt;
&lt;p&gt;图1.3 灰色背景上的一个白色&lt;code&gt;UIView&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这并没有什么令人激动的地方，我们来添加一个色块，在白色方块中间添加一个小的蓝色块。&lt;/p&gt;
&lt;p&gt;我们当然可以简单地在已经存在的&lt;code&gt;UIView&lt;/code&gt;上添加一个子视图（随意用代码或者IB），但这不能真正学到任何关于图层的东西。&lt;/p&gt;
&lt;p&gt;于是我们来创建一个&lt;code&gt;CALayer&lt;/code&gt;，并且把它作为我们视图相关图层的子图层。尽管&lt;code&gt;UIView&lt;/code&gt;类的接口中暴露了图层属性，但是标准的Xcode项目模板并没有包含Core Animation相关头文件。所以如果我们不给项目添加合适的库，是不能够使用任何图层相关的方法或者访问它的属性。所以首先需要添加QuartzCore框架到Build Phases标签（图1.4），然后在vc的.m文件中引入&lt;QuartzCore/QuartzCore.h&gt;库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/layer-tree-1.4.jpeg?imageView/2/w/700&quot; alt=&quot;图1.4&quot;&gt;&lt;/p&gt;
&lt;p&gt;图1.4 把QuartzCore库添加到项目&lt;/p&gt;
&lt;p&gt;之后就可以在代码中直接引用&lt;code&gt;CALayer&lt;/code&gt;的属性和方法。在清单1.1中，我们用创建了一个&lt;code&gt;CALayer&lt;/code&gt;，设置了它的&lt;code&gt;backgroundColor&lt;/code&gt;属性，然后添加到&lt;code&gt;layerView&lt;/code&gt;背后相关图层的子图层（这段代码的前提是通过IB创建了&lt;code&gt;layerView&lt;/code&gt;并做好了连接），图1.5显示了结果。&lt;/p&gt;
&lt;p&gt;清单1.1 给视图添加一个蓝色子图层&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//objective-c    
#import &amp;quot;ViewController.h&amp;quot;
#import &amp;lt;QuartzCore/QuartzCore.h&amp;gt;
@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *layerView;
￼
@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    //create sublayer
    CALayer *blueLayer = [CALayer layer];
    blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);
    blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    //add it to our view
    [self.layerView.layer addSublayer:blueLayer];
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/layer-tree-1.5.jpeg?imageView/2/w/700&quot; alt=&quot;图1.5&quot;&gt;&lt;/p&gt;
&lt;p&gt;图1.5 白色&lt;code&gt;UIView&lt;/code&gt;内部嵌套的蓝色&lt;code&gt;CALayer&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层，从清单1.1可以看出，你可以显示创建一个单独的图层，并且把它直接添加到视图关联图层的子图层。尽管可以这样添加图层，但往往我们只是见简单地处理视图，他们关联的图层并不需要额外地手动添加子图层。&lt;/p&gt;
&lt;p&gt;在Mac OS平台，10.8版本之前，一个显著的性能缺陷就是由于用了视图层级而不是单独在一个视图内使用&lt;code&gt;CALayer&lt;/code&gt;树状层级。但是在iOS平台，使用轻量级的&lt;code&gt;UIView&lt;/code&gt;类并没有显著的性能影响（当然在Mac OS 10.8之后，&lt;code&gt;NSView&lt;/code&gt;的性能同样也得到很大程度的提高）。&lt;/p&gt;
&lt;p&gt;使用图层关联的视图而不是&lt;code&gt;CALayer&lt;/code&gt;的好处在于，你能在使用所有&lt;code&gt;CALayer&lt;/code&gt;底层特性的同时，也可以使用&lt;code&gt;UIView&lt;/code&gt;的高级API（比如自动排版，布局和事件处理）。&lt;/p&gt;
&lt;p&gt;然而，当满足以下条件的时候，你可能更需要使用&lt;code&gt;CALayer&lt;/code&gt;而不是&lt;code&gt;UIView&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发同时可以在Mac OS上运行的跨平台应用&lt;/li&gt;
&lt;li&gt;使用多种&lt;code&gt;CALayer&lt;/code&gt;的子类（见第六章，“特殊的图层“），并且不想创建额外的&lt;code&gt;UIView&lt;/code&gt;去包封装它们所有&lt;/li&gt;
&lt;li&gt;做一些对性能特别挑剔的工作，比如对&lt;code&gt;UIView&lt;/code&gt;一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是这些例子都很少见，总的来说，处理视图会比单独处理图层更加方便。&lt;/p&gt;
&lt;p&gt;##总结&lt;br&gt;这一章阐述了图层的树状结构，说明了如何在iOS中由&lt;code&gt;UIView&lt;/code&gt;的层级关系形成的一种平行的&lt;code&gt;CALayer&lt;/code&gt;层级关系，在后面的实验中，我们创建了自己的&lt;code&gt;CALayer&lt;/code&gt;，并把它添加到图层树中。&lt;/p&gt;
&lt;p&gt;在第二章，“图层关联的图片”，我们将要研究一下&lt;code&gt;CALayer&lt;/code&gt;关联的图片，以及Core Animation提供的操作显示的一些特性。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做&lt;em&gt;Layer Kit&lt;/em&gt;这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。&lt;/p&gt;
&lt;p&gt;Core Animation是一个&lt;em&gt;复合引擎&lt;/em&gt;，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的&lt;em&gt;图层&lt;/em&gt;，存储在一个叫做&lt;em&gt;图层树&lt;/em&gt;的体系之中。于是这个树形成了&lt;strong&gt;UIKit&lt;/strong&gt;以及在iOS应用程序当中你所能在屏幕上看见的一切的基础。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="Animation" scheme="http://charsdavy.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>谈谈iOS App打包发布</title>
    <link href="http://charsdavy.github.io/2016/07/21/ios-app-distribution/"/>
    <id>http://charsdavy.github.io/2016/07/21/ios-app-distribution/</id>
    <published>2016-07-21T11:56:38.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;来到 ZAKER 工作已经有一段时间了，博主也开始了自己的 iOS 开发之旅，因为博主是自学的，难免有些知识点的遗漏，很巧的是，关于App打包发布就是其中之一。而在最近，机缘巧合之下，需要自己打包上传到公司自己服务器用来做demo演示。在此，博主分享一下有关iOS App打包的过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;1.安装发布证书&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自己去Apple开发者中心配置&lt;/li&gt;
&lt;li&gt;找其他已经有证书的小伙伴导出p12文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.设置Scheme&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Xcode-&amp;gt;Product-&amp;gt;Scheme-&amp;gt;Edit Scheme&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-distribution-1.png?imageView/2/w/460&quot; alt=&quot;setting-scheme&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.设置软件版本号&lt;/p&gt;
&lt;p&gt;版本号格式：&lt;code&gt;数字.数字-字符(驼峰式).数字&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;code&gt;1.1-beta.1&lt;/code&gt; , &lt;code&gt;1.1.1-beta&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;版本号从0开始，不过一般版本号为0的数字省略。&lt;/p&gt;
&lt;p&gt;4.Archive&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;选择&lt;code&gt;真机&lt;/code&gt;或者&lt;code&gt;Generic iOS Device&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Product-&amp;gt;Archive&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5.Export&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-distribution-2.png?imageView/2/w/460&quot; alt=&quot;export-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-distribution-3.png?imageView/2/w/460&quot; alt=&quot;export-2&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-distribution-4.png?imageView/2/w/460&quot; alt=&quot;export-3&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-distribution-5.png?imageView/2/w/460&quot; alt=&quot;export-4&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-distribution-6.png?imageView/2/w/460&quot; alt=&quot;export-5&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/ios-app-distribution-7.png?imageView/2/w/460&quot; alt=&quot;export-6&quot;&gt;&lt;/p&gt;
&lt;p&gt;6.安装企业应用证书&lt;/p&gt;
&lt;p&gt;7.上传到ZAKER服务器&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;来到 ZAKER 工作已经有一段时间了，博主也开始了自己的 iOS 开发之旅，因为博主是自学的，难免有些知识点的遗漏，很巧的是，关于App打包发布就是其中之一。而在最近，机缘巧合之下，需要自己打包上传到公司自己服务器用来做demo演示。在此，博主分享一下有关iOS App打包的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="application" scheme="http://charsdavy.github.io/tags/application/"/>
    
  </entry>
  
  <entry>
    <title>搭建自己的开发环境</title>
    <link href="http://charsdavy.github.io/2016/07/17/custom-myself-develop-tool/"/>
    <id>http://charsdavy.github.io/2016/07/17/custom-myself-develop-tool/</id>
    <published>2016-07-17T02:23:26.000Z</published>
    <updated>2016-08-05T10:30:00.000Z</updated>
    
    <content type="html">&lt;p&gt;作为一个程序猿，每天接触最多的就是自己的“女朋友”，那么猿们肯定都有自己的一套撸具，我们都会根据自己的喜好配置自己的万能功能。无非是对于terminal的使用与配置。&lt;/p&gt;
&lt;p&gt;文章主要分享记录博主自己搭建环境的过程。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Sublime-Text&quot;&gt;&lt;a href=&quot;#Sublime-Text&quot; class=&quot;headerlink&quot; title=&quot;Sublime Text&quot;&gt;&lt;/a&gt;Sublime Text&lt;/h1&gt;&lt;p&gt;配置命令打开 Sublime Text&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ln -s &amp;quot;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&amp;quot; /usr/local/bin/subl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;JSON代码格式化&quot;&gt;&lt;a href=&quot;#JSON代码格式化&quot; class=&quot;headerlink&quot; title=&quot;JSON代码格式化&quot;&gt;&lt;/a&gt;JSON代码格式化&lt;/h2&gt;&lt;p&gt;网上有很多工具可用，博主自己现在使用一个 Tidy 的插件，效果还是蛮不错的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/custom-myself-develop-tool-subl-1.png&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;p&gt;1.打开链接&lt;a href=&quot;https://gist.github.com/charsdavy/cd2324f9483ff83425bbacf85a6ea9be&quot;&gt;https://gist.github.com/charsdavy/cd2324f9483ff83425bbacf85a6ea9be&lt;/a&gt;，下载文件。&lt;/p&gt;
&lt;p&gt;2.将解压后的文件夹中的 &lt;code&gt;prettify_json.py&lt;/code&gt; 和 &lt;code&gt;tidy_xml.py&lt;/code&gt; 问价拷贝到 &lt;code&gt;~/Library/Application Support/Sublime Text 2/Packages/User&lt;/code&gt; 路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/custom-myself-develop-tool-subl-2.png&quot; alt=&quot;路径文件夹&quot;&gt;&lt;/p&gt;
&lt;p&gt;3.打开 Sublime Text，从菜单中打开“Key-Bindings Default”文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/custom-myself-develop-tool-subl-3.png&quot; alt=&quot;打开Key-Bindings Default文件&quot;&gt;&lt;/p&gt;
&lt;p&gt;4.添加快捷键&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+x&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;tidy_xml&amp;quot; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &amp;quot;keys&amp;quot;: [&amp;quot;ctrl+shift+j&amp;quot;], &amp;quot;command&amp;quot;: &amp;quot;prettify_json&amp;quot; &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/custom-myself-develop-tool-subl-4.png&quot; alt=&quot;添加快捷键&quot;&gt;&lt;/p&gt;
&lt;p&gt;5.使用&lt;/p&gt;
&lt;p&gt;全选，然后按下 &lt;code&gt;Control + shift + j&lt;/code&gt; 键即可。&lt;/p&gt;
&lt;p&gt;持续不定期更新……&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个程序猿，每天接触最多的就是自己的“女朋友”，那么猿们肯定都有自己的一套撸具，我们都会根据自己的喜好配置自己的万能功能。无非是对于terminal的使用与配置。&lt;/p&gt;
&lt;p&gt;文章主要分享记录博主自己搭建环境的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>Mac 中 Git 命令自动补全</title>
    <link href="http://charsdavy.github.io/2016/07/17/git-auto-completion-mac/"/>
    <id>http://charsdavy.github.io/2016/07/17/git-auto-completion-mac/</id>
    <published>2016-07-17T01:51:42.000Z</published>
    <updated>2016-07-17T02:00:54.000Z</updated>
    
    <content type="html">&lt;p&gt;转战iOS开发已经有一段时间了，现在使用Mac，对于命令行的使用，真的是越来越喜欢，但是，在使用Git命令的时候，不能使用【Tab】来自动补全，为此，博主找寻方法，来完善Git命令补全功能。本文分享此功能实现。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;安装Homebrew&quot;&gt;&lt;a href=&quot;#安装Homebrew&quot; class=&quot;headerlink&quot; title=&quot;安装Homebrew&quot;&gt;&lt;/a&gt;安装Homebrew&lt;/h1&gt;&lt;p&gt;使用Homebrew安装的git，如何安装Honebrew及其使用在此就跳过，烦请自行查看(&lt;a href=&quot;http://brew.sh/index_zh-cn.html)。&quot;&gt;http://brew.sh/index_zh-cn.html)。&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;安装bash-completion&quot;&gt;&lt;a href=&quot;#安装bash-completion&quot; class=&quot;headerlink&quot; title=&quot;安装bash-completion&quot;&gt;&lt;/a&gt;安装bash-completion&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew list&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;查看是否已经安装了”bash-completion”，如果没有，继续往下看：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ brew install bash-completion&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#####安装完成之后######&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ brew info bash-completion 　&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#####下边这句话很重要#######&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;==&amp;gt; Caveats&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Add the following lines to your ~/.bash_profile:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if [ -f $(brew --prefix)/etc/bash_completion ]; then&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;. $(brew --prefix)/etc/bash_completion&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fi&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;将if…then…那一句添加到~/.bash_profile（如果没有该文件，新建一个）&lt;/p&gt;
&lt;h1 id=&quot;获取git-completion-bash&quot;&gt;&lt;a href=&quot;#获取git-completion-bash&quot; class=&quot;headerlink&quot; title=&quot;获取git-completion.bash&quot;&gt;&lt;/a&gt;获取git-completion.bash&lt;/h1&gt;&lt;p&gt;将git源码clone到本地&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone https://github.com/git/git.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;找到”contrib/completion/“目录下的git-completion.bash，将该文件拷贝到~/下并重命名为.git-completion.bash&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ cp git-completion.bash ~/.git-completion.bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;配置git-completion-bash&quot;&gt;&lt;a href=&quot;#配置git-completion-bash&quot; class=&quot;headerlink&quot; title=&quot;配置git-completion.bash&quot;&gt;&lt;/a&gt;配置git-completion.bash&lt;/h1&gt;&lt;p&gt;在~/.bash_profile文件（该目录下如果没有，新建一个）中添加下边的内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;source ~/.git-completion.bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;重启终端即可&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git --h[tab][tab]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;--help        --html-path&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;转战iOS开发已经有一段时间了，现在使用Mac，对于命令行的使用，真的是越来越喜欢，但是，在使用Git命令的时候，不能使用【Tab】来自动补全，为此，博主找寻方法，来完善Git命令补全功能。本文分享此功能实现。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="Git" scheme="http://charsdavy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>在Finder中打开终端</title>
    <link href="http://charsdavy.github.io/2016/07/13/finder-open-terminal/"/>
    <id>http://charsdavy.github.io/2016/07/13/finder-open-terminal/</id>
    <published>2016-07-13T07:14:35.000Z</published>
    <updated>2016-07-12T23:17:32.000Z</updated>
    
    <content type="html">&lt;p&gt;在Mac中，如果要在终端中进入在Finder中打开的目录，常用的方法是在终端中先敲入一个”cd “，然后在Finer中选中文件夹拖入到终端中，再回车即可实现。不过这样做终究还是麻烦了点，下面介绍如何直接在Finder中直接操作。&lt;/p&gt;
&lt;p&gt;在终端里打开Finder很简单，使用&lt;code&gt;open .&lt;/code&gt;即可&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;系统设置&quot;&gt;&lt;a href=&quot;#系统设置&quot; class=&quot;headerlink&quot; title=&quot;系统设置&quot;&gt;&lt;/a&gt;系统设置&lt;/h1&gt;&lt;p&gt;在Finder打开terminal这个功能其实是有的，但是系统默认没有打开，我们可以通过如下方法将其打开&lt;/p&gt;
&lt;p&gt;进入&lt;code&gt;系统偏好设置&lt;/code&gt;-&amp;gt;&lt;code&gt;键盘&lt;/code&gt;-&amp;gt;&lt;code&gt;快捷键&lt;/code&gt;-&amp;gt;&lt;code&gt;服务&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在右边&lt;code&gt;新建位于文件夹位置的终端窗口&lt;/code&gt;上打勾。&lt;/p&gt;
&lt;p&gt;如此设置后，在Finder中右击某文件，在出现的菜单中找到服务，然后点击&lt;code&gt;新建位于文件夹位置的终端窗口&lt;/code&gt;即可。&lt;/p&gt;
&lt;h1 id=&quot;Go2Shell&quot;&gt;&lt;a href=&quot;#Go2Shell&quot; class=&quot;headerlink&quot; title=&quot;Go2Shell&quot;&gt;&lt;/a&gt;Go2Shell&lt;/h1&gt;&lt;p&gt;在Mac App Store中下载 Go2Shell 软件，下载后在”应用程序“里找到Go2Shell软件，按住Cmd键，将其拖动到Finder的工具栏上。&lt;/p&gt;
&lt;p&gt;打开Go2Shell设置的方法是：在终端中输入命令 &lt;code&gt;open -a Go2Shell --args config&lt;/code&gt;，然后回车。&lt;/p&gt;
&lt;p&gt;优点：可以不需要选中文件夹，直接点Go2Shell按钮就可以打开终端。&lt;/p&gt;
&lt;p&gt;缺点：每次都是在新的终端窗口中打开，而不是在新的终端标签中打开。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在Mac中，如果要在终端中进入在Finder中打开的目录，常用的方法是在终端中先敲入一个”cd “，然后在Finer中选中文件夹拖入到终端中，再回车即可实现。不过这样做终究还是麻烦了点，下面介绍如何直接在Finder中直接操作。&lt;/p&gt;
&lt;p&gt;在终端里打开Finder很简单，使用&lt;code&gt;open .&lt;/code&gt;即可&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="Mac" scheme="http://charsdavy.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Git可视化比较工具P4Merge</title>
    <link href="http://charsdavy.github.io/2016/07/12/git-diff-p4merge/"/>
    <id>http://charsdavy.github.io/2016/07/12/git-diff-p4merge/</id>
    <published>2016-07-12T10:41:40.000Z</published>
    <updated>2016-07-12T23:17:32.000Z</updated>
    
    <content type="html">&lt;p&gt;在转战Mac之后，BeyondCompare 不再那么容易免费使用，今天终于让我找到了一个Git的GUI比较工具P4Merge，免费的，支持中文，还不错，推荐一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/git-diff-p4merge.png?imageView/2/w/460&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;下载&quot;&gt;&lt;a href=&quot;#下载&quot; class=&quot;headerlink&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h1&gt;&lt;p&gt;打开这个链接: &lt;a href=&quot;https://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools&quot;&gt;perforce-visual-merge-and-diff-tools&lt;/a&gt;，点左上角的 &lt;code&gt;FREE DOWNLOAD P4Merge&lt;/code&gt; , 找到 &lt;code&gt;Perforce Clients&lt;/code&gt; 中的 &lt;code&gt;P4Merge: Visual Merge Tool&lt;/code&gt; 项，在右边的第二行选择&lt;code&gt;Mac OS 10.6+ (64bit）&lt;/code&gt; ，点下面橙色的 &lt;code&gt;Accept and Download&lt;/code&gt;，选择跳过 &lt;code&gt;Skip Registration&lt;/code&gt; ，就会开始下载了。&lt;/p&gt;
&lt;p&gt;下载到&lt;code&gt;P4V.dmg&lt;/code&gt;文件后，双击打开，拖动&lt;code&gt;P4Merge&lt;/code&gt;到&lt;code&gt;Application&lt;/code&gt;文件夹上就可以完成安装了。&lt;/p&gt;
&lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git config --global diff.tool p4merge&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global difftool.p4merge.cmd /Applications/p4merge.app/Contents/MacOS/p4merge&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global difftool.p4merge.cmd &amp;quot;/Applications/p4merge.app/Contents/Resources/launchp4merge \$LOCAL \$REMOTE&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果直接复制原文的代码，运行上面的代码时会提示：&lt;br&gt;error: key does not contain a section: -global&lt;br&gt;跟别人的命令比较一下，就会发现应该是—global（要两个短横连在一起的），原文的短横线有问题&lt;/p&gt;
&lt;p&gt;现在敲&lt;code&gt;git difftool&lt;/code&gt;命令执行时，会提示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/usr/libexec/git-core/mergetools/p4merge: line 2: p4merge: command not found&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;原因是路径还需要再配置一下，如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git config --global difftool.p4merge.path &amp;quot;/Applications/p4merge.app/Contents/Resources/launchp4merge&amp;quot;&lt;/code&gt;&lt;br&gt;以后想要比较Git中的代码时，敲&lt;code&gt;git difftool filepath&lt;/code&gt; 即可&lt;/p&gt;
&lt;p&gt;Linux、Windows下也都可以使用这个工具进行比较代码，只是需要另行配置了。P4Merge除了有比较功能，还有合并功能，怎么配置可以借鉴下面给出的参考链接。另外还有一个可视化比较工具meld，据说也不错，有时间试试.&lt;/p&gt;
&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/ccf0703/article/details/7661789&quot;&gt;《Mac os x下git merge工具P4Merge的安装与配置》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nieyong.github.io/wiki_ny/git%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95.html&quot;&gt;《Git 用户信息》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/tony4d/3454372&quot;&gt;《Setup p4merge as a visual diff and merge tool for git》&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在转战Mac之后，BeyondCompare 不再那么容易免费使用，今天终于让我找到了一个Git的GUI比较工具P4Merge，免费的，支持中文，还不错，推荐一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/git-diff-p4merge.png?imageView/2/w/460&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>说说升级Xcode中SDK与真机调试版本</title>
    <link href="http://charsdavy.github.io/2016/06/30/xcode-update-sdk-devicesupport/"/>
    <id>http://charsdavy.github.io/2016/06/30/xcode-update-sdk-devicesupport/</id>
    <published>2016-06-30T07:03:02.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;相信作为一名iOS开发者，每当WWDC开始，iOS升级时，那种切肤之痛，是只有开发者才能体会而又无言的一种沉默抗议。&lt;/p&gt;
&lt;p&gt;Apple很残暴的将MAC OS、iOS、Xcode牢固的捆绑在一起。如果需要真机调试，那么Xcode的SDK版本一定不能低于真机，Xcode版本的安装有MAC OS的版本要求，这样一来，只要升级一下iOS版本，那么恭喜你，很有可能你需要升级MAC OS和Xcode。而对于动辄数十个G的文件，在天朝的绿色网络保护下，是一件多么伤神的事情啊。更甚的是，现在的MAC OS系统越来越不好用了，我很是怀恋之前的版本，课无奈胳膊拗不过大腿。&lt;/p&gt;
&lt;p&gt;现在，终于有了可行的办法，能够解决上述神伤，在此总结分享给大家。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;下载Xcode历史版本&quot;&gt;&lt;a href=&quot;#下载Xcode历史版本&quot; class=&quot;headerlink&quot; title=&quot;下载Xcode历史版本&quot;&gt;&lt;/a&gt;下载Xcode历史版本&lt;/h1&gt;&lt;p&gt;Apple提供了官方下载地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/download/more&quot;&gt;https://developer.apple.com/download/more&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开链接，登录账户，即可看见下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%ACxcode.png&quot; alt=&quot;下载历史版本Xcode&quot;&gt;&lt;/p&gt;
&lt;p&gt;根据左侧栏，筛选自己需要的软件，下载即可。&lt;/p&gt;
&lt;h1 id=&quot;升级Xcode真机调试版本&quot;&gt;&lt;a href=&quot;#升级Xcode真机调试版本&quot; class=&quot;headerlink&quot; title=&quot;升级Xcode真机调试版本&quot;&gt;&lt;/a&gt;升级Xcode真机调试版本&lt;/h1&gt;&lt;p&gt;1）在一台已经安装好的高版本中，获取需要的文件。&lt;/p&gt;
&lt;p&gt;2）替换自己的电脑上的Xcode对应的文件。&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;p&gt;1）找到应用程序，显示包中的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/%E6%98%BE%E7%A4%BA%E5%8C%85%E6%96%87%E4%BB%B6.png&quot; alt=&quot;显示包文件&quot;&gt;&lt;/p&gt;
&lt;p&gt;2）进入路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png&quot; alt=&quot;文件目录&quot;&gt;&lt;/p&gt;
&lt;p&gt;拷贝需要的文件，如 9.3文件夹。&lt;/p&gt;
&lt;p&gt;粘贴至自己电脑对应的位置即可。&lt;/p&gt;
&lt;h1 id=&quot;升级Xcode的SDK&quot;&gt;&lt;a href=&quot;#升级Xcode的SDK&quot; class=&quot;headerlink&quot; title=&quot;升级Xcode的SDK&quot;&gt;&lt;/a&gt;升级Xcode的SDK&lt;/h1&gt;&lt;p&gt;延续上述步骤，只需要进入文件路径&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;拷贝SDKs文件夹，粘贴至自己电脑相对应位置即可。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;相信作为一名iOS开发者，每当WWDC开始，iOS升级时，那种切肤之痛，是只有开发者才能体会而又无言的一种沉默抗议。&lt;/p&gt;
&lt;p&gt;Apple很残暴的将MAC OS、iOS、Xcode牢固的捆绑在一起。如果需要真机调试，那么Xcode的SDK版本一定不能低于真机，Xcode版本的安装有MAC OS的版本要求，这样一来，只要升级一下iOS版本，那么恭喜你，很有可能你需要升级MAC OS和Xcode。而对于动辄数十个G的文件，在天朝的绿色网络保护下，是一件多么伤神的事情啊。更甚的是，现在的MAC OS系统越来越不好用了，我很是怀恋之前的版本，课无奈胳膊拗不过大腿。&lt;/p&gt;
&lt;p&gt;现在，终于有了可行的办法，能够解决上述神伤，在此总结分享给大家。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="开发助手" scheme="http://charsdavy.github.io/tags/assistant/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 博客功能扩展 - 添加回滚到顶部按钮</title>
    <link href="http://charsdavy.github.io/2016/06/24/hexo-extern-scroll-top/"/>
    <id>http://charsdavy.github.io/2016/06/24/hexo-extern-scroll-top/</id>
    <published>2016-06-24T11:30:46.000Z</published>
    <updated>2016-07-12T23:17:32.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：承接前文&lt;a href=&quot;http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/&quot;&gt;《手把手教 GitHub + Hexo 搭建博客》&lt;/a&gt; ，对现有博客进行功能扩展。因为随着文章的发表，页面变得很长，长文章也较多，偶尔需要立即回到顶部，这个时候，就需要添加新的快捷方式。于是乎，诞生了这个功能扩展。文章主要分享实现滚动到顶部按钮功能。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt; 以Yilia主题为例，不同的主题可以类比找到对应的文件地址。 &lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;添加html代码&quot;&gt;&lt;a href=&quot;#添加html代码&quot; class=&quot;headerlink&quot; title=&quot;添加html代码&quot;&gt;&lt;/a&gt;添加html代码&lt;/h1&gt;&lt;p&gt;打开文件夹&lt;code&gt;/themes/Yilia/layout/_partial&lt;/code&gt;在此文件夹下，新建文件&lt;code&gt;totop.ejs&lt;/code&gt;，并向其中加入如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div id=&amp;quot;totop&amp;quot; style=&amp;quot;position:fixed;bottom:50px;right:30px;cursor: pointer;&amp;quot;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;a title=&amp;quot;返回顶部&amp;quot;&amp;gt;&amp;lt;img src=&amp;quot;/img/scrollup.png&amp;quot;/&amp;gt;&amp;lt;/a&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意： 文件的编码格式为&lt;code&gt;utf-8&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;添加js代码&quot;&gt;&lt;a href=&quot;#添加js代码&quot; class=&quot;headerlink&quot; title=&quot;添加js代码&quot;&gt;&lt;/a&gt;添加js代码&lt;/h1&gt;&lt;p&gt;打开文件夹&lt;code&gt;/themes/Yilia/source/js&lt;/code&gt;，新建文件&lt;code&gt;totop.js&lt;/code&gt;，将如下代码复制其中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(function($) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // When to show the scroll link&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // higher number = scroll link appears further down the page&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var upperLimit = 1000;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Our scroll link element&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var scrollElem = $(&amp;apos;#totop&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Scroll to top speed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var scrollSpeed = 1600;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Show and hide the scroll to top link based on scroll position&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scrollElem.hide();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(window).scroll(function () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var scrollTop = $(document).scrollTop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ( scrollTop &amp;gt; upperLimit ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $(scrollElem).stop().fadeTo(300, 1); // fade back in&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            $(scrollElem).stop().fadeTo(300, 0); // fade out&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Scroll to top animation on click&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $(scrollElem).click(function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        $(&amp;apos;html, body&amp;apos;).animate(&amp;#123;scrollTop:0&amp;#125;, scrollSpeed); return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)(jQuery);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以对&lt;code&gt;upperLimit&lt;/code&gt;和&lt;code&gt;scrollSpeed&lt;/code&gt;参数进行修改，控制显示位置和回滚速度。&lt;/p&gt;
&lt;h1 id=&quot;添加文件引用&quot;&gt;&lt;a href=&quot;#添加文件引用&quot; class=&quot;headerlink&quot; title=&quot;添加文件引用&quot;&gt;&lt;/a&gt;添加文件引用&lt;/h1&gt;&lt;p&gt;打开文件&lt;code&gt;/themes/Yilia/layout/_partial/after_footer.ejs&lt;/code&gt;，在文件的末尾添加以下两行代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;%- partial(&amp;apos;totop&amp;apos;) %&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&amp;quot;&amp;lt;%- config.root %&amp;gt;js/totop.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;资源&quot;&gt;&lt;a href=&quot;#资源&quot; class=&quot;headerlink&quot; title=&quot;资源&quot;&gt;&lt;/a&gt;资源&lt;/h1&gt;&lt;p&gt;将下面的图片复制到&lt;code&gt;/themes/Yilia/source/img&lt;/code&gt;目录下，文件名为&lt;code&gt;scrollup.png&lt;/code&gt;，页面足够长时，就可以看见按钮出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/scrollup.png&quot; alt=&quot;scrollup.png&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：承接前文&lt;a href=&quot;http://charsdavy.github.io/2016/05/31/build-blog-by-hexo/&quot;&gt;《手把手教 GitHub + Hexo 搭建博客》&lt;/a&gt; ，对现有博客进行功能扩展。因为随着文章的发表，页面变得很长，长文章也较多，偶尔需要立即回到顶部，这个时候，就需要添加新的快捷方式。于是乎，诞生了这个功能扩展。文章主要分享实现滚动到顶部按钮功能。&lt;/p&gt;
    
    </summary>
    
      <category term="应用实战" scheme="http://charsdavy.github.io/categories/apply/"/>
    
    
      <category term="hexo" scheme="http://charsdavy.github.io/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发 - 成熟的夜间模式解决方案</title>
    <link href="http://charsdavy.github.io/2016/06/20/ios-night-mode/"/>
    <id>http://charsdavy.github.io/2016/06/20/ios-night-mode/</id>
    <published>2016-06-20T05:03:03.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;方法调剂的版本&quot;&gt;&lt;a href=&quot;#方法调剂的版本&quot; class=&quot;headerlink&quot; title=&quot;方法调剂的版本&quot;&gt;&lt;/a&gt;方法调剂的版本&lt;/h1&gt;&lt;p&gt;如何在不改变原有的架构，甚至不改变原有的代码的基础上，为应用优雅地添加夜间模式成为很多开发者不得不面对的问题。这也是 1.0 时代的 DKNightVersion 想要实现的目标。&lt;/p&gt;
&lt;p&gt;其核心思路就是使用方法调剂修改 backgroundColor 的存取方法。&lt;/p&gt;
&lt;h1 id=&quot;使用-nightBackgroundColor&quot;&gt;&lt;a href=&quot;#使用-nightBackgroundColor&quot; class=&quot;headerlink&quot; title=&quot;使用 nightBackgroundColor&quot;&gt;&lt;/a&gt;使用 nightBackgroundColor&lt;/h1&gt;&lt;p&gt;在思考之后，我想到，想要在不改动原有代码的基础上实现夜间模式只能通过在分类中添加 nightBackgroundColor 属性，并且使用方法调剂改变 backgroundColor 的 setter 方法。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)hook_setBackgroundColor:(UIColor*)backgroundColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self setNormalBackgroundColor:backgroundColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self hook_setBackgroundColor:backgroundColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在当前主题为 DKThemeVersionNormal 时，将颜色保存至 normalBackgroundColor 中，然后再调用原 backgroundColor 的 setter 方法，更新视图的颜色。&lt;/p&gt;
&lt;h1 id=&quot;DKNightVersionManager&quot;&gt;&lt;a href=&quot;#DKNightVersionManager&quot; class=&quot;headerlink&quot; title=&quot;DKNightVersionManager&quot;&gt;&lt;/a&gt;DKNightVersionManager&lt;/h1&gt;&lt;p&gt;这里只解决了颜色设置的问题，下面会说明，如果在主题改变时，实时更新颜色，而不用重新进入当前页面。&lt;/p&gt;
&lt;p&gt;整个 DKNightVersion 都是由一个 DKNightVersionManager 的单例来管理的，而它的主要工作就是负责改变应用的主题、并在主题改变时通知其它视图更新颜色：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)changeColor:(id &amp;lt;DKNightVersionChangeColorProtocol&amp;gt;)object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([object respondsToSelector:@selector(changeColor)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [object changeColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([object respondsToSelector:@selector(subviews)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (![object subviews]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Basic case, do nothing.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for (id subview in [object subviews]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // recursive darken all the subviews of current view.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [self changeColor:subview];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if ([subview respondsToSelector:@selector(changeColor)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    [subview changeColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果主题更新，那么就会递归地调用 changeColor 方法，刷新全部的视图颜色，而这个方法的实现比较简单：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)changeColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([DKNightVersionManager currentThemeVersion] == DKThemeVersionNormal) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.backgroundColor = self.normalBackgroundColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.backgroundColor = self.nightBackgroundColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面就是整个框架在 1.0 版本时的实现思路。不过这个版本的 DKNightVersion 在实际应用中会有比较多的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在高速滚动的 scrollView 上面来回切换夜间模式，会出现颜色错乱的问题&lt;/li&gt;
&lt;li&gt;由于对 backgroundColor 属性进行不合适的方法调剂，其行为无法预测，比如：在设置颜色后，再取出，不一定与设置时传入的颜色相同&lt;/li&gt;
&lt;li&gt;无法适配第三方 UI 控件&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;使用色表的版本&quot;&gt;&lt;a href=&quot;#使用色表的版本&quot; class=&quot;headerlink&quot; title=&quot;使用色表的版本&quot;&gt;&lt;/a&gt;使用色表的版本&lt;/h1&gt;&lt;p&gt;为了解决 1.0 中的各种问题，我决定在 2.0 版本中放弃对 nightBackgroundColor 的使用，并且重新设计底层的实现，转而使用更为稳定、安全的方法实现夜间模式，先看一下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
&lt;p&gt;新的实现支持夜间模式，且支持多主题&lt;/p&gt;
&lt;h1 id=&quot;DKColorPicker&quot;&gt;&lt;a href=&quot;#DKColorPicker&quot; class=&quot;headerlink&quot; title=&quot;DKColorPicker&quot;&gt;&lt;/a&gt;DKColorPicker&lt;/h1&gt;&lt;p&gt;与上一个版本实现上的不同，在 2.0 中删除了全部的 nightBackgroundColor，使用一个名为 dk_backgroundColorPicker 的属性取代它。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, copy) DKColorPicker dk_backgroundColorPicker;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个属性其实就是一个 block，它接收参数 DKThemeVersion &lt;em&gt;themeVersion，但是会返回一个 UIColor &lt;/em&gt;：&lt;/p&gt;
&lt;p&gt;在第一次传入 picker 或者每次主题改变时，都会将当前主题 DKThemeVersion 传入 picker 并执行，然后，将得到的 UIColor 赋值给对应的属性 backgroundColor 更新视图颜色。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef UIColor *(^DKColorPicker)(DKThemeVersion *themeVersion);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如下面使用 DKColorPickerWithRGB 创建一个临时的 DKColorPicker：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 DKThemeVersionNormal 时返回 0xffffff&lt;/li&gt;
&lt;li&gt;在 DKThemeVersionNight 时返回 0x343434&lt;/li&gt;
&lt;li&gt;在自定义的主题下返回 0xfafafa （这里的顺序与色表中主题的顺序有关）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cell.dk_backgroundColorPicker = DKColorPickerWithRGB(0xffffff, 0x343434, 0xfafafa);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;同时，每一个对象还持有一个 pickers 数组，来存储自己的全部 DKColorPicker：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface NSObject ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) NSMutableDictionary&amp;lt;NSString *, DKColorPicker&amp;gt; *pickers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在第一次使用这个属性时，当前对象注册为 DKNightVersionThemeChangingNotificaiton 通知的观察者。&lt;/p&gt;
&lt;p&gt;在每次收到通知时，都会调用 night_update 方法，将当前主题传入 DKColorPicker，并再次执行，并将结果传入对应的属性 [self performSelector:sel withObject:result]。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)night_updateColor &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.pickers enumerateKeysAndObjectsUsingBlock:^(NSString * _Nonnull selector, DKColorPicker  _Nonnull picker, BOOL * _Nonnull stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SEL sel = NSSelectorFromString(selector);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        id result = picker(self.dk_manager.themeVersion);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [UIView animateWithDuration:DKNightVersionAnimationDuration  animations:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       [self performSelector:sel withObject:result];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;也就是说，在每次改变主题的时候，都会发出通知。&lt;/p&gt;
&lt;h1 id=&quot;DKColorTable&quot;&gt;&lt;a href=&quot;#DKColorTable&quot; class=&quot;headerlink&quot; title=&quot;DKColorTable&quot;&gt;&lt;/a&gt;DKColorTable&lt;/h1&gt;&lt;p&gt;虽然我们在上面临时创建了一些 DKColorPicker。不过在 DKNightVersion 中，我更推荐使用色表，来减少相同的 DKColorPicker 的创建，并且能够更好地管理整个应用中的颜色：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NORMAL   NIGHT    RED  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ffffff          #343434  #fafafa      BG&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#aaaaaa    #313131   #aaaaaa  SEP&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#0000ff      #ffffff          #fa0000   TINT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#000000    #ffffff          #000000  TEXT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ffffff          #444444    #ffffff BAR&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面就是默认色表文件 DKColorTable.txt 中的内容，其中，第一行表示主题，NORMAL 主题必须存在，而且必须为第一列，而最右面的 BG、SEP 就是对应 DKColorPicker 的 key。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;self.tableView.dk_backgroundColorPicker =  DKColorPickerWithKey(BG);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在使用时，上面的代码就相当于返回了一个在 NORMAL 时返回 #ffffff、NIGHT 时返回 #343434 以及 RED 时返回 #fafafa 的 DKColorPicker。&lt;/p&gt;
&lt;h1 id=&quot;pickerify&quot;&gt;&lt;a href=&quot;#pickerify&quot; class=&quot;headerlink&quot; title=&quot;pickerify&quot;&gt;&lt;/a&gt;pickerify&lt;/h1&gt;&lt;p&gt;虽然说，我们使用色表以及 DKColorPicker 解决了，但是，到目前为止我们还没有解决第三方框架的问题。&lt;/p&gt;
&lt;p&gt;比如我们使用了某个第三方框架，或者自己添加了某个 color 属性，比如说：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface DKView ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) UIColor *weirdColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;weirdColor 并没有对应的 DKColorPicker，但是，我们可以通过 pickerify 在想要使用 dk_weirdColorPicker 的地方生成这个对应的 picker：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@pickerify(DKView, weirdColor);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，我们就可以使用 dk_weirdColorPicker 属性了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;view.dk_weirdColorPicker = DKColorPickerWithKey(BG);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;pickerify 其实是一个宏：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define pickerify(KLASS, PROPERTY) interface \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KLASS (Night) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @property (nonatomic, copy, setter = dk_set ## PROPERTY ## Picker:) DKColorPicker dk_ ## PROPERTY ## Picker; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @end \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @interface \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KLASS () \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @property (nonatomic, strong) NSMutableDictionary&amp;lt;NSString *, DKColorPicker&amp;gt; *pickers; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @end \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @implementation \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KLASS (Night) \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - (DKColorPicker)dk_ ## PROPERTY ## Picker &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return objc_getAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker)); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    - (void)dk_set ## PROPERTY ## Picker:(DKColorPicker)picker &amp;#123; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        objc_setAssociatedObject(self, @selector(dk_ ## PROPERTY ## Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC); \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self setValue:picker(self.dk_manager.themeVersion) forKeyPath:@keypath(self, PROPERTY)];\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.pickers setValue:[picker copy] forKey:_DKSetterWithPROPERTYerty(@#PROPERTY)]; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个宏根据传入的类和属性名，为我们生成了对应 picker 的存取方法，它也可以说是一种元编程的手段。&lt;/p&gt;
&lt;p&gt;这里生成的 setter 方法不是标准意义上的驼峰命名法 dk_setweirdColorPicker:，因为我不知道怎么才能让大写首字母之后的属性添加到这里（如果各位读者有解决方案，欢迎提 PR 或者 issue）。&lt;/p&gt;
&lt;h1 id=&quot;嵌入式-Ruby&quot;&gt;&lt;a href=&quot;#嵌入式-Ruby&quot; class=&quot;headerlink&quot; title=&quot;嵌入式 Ruby&quot;&gt;&lt;/a&gt;嵌入式 Ruby&lt;/h1&gt;&lt;p&gt;由于框架中很多的代码，都是重复的，所以在这里使用了嵌入式 Ruby 模板来生成对应的文件 color.m.irb：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  &amp;lt;%= klass.name %&amp;gt;+Night.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  &amp;lt;%= klass.name %&amp;gt;+Night&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2015 Draveness. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  These files are generated by ruby script, if you want to modify code&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  in this file, you are supposed to update the ruby code, run it and&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  test it. And finally open a pull request.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;&amp;lt;%= klass.name %&amp;gt;+Night.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;DKNightVersionManager.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;objc/runtime.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface &amp;lt;%= klass.name %&amp;gt; ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) NSMutableDictionary&amp;lt;NSString *, DKColorPicker&amp;gt; *pickers;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation &amp;lt;%= klass.name %&amp;gt; (Night)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;% klass.properties.each do |property| %&amp;gt;&amp;lt;%= &amp;quot;&amp;quot;&amp;quot;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (DKColorPicker)dk_#&amp;#123;property.name&amp;#125;Picker &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return objc_getAssociatedObject(self, @selector(dk_#&amp;#123;property.name&amp;#125;Picker));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)dk_set#&amp;#123;property.cap_name&amp;#125;Picker:(DKColorPicker)picker &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_setAssociatedObject(self, @selector(dk_#&amp;#123;property.name&amp;#125;Picker), picker, OBJC_ASSOCIATION_COPY_NONATOMIC);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.#&amp;#123;property.name&amp;#125; = picker(self.dk_manager.themeVersion);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.pickers setValue:[picker copy] forKey:@\&amp;quot;#&amp;#123;property.setter&amp;#125;\&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;&amp;quot;&amp;quot; %&amp;gt;&amp;lt;% end %&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这部分的实现并不在这篇文章的讨论范围之内，如果，对这部分看兴趣，可以看一下仓库中的 generator 文件夹，其中包含了代码生成器的全部代码。&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;如果你对 DKNightVersion 的使用有兴趣，可以查看仓库的 README 文件，有人会说不要在项目中 ObjC runtime，我个人觉得是没有问题，AFNetworking、 BlocksKit 也使用方法调剂来改变原有方法的实现，不能因为它强大就不使用它；正相反，有时候，使用 runtime 才能优雅地解决问题。&lt;/p&gt;
&lt;p&gt;GitHub地址:&lt;a href=&quot;https://github.com/draveness/iOS-Source-Code-Analyze&quot;&gt;https://github.com/draveness/iOS-Source-Code-Analyze&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://draveness.me/night&quot;&gt;http://draveness.me/night&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：iOS夜间模式是我们在APP开发中经常会要提供的一个功能。然后，是否可以使用一些已经成熟的第三方框架呢，文章分享一个适用于夜间模式的框架 - DKNightVersion 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/DKNightVersion.gif?imageView/2/w/360&quot; alt=&quot;效果图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="UI" scheme="http://charsdavy.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>iOS 源代码分析 - SDWebImage</title>
    <link href="http://charsdavy.github.io/2016/06/17/ios-sdwebimage-code-reading/"/>
    <id>http://charsdavy.github.io/2016/06/17/ios-sdwebimage-code-reading/</id>
    <published>2016-06-17T11:50:38.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项目的源代码. 本文主要分享SDWebImage框架源代码的相关信息. &lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;简洁的接口&quot;&gt;&lt;a href=&quot;#简洁的接口&quot; class=&quot;headerlink&quot; title=&quot;简洁的接口&quot;&gt;&lt;/a&gt;简洁的接口&lt;/h1&gt;&lt;p&gt;首先来介绍一下这个 SDWebImage 这个著名开源框架, 这个开源框架的主要作用就是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Asynchronous image downloader with cache support with an UIImageView category.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个异步下载图片并且支持缓存的 UIImageView 分类.&lt;/p&gt;
&lt;p&gt;就这么直译过来相信各位也能理解, 框架中最最常用的方法其实就是这个:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView sd_setImageWithURL:[NSURL URLWithString:@&amp;quot;url&amp;quot;]  placeholderImage:[UIImage imageNamed:@&amp;quot;placeholder.png&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然这个框架中还有 UIButton 的分类, 可以给 UIButton 异步加载图片, 不过这个并没有 UIImageView 分类中的这个方法常用.&lt;/p&gt;
&lt;p&gt;这个框架的设计还是极其的优雅和简洁, 主要的功能就是这么一行代码, 而其中复杂的实现细节全部隐藏在这行代码之后, 正应了那句话:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把简洁留给别人, 把复杂留给自己.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们已经看到了这个框架简洁的接口, 接下来我们看一下 SDWebImage 是用什么样的方式优雅地实现异步加载图片和缓存的功能呢?&lt;/p&gt;
&lt;h1 id=&quot;复杂的实现&quot;&gt;&lt;a href=&quot;#复杂的实现&quot; class=&quot;headerlink&quot; title=&quot;复杂的实现&quot;&gt;&lt;/a&gt;复杂的实现&lt;/h1&gt;&lt;p&gt;其实复杂只是相对于简洁而言的, 并不是说 SDWebImage 的实现就很糟糕, 相反, 它的实现还是非常 amazing 的.&lt;/p&gt;
&lt;p&gt;UIImageView+WebCache 和 UIButton+WebCache 直接为表层的 UIKit 框架提供接口, 而 SDWebImageManger 负责处理和协调 SDWebImageDownloader 和 SDWebImageCache. 并与 UIKit 层进行交互, 而底层的一些类为更高层级的抽象提供支持.&lt;/p&gt;
&lt;p&gt;在这里我们会忽略很多的实现细节, 并不会对每一行源代码逐一解读.&lt;/p&gt;
&lt;h1 id=&quot;UIImageView-WebCache&quot;&gt;&lt;a href=&quot;#UIImageView-WebCache&quot; class=&quot;headerlink&quot; title=&quot;UIImageView+WebCache&quot;&gt;&lt;/a&gt;UIImageView+WebCache&lt;/h1&gt;&lt;p&gt;接下来我们就以 UIImageView+WebCache 中的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sd_setImageWithURL:(NSURL *)url  placeholderImage:(UIImage *)placeholder;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这一方法为入口研究一下 SDWebImage 是怎样工作的. 我们打开上面这段方法的实现代码 UIImageView+WebCache.m&lt;/p&gt;
&lt;p&gt;当然你也可以&lt;code&gt;git clone git@github.com:rs/SDWebImage.git&lt;/code&gt;到本地来查看.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sd_setImageWithURL:(NSURL *)url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          placeholderImage:(UIImage *)placeholder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self sd_setImageWithURL:url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            placeholderImage:placeholder &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             options:0 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             progress:nil &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             completed:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这段方法唯一的作用就是调用了另一个方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self sd_setImageWithURL:placeholderImage:options:progress:completed:]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个文件中, 你会看到很多的&lt;code&gt;sd_setImageWithURL......&lt;/code&gt;方法, 它们最终都会调用上面这个方法, 只是根据需要传入不同的参数, 这在很多的开源项目中乃至我们平时写的项目中都是很常见的. 而这个方法也是 UIImageView+WebCache 中的核心方法.&lt;/p&gt;
&lt;p&gt;这里就不再复制出这个方法的全部实现了.&lt;/p&gt;
&lt;h1 id=&quot;操作的管理&quot;&gt;&lt;a href=&quot;#操作的管理&quot; class=&quot;headerlink&quot; title=&quot;操作的管理&quot;&gt;&lt;/a&gt;操作的管理&lt;/h1&gt;&lt;p&gt;这是这个方法的第一行代码:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self sd_cancelCurrentImageLoad];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这行看似简单的代码最开始是被我忽略的, 我后来才发现蕴藏在这行代码之后的思想, 也就是 SDWebImage 管理操作的办法.&lt;/p&gt;
&lt;p&gt;框架中的所有操作实际上都是通过一个 operationDictionary 来管理, 而这个字典实际上是动态的添加到 UIView 上的一个属性, 至于为什么添加到 UIView 上, 主要是因为这个 operationDictionary 需要在 UIButton 和 UIImageView 上重用, 所以需要添加到它们的根类上.&lt;/p&gt;
&lt;p&gt;这行代码是要保证没有当前正在进行的异步下载操作, 不会与即将进行的操作发生冲突, 它会调用:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_cancelCurrentImageLoad #1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self sd_cancelImageLoadOperationWithKey:@&amp;quot;UIImageViewImageLoad&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而这个方法会使当前 UIImageView 中的所有操作都被 cancel. 不会影响之后进行的下载操作.&lt;/p&gt;
&lt;h1 id=&quot;占位图的实现&quot;&gt;&lt;a href=&quot;#占位图的实现&quot; class=&quot;headerlink&quot; title=&quot;占位图的实现&quot;&gt;&lt;/a&gt;占位图的实现&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!(options &amp;amp; SDWebImageDelayPlaceholder)) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.image = placeholder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果传入的 options 中没有 SDWebImageDelayPlaceholder(默认情况下 options == 0), 那么就会为 UIImageView 添加一个临时的 image, 也就是占位图.&lt;/p&gt;
&lt;h1 id=&quot;获取图片&quot;&gt;&lt;a href=&quot;#获取图片&quot; class=&quot;headerlink&quot; title=&quot;获取图片&quot;&gt;&lt;/a&gt;获取图片&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (url)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接下来会检测传入的 url 是否非空, 如果非空那么一个全局的 SDWebImageManager 就会调用以下的方法获取图片:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下载完成后会调用 (SDWebImageCompletionWithFinishedBlock)completedBlock 为 UIImageView.image 赋值, 添加上最终所需要的图片.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_main_sync_safe(^&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!wself) return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (image) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wself.image = image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [wself setNeedsLayout];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ((options &amp;amp; SDWebImageDelayPlaceholder)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            wself.image = placeholder;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [wself setNeedsLayout];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (completedBlock &amp;amp;&amp;amp; finished) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        completedBlock(image, error, cacheType, url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;dispatch-main-sync-safe-宏定义&quot;&gt;&lt;a href=&quot;#dispatch-main-sync-safe-宏定义&quot; class=&quot;headerlink&quot; title=&quot;dispatch_main_sync_safe 宏定义&quot;&gt;&lt;/a&gt;dispatch_main_sync_safe 宏定义&lt;/h1&gt;&lt;p&gt;上述代码中的 dispatch_main_sync_safe 是一个宏定义, 点进去一看发现宏是这样定义的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#define dispatch_main_sync_safe(block)\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([NSThread isMainThread]) &amp;#123;\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        block();\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; else &amp;#123;\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_sync(dispatch_get_main_queue(), block);\&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;相信这个宏的名字已经讲他的作用解释的很清楚了: 因为图像的绘制只能在主线程完成, 所以, dispatch_main_sync_safe 就是为了保证 block 能在主线程中执行.&lt;/p&gt;
&lt;p&gt;而最后, 在&lt;code&gt;[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]&lt;/code&gt;返回 operation 的同时, 也会向 operationDictionary 中添加一个键值对, 来表示操作的正在进行:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// UIImageView+WebCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// sd_setImageWithURL:placeholderImage:options:progress:completed: #28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self sd_setImageLoadOperation:operation forKey:@&amp;quot;UIImageViewImageLoad&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它将 opertion 存储到 operationDictionary 中方便以后的 cancel.&lt;/p&gt;
&lt;p&gt;到此为止我们已经对 SDWebImage 框架中的这一方法分析完了, 接下来我们将要分析 SDWebImageManager 中的方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[SDWebImageManager.sharedManager downloadImageWithURL:options:progress:completed:]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;SDWebImageManager&quot;&gt;&lt;a href=&quot;#SDWebImageManager&quot; class=&quot;headerlink&quot; title=&quot;SDWebImageManager&quot;&gt;&lt;/a&gt;SDWebImageManager&lt;/h1&gt;&lt;p&gt;在 SDWebImageManager.h 中你可以看到关于 SDWebImageManager 的描述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The SDWebImageManager is the class behind the UIImageView+WebCache category and likes. It ties the asynchronous downloader (SDWebImageDownloader) with the image cache store (SDImageCache). You can use this class directly to benefit from web image downloading with caching in another context than a UIView.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个类就是隐藏在 UIImageView+WebCache 背后, 用于处理异步下载和图片缓存的类, 当然你也可以直接使用 SDWebImageManager 的上述方法 &lt;code&gt;downloadImageWithURL:options:progress:completed:&lt;/code&gt;来直接下载图片.&lt;/p&gt;
&lt;p&gt;可以看到, 这个类的主要作用就是为 UIImageView+WebCache 和 SDWebImageDownloader, SDImageCache 之间构建一个桥梁, 使它们能够更好的协同工作, 我们在这里分析这个核心方法的源代码, 它是如何协调异步下载和图片缓存的.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// downloadImageWithURL:options:progress:completed: #6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ([url isKindOfClass:NSString.class]) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url = [NSURL URLWithString:(NSString *)url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (![url isKindOfClass:NSURL.class]) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    url = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这块代码的功能是确定 url 是否被正确传入, 如果传入参数的是 NSString 类型就会被转换为 NSURL. 如果转换失败, 那么 url 会被赋值为空, 这个下载的操作就会出错.&lt;/p&gt;
&lt;h1 id=&quot;SDWebImageCombinedOperation&quot;&gt;&lt;a href=&quot;#SDWebImageCombinedOperation&quot; class=&quot;headerlink&quot; title=&quot;SDWebImageCombinedOperation&quot;&gt;&lt;/a&gt;SDWebImageCombinedOperation&lt;/h1&gt;&lt;p&gt;当 url 被正确传入之后, 会实例一个非常奇怪的 “operation”, 它其实是一个遵循 SDWebImageOperation 协议的 NSObject 的子类. 而这个协议也非常的简单:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@protocol SDWebImageOperation &amp;lt;NSObject&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)cancel;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里仅仅是将这个 SDWebImageOperation 类包装成一个看着像 NSOperation 其实并不是 NSOperation 的类, 而这个类唯一与 NSOperation 的相同之处就是它们都可以响应 cancel 方法. &lt;/p&gt;
&lt;p&gt;而调用这个类的存在实际是为了使代码更加的简洁, 因为调用这个类的 cancel 方法, 会使得它持有的两个 operation 都被 cancel.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageCombinedOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// cancel #1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)cancel &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.cancelled = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.cacheOperation) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.cacheOperation cancel];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.cacheOperation = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.cancelBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.cancelBlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _cancelBlock = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而这个类, 应该是为了实现更简洁的 cancel 操作而设计出来的. 既然我们获取了 url, 再通过 url 获取对应的 key&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *key = [self cacheKeyForURL:url];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下一步是使用 key 在缓存中查找以前是否下载过相同的图片.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;operation.cacheOperation = [self.imageCache  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queryDiskCacheForKey:key &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;done:^(UIImage *image, SDImageCacheType cacheType) &amp;#123; ... &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里调用 SDImageCache 的实例方法 queryDiskCacheForKey:done: 来尝试在缓存中获取图片的数据. 而这个方法返回的就是货真价实的 NSOperation.&lt;/p&gt;
&lt;p&gt;如果我们在缓存中查找到了对应的图片, 那么我们直接调用 completedBlock 回调块结束这一次的图片下载操作.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageManager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// downloadImageWithURL:options:progress:completed: #47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_main_sync_safe(^&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    completedBlock(image, nil, cacheType, YES, url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果我们没有找到图片, 那么就会调用 SDWebImageDownloader 的实例方法:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id &amp;lt;SDWebImageOperation&amp;gt; subOperation =  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; [self.imageDownloader &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    downloadImageWithURL:url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    options:downloaderOptions &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    progress:progressBlock &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    completed:^(UIImage *downloadedImage, NSData *data, NSError *error, BOOL finished) &amp;#123; ... &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果这个方法返回了正确的 downloadedImage, 那么我们就会在全局的缓存中存储这个图片的数据:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageCache &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    storeImage:downloadedImage &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    recalculateFromImage:NO &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageData:data &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    forKey:key &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toDisk:cacheOnDisk];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;并调用 completedBlock 对 UIImageView 或者 UIButton 添加图片, 或者进行其它的操作.&lt;br&gt;最后, 我们将这个 subOperation 的 cancel 操作添加到 operation.cancelBlock 中. 方便操作的取消.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;operation.cancelBlock = ^&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [subOperation cancel];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;SDWebImageCache&quot;&gt;&lt;a href=&quot;#SDWebImageCache&quot; class=&quot;headerlink&quot; title=&quot;SDWebImageCache&quot;&gt;&lt;/a&gt;SDWebImageCache&lt;/h1&gt;&lt;p&gt;SDWebImageCache.h 这个类在源代码中有这样的注释:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;SDImageCache maintains a memory cache and an optional disk cache.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它维护了一个内存缓存和一个可选的磁盘缓存, 我们先来看一下在上一阶段中没有解读的两个方法, 首先是:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSOperation *)queryDiskCacheForKey:(NSString *)key &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    done:(SDWebImageQueryCompletedBlock)doneBlock;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个方法的主要功能是异步的查询图片缓存. 因为图片的缓存可能在两个地方, 而该方法首先会在内存中查找是否有图片的缓存.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// queryDiskCacheForKey:done: #9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIImage *image = [self imageFromMemoryCacheForKey:key];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 imageFromMemoryCacheForKey 方法会在 SDWebImageCache 维护的缓存 memCache 中查找是否有对应的数据, 而 memCache 就是一个 NSCache.&lt;/p&gt;
&lt;p&gt;如果在内存中并没有找到图片的缓存的话, 就需要在磁盘中寻找了, 这个就比较麻烦了..&lt;/p&gt;
&lt;p&gt;在这里会调用一个方法 diskImageForKey 这个方法的具体实现我在这里就不介绍了, 涉及到很多底层 Core Foundation 框架的知识, 不过这里文件名字的存储使用 MD5 处理过后的文件名.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDImageCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// cachedFileNameForKey: #6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CC_MD5(str, (CC_LONG)strlen(str), r);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于其它的实现细节也就不多说了…&lt;br&gt;如果在磁盘中查找到对应的图片, 我们会将它复制到内存中, 以便下次的使用.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDImageCache&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// queryDiskCacheForKey:done: #24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIImage *diskImage = [self diskImageForKey:key];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (diskImage) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGFloat cost = diskImage.size.height * diskImage.size.width * diskImage.scale;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.memCache setObject:diskImage forKey:key cost:cost];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些就是 SDImageCache 的核心内容了, 而接下来将介绍如果缓存没有命中, 图片是如何被下载的.&lt;/p&gt;
&lt;h1 id=&quot;SDWebImageDownloader&quot;&gt;&lt;a href=&quot;#SDWebImageDownloader&quot; class=&quot;headerlink&quot; title=&quot;SDWebImageDownloader&quot;&gt;&lt;/a&gt;SDWebImageDownloader&lt;/h1&gt;&lt;p&gt;按照之前的惯例, 我们先来看一下 SDWebImageDownloader.h 中对这个类的描述.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Asynchronous downloader dedicated and optimized for image loading.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;专用的并且优化的图片异步下载器.&lt;/p&gt;
&lt;p&gt;这个类的核心功能就是下载图片, 而核心方法就是上面提到的:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id &amp;lt;SDWebImageOperation&amp;gt;)downloadImageWithURL:(NSURL *)url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    options:(SDWebImageDownloaderOptions)options &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    progress:(SDWebImageDownloaderProgressBlock)progressBlock &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    completed:(SDWebImageDownloaderCompletedBlock)completedBlock;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;回调&lt;br&gt;这个方法直接调用了另一个关键的方法:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    andCompletedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    forURL:(NSURL *)url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    createCallback:(SDWebImageNoParamsBlock)createCallback&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它为这个下载的操作添加回调的块, 在下载进行时, 或者在下载结束时执行一些操作, 先来阅读一下这个方法的源代码:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// addProgressCallback:andCompletedBlock:forURL:createCallback: #10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL first = NO;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!self.URLCallbacks[url]) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.URLCallbacks[url] = [NSMutableArray new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    first = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Handle single download of simultaneous download request for the same URL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *callbacksForURL = self.URLCallbacks[url];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableDictionary *callbacks = [NSMutableDictionary new];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[callbacksForURL addObject:callbacks];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.URLCallbacks[url] = callbacksForURL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (first) &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    createCallback();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法会先查看这个 url 是否有对应的 callback, 使用的是 downloader 持有的一个字典 URLCallbacks.&lt;/p&gt;
&lt;p&gt;如果是第一次添加回调的话, 就会执行 first = YES, 这个赋值非常的关键, 因为 first 不为 YES 那么 HTTP 请求就不会被初始化, 图片也无法被获取.&lt;/p&gt;
&lt;p&gt;然后, 在这个方法中会重新修正在 URLCallbacks 中存储的回调块.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *callbacksForURL = self.URLCallbacks[url];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableDictionary *callbacks = [NSMutableDictionary new];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock copy];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock copy];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[callbacksForURL addObject:callbacks];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.URLCallbacks[url] = callbacksForURL;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是第一次添加回调块, 那么就会直接运行这个 createCallback 这个 block, 而这个 block, 就是我们在前一个方法 downloadImageWithURL:options:progress:completed: 中传入的回调块.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// downloadImageWithURL:options:progress:completed: #4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self addProgressCallback:progressBlock andCompletedBlock:completedBlock forURL:url createCallback:^&amp;#123; ... &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们下面来分析这个传入的无参数的代码. 首先这段代码初始化了一个 NSMutableURLRequest:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// downloadImageWithURL:options:progress:completed: #11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableURLRequest *request = [[NSMutableURLRequest alloc]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initWithURL:url &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cachePolicy:...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    timeoutInterval:timeoutInterval];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个 request 就用于在之后发送 HTTP 请求.&lt;/p&gt;
&lt;p&gt;在初始化了这个 request 之后, 又初始化了一个 SDWebImageDownloaderOperation 的实例, 这个实例, 就是用于请求网络资源的操作. 它是一个 NSOperation 的子类,&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// downloadImageWithURL:options:progress:completed: #20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;operation = [[SDWebImageDownloaderOperation alloc]  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    initWithRequest:request&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    options:options&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    progress:...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    completed:...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cancelled:...&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是在初始化之后, 这个操作并不会开始(NSOperation 实例只有在调用 start 方法或者加入 NSOperationQueue 才会执行), 我们需要将这个操作加入到一个 NSOperationQueue 中.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloader&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// downloadImageWithURL:options:progress:completed: #59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[wself.downloadQueue addOperation:operation];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;只有将它加入到这个下载队列中, 这个操作才会执行.&lt;/p&gt;
&lt;h1 id=&quot;SDWebImageDownloaderOperation&quot;&gt;&lt;a href=&quot;#SDWebImageDownloaderOperation&quot; class=&quot;headerlink&quot; title=&quot;SDWebImageDownloaderOperation&quot;&gt;&lt;/a&gt;SDWebImageDownloaderOperation&lt;/h1&gt;&lt;p&gt;这个类就是处理 HTTP 请求, URL 连接的类, 当这个类的实例被加入队列之后, start 方法就会被调用, 而 start 方法首先就会产生一个 NSURLConnection.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloaderOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// start #1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@synchronized (self) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.isCancelled) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.finished = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self reset];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.executing = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.thread = [NSThread currentThread];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而接下来这个 connection 就会开始运行:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloaderOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// start #29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.connection start];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;它会发出一个 SDWebImageDownloadStartNotification 通知&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// SDWebImageDownloaderOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// start #35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSNotificationCenter defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:self];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;/h1&gt;&lt;p&gt;在 start 方法调用之后, 就是 NSURLConnectionDataDelegate 中代理方法的调用.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)connectionDidFinishLoading:(NSURLConnection *)aConnection;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这三个代理方法中的前两个会不停回调 progressBlock 来提示下载的进度.&lt;/p&gt;
&lt;p&gt;而最后一个代理方法会在图片下载完成之后调用 completionBlock 来完成最后 UIImageView.image 的更新.&lt;/p&gt;
&lt;p&gt;而这里调用的 progressBlock completionBlock cancelBlock 都是在之前存储在 URLCallbacks 字典中的.&lt;/p&gt;
&lt;p&gt;到目前为止, 我们就基本解析了 SDWebImage 中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    sd_setImageWithURL:[NSURL URLWithString:@&amp;quot;url&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    placeholderImage:[UIImage imageNamed:@&amp;quot;placeholder.png&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个方法执行的全部过程了.&lt;/p&gt;
&lt;h1 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/sdwebimage-flow-chart.png?imageView/2/w/400&quot; alt=&quot;流程图&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们使用一个流程图来表示上述方法所执行的全过程.&lt;br&gt;这段流程图展示了上述方法调用中大部分重要方法的调用.&lt;/p&gt;
&lt;p&gt;SDWebImage 如何为 UIImageView 添加图片(面试回答)&lt;/p&gt;
&lt;p&gt;SDWebImage 中为 UIView 提供了一个分类叫做 WebCache, 这个分类中有一个最常用的接口, &lt;code&gt;sd_setImageWithURL:placeholderImage:&lt;/code&gt;, 这个分类同时提供了很多类似的方法, 这些方法最终会调用一个同时具有 option progressBlock completionBlock 的方法, 而在这个类最终被调用的方法首先会检查是否传入了 placeholderImage 以及对应的参数, 并设置 placeholderImage.&lt;/p&gt;
&lt;p&gt;然后会获取 SDWebImageManager 中的单例调用一个 &lt;code&gt;downloadImageWithURL:...&lt;/code&gt; 的方法来获取图片, 而这个 manager 获取图片的过程有大体上分为两部分, 它首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以 url 作为数据的索引先在内存中寻找是否有对应的缓存, 如果缓存未命中就会在磁盘中利用 MD5 处理过的 key 来继续查询对应的数据, 如果找到了, 就会把磁盘中的缓存备份到内存中.&lt;/p&gt;
&lt;p&gt;然而, 假设我们在内存和磁盘缓存中都没有命中, 那么 manager 就会调用它持有的一个 SDWebImageDownloader 对象的方法 &lt;code&gt;downloadImageWithURL:...&lt;/code&gt; 来下载图片, 这个方法会在执行的过程中调用另一个方法 &lt;code&gt;addProgressCallback:andCompletedBlock:fotURL:createCallback:&lt;/code&gt; 来存储下载过程中和下载完成的回调, 当回调块是第一次添加的时候, 方法会实例化一个 NSMutableURLRequest 和 SDWebImageDownloaderOperation, 并将后者加入 downloader 持有的下载队列开始图片的异步下载.&lt;/p&gt;
&lt;p&gt;而在图片下载完成之后, 就会在主线程设置 image 属性, 完成整个图像的异步下载和配置.&lt;/p&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;SDWebImage 的图片加载过程其实很符合我们的直觉:&lt;/p&gt;
&lt;p&gt;查看缓存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存命中&lt;ul&gt;
&lt;li&gt;返回图片&lt;/li&gt;
&lt;li&gt;更新 UIImageView&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;缓存未命中&lt;ul&gt;
&lt;li&gt;异步下载图片&lt;/li&gt;
&lt;li&gt;加入缓存&lt;/li&gt;
&lt;li&gt;更新 UIImageView&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要有足够的耐心, 阅读这个开源项目的源代码也是没有太多困难的.&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://dravenes.me/ios-yuan-dai-ma-jie-xi-sdwebimage&quot;&gt;http://dravenes.me/ios-yuan-dai-ma-jie-xi-sdwebimage&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：世人都说阅读源代码对于功力的提升是十分显著的, 但是很多的著名开源框架源代码动辄上万行, 复杂度实在太高, 曾经试图读一些开源框架的源代码, 比如说 AFNetworking, SDWebImage, ReactiveCocoa 但是由于当时比较浮躁, 实在没法静下心来看, 而且有一些急功近利, 所以面对宝藏实在无力挖掘. 而最近, 由于时间比较充裕, 也终于能静下心来一段一段分析这些著名项目的源代码. 本文主要分享SDWebImage框架源代码的相关信息. &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="开源框架" scheme="http://charsdavy.github.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>简单聊聊 iOS 中的网络加密</title>
    <link href="http://charsdavy.github.io/2016/06/15/ios-network-encrypt/"/>
    <id>http://charsdavy.github.io/2016/06/15/ios-network-encrypt/</id>
    <published>2016-06-14T23:55:50.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;导言&quot;&gt;&lt;a href=&quot;#导言&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h1&gt;&lt;p&gt;公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。&lt;/p&gt;
&lt;p&gt;但是不论在任何时候，都应该将服务置于HTTPS上，因为它可以避免中间人攻击的问题，还自带了基于非对称密钥的加密通道。&lt;/p&gt;
&lt;h1 id=&quot;HTTPS交互原理&quot;&gt;&lt;a href=&quot;#HTTPS交互原理&quot; class=&quot;headerlink&quot; title=&quot;HTTPS交互原理&quot;&gt;&lt;/a&gt;HTTPS交互原理&lt;/h1&gt;&lt;p&gt;简答说，HTTPS 就是 HTTP协议加了一层SSL协议的加密处理，SSL 证书就是遵守 SSL协议，由受信任的数字证书颁发机构CA（如GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。&lt;/p&gt;
&lt;p&gt;HTTPS 客户端与服务器交互过程：&lt;/p&gt;
&lt;p&gt;1）客户端发送请求，服务器返回公钥给客户端；&lt;/p&gt;
&lt;p&gt;2）客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器；&lt;/p&gt;
&lt;p&gt;3）服务器收到后，利用私钥解开得到对称加密秘钥，保存；&lt;/p&gt;
&lt;p&gt;4）之后的交互都使用对称加密后的数据进行交互。&lt;/p&gt;
&lt;h2 id=&quot;证书&quot;&gt;&lt;a href=&quot;#证书&quot; class=&quot;headerlink&quot; title=&quot;证书&quot;&gt;&lt;/a&gt;证书&lt;/h2&gt;&lt;p&gt;简单说，证书有两种，一种是正经的：&lt;/p&gt;
&lt;p&gt;CA颁发的证书&lt;/p&gt;
&lt;p&gt;一种是不正经的：&lt;/p&gt;
&lt;p&gt;自己生成签发的证书&lt;/p&gt;
&lt;h1 id=&quot;我们需要做什么&quot;&gt;&lt;a href=&quot;#我们需要做什么&quot; class=&quot;headerlink&quot; title=&quot;我们需要做什么&quot;&gt;&lt;/a&gt;我们需要做什么&lt;/h1&gt;&lt;p&gt;如果遇到正经的证书，我们直接用AFNetworking 直接请求就好了，AFNetworking 内部帮我们封装了HTTPS的请求方式，但是大部分公司接口都是不正经的证书，这时需要我们做以下几步：&lt;/p&gt;
&lt;p&gt;1）将服务器的公钥证书拖到Xcode中&lt;/p&gt;
&lt;p&gt;2）修改验证模式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;manager.securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModePublicKey];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;p&gt;简单来说，就是你本可以修改AFN这个设置来允许客户端接收服务器的任何证书，但是这么做有个问题，就是你无法验证证书是否是你的服务器后端的证书，给中间人攻击，即通过重定向路由来分析伪造你的服务器端打开了大门。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFSecurityPolicy *securityPolicy = [AFSecurityPolicy defaultPolicy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;securityPolicy.allowInvalidCertificates = YES;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;p&gt;AFNetworking是允许内嵌证书的，通过内嵌证书，AFNetworking就通过比对服务器端证书、内嵌的证书、站点域名是否一致来验证连接的服务器是否正确。由于CA证书验证是通过站点域名进行验证的，如果你的服务器后端有绑定的域名，这是最方便的。将你的服务器端证书，如果是pem格式的，用下面的命令转成cer格式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;openssl x509 -in &amp;lt;你的服务器证书&amp;gt;.pem -outform der -out server.cer&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后将生成的server.cer文件，如果有自建ca，再加上ca的cer格式证书，引入到app的bundle里，AFNetworking在&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModeCertificate];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AFSecurityPolicy *securityPolicy = [AFSecurityPolicy AFSSLPinningModePublicKey];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;情况下，会自动扫描bundle中.cer的文件，并引入，这样就可以通过自签证书来验证服务器唯一性了。&lt;/p&gt;
&lt;h1 id=&quot;AFSecurityPolicy三种验证模式&quot;&gt;&lt;a href=&quot;#AFSecurityPolicy三种验证模式&quot; class=&quot;headerlink&quot; title=&quot;AFSecurityPolicy三种验证模式&quot;&gt;&lt;/a&gt;AFSecurityPolicy三种验证模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AFSSLPinningModeNone&lt;br&gt;这个模式表示不做SSL pinning，&lt;br&gt;只跟浏览器一样在系统的信任机构列表里验证服务端返回的证书。若证书是信任机构签发的就会通过，若是自己服务器生成的证书就不会通过。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AFSSLPinningModeCertificate&lt;br&gt;这个模式表示用证书绑定方式验证证书，需要客户端保存有服务端的证书拷贝，这里验证分两步，第一步验证证书的域名有效期等信息，第二步是对比服务端返回的证书跟客户端返回的是否一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AFSSLPinningModePublicKey&lt;br&gt;这个模式同样是用证书绑定方式验证，客户端要有服务端的证书拷贝，&lt;br&gt;只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/75d96b72bfb1&quot;&gt;http://www.jianshu.com/p/75d96b72bfb1&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：公司的接口一般会两种协议的，一种HTTP，一种HTTPS的，HTTP 只要请求，服务器就会响应，如果我们不对请求和响应做出加密处理，所有信息都是会被检测劫持到的，是很不安全的，客户端加密可以使用本文这套工具类进行处理。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://charsdavy.github.io/categories/network/"/>
    
    
      <category term="开源框架" scheme="http://charsdavy.github.io/tags/framework/"/>
    
  </entry>
  
  <entry>
    <title>State 模式</title>
    <link href="http://charsdavy.github.io/2016/06/10/state-pattern/"/>
    <id>http://charsdavy.github.io/2016/06/10/state-pattern/</id>
    <published>2016-06-10T07:51:37.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.文章主要分享State模式相关内容.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-charsdavy-github-io-2016-06-10-state-pattern-1.png?imageView/2/w/460&quot; alt=&quot;State模式图&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;不同的状态,不同的行为;或者说,每个状态有着相应的行为.&lt;/p&gt;
&lt;h1 id=&quot;何时使用&quot;&gt;&lt;a href=&quot;#何时使用&quot; class=&quot;headerlink&quot; title=&quot;何时使用&quot;&gt;&lt;/a&gt;何时使用&lt;/h1&gt;&lt;p&gt;State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用 if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.&lt;/p&gt;
&lt;p&gt;不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.&lt;/p&gt;
&lt;p&gt;参考网址：&lt;br&gt;&lt;a href=&quot;http://www.jdon.com/designpatterns/designpattern_State.htm&quot;&gt;http://www.jdon.com/designpatterns/designpattern_State.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;举例来说：一个人具有生气，高兴和抓狂等状态，在这些状态下做同一个事情可能会有不同的结果，一个人的心情可能在这三种状态中循环转变。使用一个moodState类表示一个人的心情，使用mad,Happy,Angry类代表不同的心情。使用UML图表示如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-charsdavy-github-io-2016-06-10-state-pattern-2.png?imageView/2/w/460&quot; alt=&quot;State模式UML图&quot;&gt;&lt;/p&gt;
&lt;p&gt;适用性：在下面的两情况下均可以使用State模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个对象的行为取决于它的状态，并且必须在运行时刻根据状态改变它的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个操作中含有庞大的多分支的条件豫剧，并且这些分支依赖于该对象的状态，这个状态通常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构，State模式将每一个条件分支放入一个单独的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象而独立变化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参与者：    &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Context(环境，Person)定义客户感兴趣的类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;State(Moodstate)：定义一个接口以封装与Context的一个特定状态相关的行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ConcreteState Subclasses(具体状态子类，如Angry)每一个子类实现一个与Context的状态相关的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们的协作关系是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Context将于状态相关的请求委托给当前的ConcreteState对象处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context可将自身作为一个参数传递给处理该请求的状态对象，这使得状态对象在必要的时候可访问Context。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context是客户使用的主要接口，客户可用状态对象来配置一个Context，一旦一个Context配置完毕，他的客户不再需要直接与状态对象打交道。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context或者ConcreteState子类都可以决定哪个状态是另外那个状态的后继者，以及是在何种条件下进行状态转换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;相应的代码：&quot;&gt;&lt;a href=&quot;#相应的代码：&quot; class=&quot;headerlink&quot; title=&quot;相应的代码：&quot;&gt;&lt;/a&gt;相应的代码：&lt;/h1&gt;&lt;p&gt;MoodState代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public interface MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Angry代码:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;implements MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Person p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Angry(Person p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.p = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;I&amp;apos;m angry!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p.setState(new Happy(p));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Happy代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Happy implements MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Person p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Happy(Person p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.p = p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;I&amp;apos;m happy!&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p.setState(new Mad(p));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Mad代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Mad implements MoodState&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	Person p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Mad(Person p)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.p=p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;I&amp;apos;m Mad&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void changeState()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		p.setState( new Angry(p));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private MoodState state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public Person()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		state = new Mad(this);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void setState(MoodState state)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		this.state = state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void doSomething()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		state.doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		state.changeState();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Client代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package state;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Client&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] args)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Person p = new Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		for(int i=0;i&amp;lt;10;i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			p.doSomething();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h1&gt;&lt;p&gt;状态模式将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，使得状态转换显式化并且可以被共享。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：State模式在实际使用中比较多,适合”状态的切换”.因为我们经常会使用if else if else 进行状态切换, 如果针对状态的这样判断切换反复出现,我们就要联想到是否可以采取State模式了.不只是根据状态,也有根据属性.如果某个对象的属性不同,对象的行为就不一样,这点在数据库系统中出现频率比较高,我们经常会在一个数据表的尾部,加上property属性含义的字段,用以标识记录中一些特殊性质的记录,这种属性的改变(切换)又是随时可能发生的,就有可能要使用State.文章主要分享State模式相关内容.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-charsdavy-github-io-2016-06-10-state-pattern-1.png?imageView/2/w/460&quot; alt=&quot;State模式图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://charsdavy.github.io/categories/design-pattern/"/>
    
    
      <category term="Java" scheme="http://charsdavy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 运行时编程</title>
    <link href="http://charsdavy.github.io/2016/06/09/objc-run-time/"/>
    <id>http://charsdavy.github.io/2016/06/09/objc-run-time/</id>
    <published>2016-06-09T02:21:31.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;p&gt;Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于 Objective-C语言的操作系统，Objective-C基于该系统来工作。 &lt;/p&gt;
&lt;p&gt;本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。 &lt;/p&gt;
&lt;p&gt;通常，如果仅仅写一个Cocoa 程序，程序员不需要知道和理解Objective-C运行时系统的底层细节，但这篇文章仍然值得推荐阅读，以了解 Objective-C运行时系统的原理，并能更好的利用 Objective-C的优点。&lt;/p&gt;
&lt;h1 id=&quot;2-参考&quot;&gt;&lt;a href=&quot;#2-参考&quot; class=&quot;headerlink&quot; title=&quot;2 参考&quot;&gt;&lt;/a&gt;2 参考&lt;/h1&gt;&lt;p&gt;《Objective-C 2.0 运行时系统参考库》描述了Objective-C运行库的数据结构和函数接口。程序可以通过这些接口来和Objective-C运行时系统交互。例如，您可以增加一个类或者方法，或者获得所有类的定义列表等。&lt;/p&gt;
&lt;p&gt;《Objective-C 2.0 程序设计语言》介绍了Objective-C语言本身。&lt;/p&gt;
&lt;p&gt;《Objective-C 版本说明》给出了在最近版本的Mac OS X系统中关于Objective-C运行时系统的一些改动。&lt;/p&gt;
&lt;h1 id=&quot;3-运行时系统的版本和平台&quot;&gt;&lt;a href=&quot;#3-运行时系统的版本和平台&quot; class=&quot;headerlink&quot; title=&quot;3 运行时系统的版本和平台&quot;&gt;&lt;/a&gt;3 运行时系统的版本和平台&lt;/h1&gt;&lt;p&gt;在不同的平台上Objective-C运行时系统的版本也不相同。&lt;/p&gt;
&lt;h2 id=&quot;3-1-早期版本和现行版本&quot;&gt;&lt;a href=&quot;#3-1-早期版本和现行版本&quot; class=&quot;headerlink&quot; title=&quot;3.1 早期版本和现行版本&quot;&gt;&lt;/a&gt;3.1 早期版本和现行版本&lt;/h2&gt;&lt;p&gt;Objective-C运行时系统有两个已知版本：早期版本和现行版本。&lt;/p&gt;
&lt;p&gt;现行版本主要是Objective-C 2.0 及与其相关的新特性。早期版本的编程接口见《Objective-C 1运行时系统参考库》；现行版本的编程接口见《Objective-C 2.0  运行时系统参考库》。&lt;/p&gt;
&lt;p&gt;在现行版本中，最显著的新特性就是实例变量是“健壮（non-fragile ）的”：&lt;/p&gt;
&lt;p&gt;1）在早期版本中，如果您改变类中实例变量的布局，您必须重新编译该类的所有子类。&lt;/p&gt;
&lt;p&gt;2）在现行版本中，如果您改变类中实例变量的布局，您无需重新编译该类的任何子类。&lt;/p&gt;
&lt;p&gt;此外，现行版本支持声明property 的synthesis属性（参考《Objective-C 2.0 程序设计语言》的“属性”一节）。&lt;/p&gt;
&lt;h2 id=&quot;3-2-平台&quot;&gt;&lt;a href=&quot;#3-2-平台&quot; class=&quot;headerlink&quot; title=&quot;3.2 平台&quot;&gt;&lt;/a&gt;3.2 平台&lt;/h2&gt;&lt;p&gt;iPhone 程序和Mac OS X 10.5及以后的系统中的64位程序使用的都是Objective-C运行时系统的现行版本。&lt;/p&gt;
&lt;p&gt;其它情况（Mac OS X系统中的32位程序）使用的是早期版本。&lt;/p&gt;
&lt;h1 id=&quot;4-和运行时系统的交互&quot;&gt;&lt;a href=&quot;#4-和运行时系统的交互&quot; class=&quot;headerlink&quot; title=&quot;4 和运行时系统的交互&quot;&gt;&lt;/a&gt;4 和运行时系统的交互&lt;/h1&gt;&lt;p&gt;Objective-C程序有三种途径和运行时系统交互：&lt;/p&gt;
&lt;p&gt;1）通过 Objective-C源代码；&lt;/p&gt;
&lt;p&gt;2）通过 Foundation框架中类NSObject的方法；&lt;/p&gt;
&lt;p&gt;3）通过直接调用运行时系统的函数。&lt;/p&gt;
&lt;h2 id=&quot;4-1-通过Objective-C源代码&quot;&gt;&lt;a href=&quot;#4-1-通过Objective-C源代码&quot; class=&quot;headerlink&quot; title=&quot;4.1 通过Objective-C源代码&quot;&gt;&lt;/a&gt;4.1 通过Objective-C源代码&lt;/h2&gt;&lt;p&gt;大部分情况下，运行时系统在后台自动运行，您只需编写和编译Objective-C源代码。 &lt;/p&gt;
&lt;p&gt;当您编译Objective-C类和方法时，编译器为实现语言动态特性将自动创建一些数据结构和函数。&lt;/p&gt;
&lt;p&gt;这些数据结构包含类定义和协议类定义中的信息，如在《Objective-C 2.0 程序设计语言》中“定义类”和“协议类”一节所讨论的类的对象和协议类的对象，方法选标，实例变量模板，以及其它来自于源代码的信息。运行时系统的主要功能就是根据源代码中的表达式发送消息，如“消息”一节所述。&lt;/p&gt;
&lt;h2 id=&quot;4-2-通过类NSObject的方法&quot;&gt;&lt;a href=&quot;#4-2-通过类NSObject的方法&quot; class=&quot;headerlink&quot; title=&quot;4.2 通过类NSObject的方法&quot;&gt;&lt;/a&gt;4.2 通过类NSObject的方法&lt;/h2&gt;&lt;p&gt;Cocoa 程序中绝大部分类都是NSObject类的子类，所以大部分都继承了NSObject类的方法，因而继承了NSObject的行为。（NSProxy类是个例外；更多细节参考“消息转发”一节。）然而，某些情况下，NSObject类仅仅定义了完成某件事情的模板，而没有提供所有需要的代码。&lt;/p&gt;
&lt;p&gt;例如，NSObject类定义了description 方法，返回该类内容的字符串表示。这主要是用来调试程序——GDB中的print-object方法就是直接打印出该方法返回的字符串。NSObject类中该方法的实现并不知道子类中的内容，所以它只是返回类的名字和对象的地址。NSObject的子类可以重新实现该方法以提供更多的信息。例如，NSArray 类改写了该方法来返回NSArray 类包含的每个对象的内容。&lt;/p&gt;
&lt;p&gt;某些NSObject的方法只是简单地从运行时系统中获得信息，从而允许对象进行一定程度的自我检查。例如，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class 返回对象的类；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;isKindOfClass:和isMemberOfClass:检查对象是否在指定的类继承体系中；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;respondsToSelector:检查对象能否响应指定的消息；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;conformsToProtocol:检查对象是否实现了指定协议类的方法；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;methodForSelector:返回指定方法实现的地址。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;4-3-通过运行时系统的函数&quot;&gt;&lt;a href=&quot;#4-3-通过运行时系统的函数&quot; class=&quot;headerlink&quot; title=&quot;4.3 通过运行时系统的函数&quot;&gt;&lt;/a&gt;4.3 通过运行时系统的函数&lt;/h2&gt;&lt;p&gt;运行时系统是一个有公开接口的动态库，由一些数据结构和函数的集合组成，这些数据结构和函数的声明头文件在/usr/include/objc 中。这些函数支持用纯 C 的函数来实现Objective-C同样的功能。还有一些函数构成了NSObject类方法的基础。这些函数使得访问运行时系统接口和提供开发工具成为可能。尽管大部分情况下它们在 Objective-C程序不是必须的，但是有时候对于 Objecitve-C程序来说某些函数是非常有用的。&lt;/p&gt;
&lt;p&gt;这些函数的文档参见《Objective-C 2.0 运行时系统参考库》。&lt;/p&gt;
&lt;h1 id=&quot;5-消息&quot;&gt;&lt;a href=&quot;#5-消息&quot; class=&quot;headerlink&quot; title=&quot;5 消息&quot;&gt;&lt;/a&gt;5 消息&lt;/h1&gt;&lt;p&gt;本章节描述了代码的消息表达式如何转换为对objc_msgSend函数的调用，如何通过名字来指定一个方法，以及如何使用objc_msgSend函数。&lt;/p&gt;
&lt;h2 id=&quot;5-1-获得方法地址&quot;&gt;&lt;a href=&quot;#5-1-获得方法地址&quot; class=&quot;headerlink&quot; title=&quot;5.1 获得方法地址&quot;&gt;&lt;/a&gt;5.1 获得方法地址&lt;/h2&gt;&lt;p&gt;避免动态绑定的唯一办法就是取得方法的地址，并且直接像函数调用一样调用它。当一个方法会被连续调用很多次，而且您希望节省每次调用方法都要发送消息的开销时，使用方法地址来调用方法就显得很有效。&lt;/p&gt;
&lt;p&gt;利用NSObject类中的methodForSelector:方法，您可以获得一个指向方法实现的指针，并可以使用该指针直接调用方法实现。methodForSelector:返回的指针和赋值的变量类型必须完全一致，包括方法的参数类型和返回值类型都在类型识别的考虑范围中。&lt;/p&gt;
&lt;p&gt;下面的例子展示了怎么使用指针来调用setFilled:的方法实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void (*setter)(id, SEL, BOOL); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;setter = (void (*)(id, SEL, BOOL))[target methodForSelector:@selector(setFilled:)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for ( i = 0; i &amp;lt; 1000, i++ ) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setter(targetList[i], @selector(setFilled:), YES);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方法指针的第一个参数是接收消息的对象（self），第二个参数是方法选标（_cmd）。这两个参数在方法中是隐藏参数，但使用函数的形式来调用方法时必须显示的给出。&lt;/p&gt;
&lt;p&gt;使用methodForSelector:来避免动态绑定将减少大部分消息的开销，但是这只有在指定的消息被重复发送很多次时才有意义，例如上面的for 循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;methodForSelector:是Cocoa 运行时系统的提供的功能，而不是Objective-C语言本身的功能。&lt;/p&gt;
&lt;h2 id=&quot;5-2-objc-msgSend函数&quot;&gt;&lt;a href=&quot;#5-2-objc-msgSend函数&quot; class=&quot;headerlink&quot; title=&quot;5.2 objc_msgSend函数&quot;&gt;&lt;/a&gt;5.2 objc_msgSend函数&lt;/h2&gt;&lt;p&gt;在Objective-C中，消息是直到运行的时候才和方法实现绑定的。编译器会把一个消息表达式，&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[receiver message]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;转换成一个对消息函数objc_msgSend的调用。该函数有两个主要参数：消息接收者和消息对应的方法名字——也就是方法选标：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同时接收消息中的任意数目的参数：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;objc_msgSend(receiver, selector, arg1, arg2, ...)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;该消息函数做了动态绑定所需要的一切：&lt;/p&gt;
&lt;p&gt;1）它首先找到选标所对应的方法实现。因为不同的类对同一方法可能会有不同的实现，所以找到的方法实现依赖于消息接收者的类型。&lt;/p&gt;
&lt;p&gt;2）然后将消息接收者对象（指向消息接收者对象的指针）以及方法中指定的参数传给找到的方法实现。&lt;/p&gt;
&lt;p&gt;3）最后，将方法实现的返回值作为该函数的返回值返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;编译器将自动插入调用该消息函数的代码。您无须在代码中显示调用该消息函数。&lt;/p&gt;
&lt;p&gt;消息机制的关键在于编译器为类和对象生成的结构。每个类的结构中至少包括两个基本元素：&lt;/p&gt;
&lt;p&gt;1）指向父类的指针。&lt;/p&gt;
&lt;p&gt;2）类的方法表。方法表将方法选标和该类的方法实现的地址关联起来。例如，setOrigin::的方法选标和setOrigin::的方法实现的地址关联，display  的方法选标和display 的方法实现的地址关联，等等。&lt;/p&gt;
&lt;p&gt;当新的对象被创建时，其内存同时被分配，实例变量也同时被初始化。对象的第一个实例变量是一个指向该对象的类结构的指针，叫做isa。通过该指针，对象可以访问它对应的类以及相应的父类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管严格来说这并不是 Obective-C 语言的一部分，但是在Objective-C运行时系统中对象需要有isa 指针。对象和结构体struct objc_object（在objc/objc.h 中定义）必须“一致”。然而，您很少需要创建您自己的根对象，因为从 NSObject或者NSProxy 继承的对象都自动包括isa 变量。&lt;/p&gt;
&lt;p&gt;类和对象的结构如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-f237a0b62cb32d9b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当对象收到消息时，消息函数首先根据该对象的 isa 指针找到该对象所对应的类的方法表，并从表中寻找该消息对应的方法选标。如果找不到，objc_msgSend将继续从父类中寻找，直到 NSObject类。一旦找到了方法选标， objc_msgSend则以消息接收者对象为参数调用，调用该选标对应的方法实现。&lt;/p&gt;
&lt;p&gt;这就是在运行时系统中选择方法实现的方式。在面向对象编程中，一般称作方法和消息动态绑定的过程。&lt;/p&gt;
&lt;p&gt;为了加快消息的处理过程，运行时系统通常会将使用过的方法选标和方法实现的地址放入缓存中。每个类都有一个独立的缓存，同时包括继承的方法和在该类中定义的方法。消息函数会首先检查消息接收者对象对应的类的缓存（理论上，如果一个方法被使用过一次，那么它很可能被再次使用）。如果在缓存中已经有需要的方法选标，则消息仅仅比函数调用慢一点点。如果程序运行了足够长的时间，几乎每个消息都能在缓存中找到方法实现。程序运行时，缓存也将随着新的消息的增加而增加。&lt;/p&gt;
&lt;h2 id=&quot;5-3-使用隐藏的参数&quot;&gt;&lt;a href=&quot;#5-3-使用隐藏的参数&quot; class=&quot;headerlink&quot; title=&quot;5.3 使用隐藏的参数&quot;&gt;&lt;/a&gt;5.3 使用隐藏的参数&lt;/h2&gt;&lt;p&gt;当objc_msgSend找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现，同时，它还将传递两个隐藏的参数：&lt;/p&gt;
&lt;p&gt;1）接收消息的对象&lt;/p&gt;
&lt;p&gt;2）方法选标&lt;/p&gt;
&lt;p&gt;这些参数帮助方法实现获得了消息表达式的信息。它们被认为是“隐藏”的原因是它们并没有在定义方法的源代码中声明，而是在代码编译时是插入方法的实现中的。&lt;/p&gt;
&lt;p&gt;尽管这些参数没有被显示声明，但在源代码中仍然可以引用它们（就像可以引用消息接收者对象的实例变量一样）。在方法中可以通过 self来引用消息接收者对象，通过选标_cmd来引用方法本身。&lt;/p&gt;
&lt;p&gt;在下面的例子中，_cmd指的是strange 方法，self指的收到strange 消息的对象。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- strange  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id  target = getTheReceiver();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SEL method = getTheMethod();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( target == self || method == _cmd )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [target performSelector:method];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这两个参数中，self更有用一些。实际上，它是在方法实现中访问消息接收者对象的实例变量的途径。 &lt;/p&gt;
&lt;h1 id=&quot;6-动态方法解析&quot;&gt;&lt;a href=&quot;#6-动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;6 动态方法解析&quot;&gt;&lt;/a&gt;6 动态方法解析&lt;/h1&gt;&lt;p&gt;本章节将描述怎样动态地提供一个方法的实现。&lt;/p&gt;
&lt;h2 id=&quot;6-1-动态方法解析&quot;&gt;&lt;a href=&quot;#6-1-动态方法解析&quot; class=&quot;headerlink&quot; title=&quot;6.1 动态方法解析&quot;&gt;&lt;/a&gt;6.1 动态方法解析&lt;/h2&gt;&lt;p&gt;有时候，程序员需要动态地提供一个方法的实现。例如，Objective-C中属性（Property ）（ 参考《Objective-C 2.0 程序设计语言》中“属性”小节）前的修饰符@dynamic&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@dynamic propertyName;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;表示编译器须动态地生成该属性对应地方法。&lt;/p&gt;
&lt;p&gt;程序员可以通过实现&lt;code&gt;resolveInstanceMethod:和resolveClassMethod:&lt;/code&gt;来动态地实现给定选标的对象方法或者类方法。&lt;/p&gt;
&lt;p&gt;Objective-C方法可以认为是至少有两个参数self和_cmd的C 函数。您可以通过class_addMethod 方法将一个函数加入到类的方法中。例如，有如下的函数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;void dynamicMethodIMP(id self, SEL _cmd) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // implementation ....&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;程序员可以通过resolveInstanceMethod:将它作为类方法resolveThisMethodDynamically的实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@implementation MyClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (BOOL)resolveInstanceMethod:(SEL)aSEL  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (aSEL == @selector(resolveThisMethodDynamically)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &amp;quot;v@:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          return YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [super resolveInstanceMethod:aSEL];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常消息转发（见 “消息转发”）和动态方法解析是互不相干的。在进入消息转发机制之前，respondsToSelector:和instancesRespondToSelector:  会被首先调用。您可以在这两个方法中为传进来的选标提供一个IMP 。如果您实现了resolveInstanceMethod:方法，但是仍然希望正常的消息转发机制进行，您只需要返回NO即可。 &lt;/p&gt;
&lt;h2 id=&quot;6-2-动态加载&quot;&gt;&lt;a href=&quot;#6-2-动态加载&quot; class=&quot;headerlink&quot; title=&quot;6.2 动态加载&quot;&gt;&lt;/a&gt;6.2 动态加载&lt;/h2&gt;&lt;p&gt;Objective-C程序可以在运行时链接和载入新的类和范畴类。新载入的类和在程序启动时载入的类并没有区别。 &lt;/p&gt;
&lt;p&gt;动态加载可以用在很多地方。例如，系统配置中的模块就是被动态加载的。&lt;br&gt;在Cocoa 环境中，动态加载一般被用来对应用程序进行定制。您的程序可以在运行时加载其他程序员编写的模块——和Interface Build 载入定制的调色板以及系统配置程序载入定制的模块的类似。这些模块通过您许可的方式扩展您的程序，而您无需自己来定义或者实现。您提供了框架，而其它的程序员提供了实现。 &lt;/p&gt;
&lt;p&gt;尽管已经有一个运行时系统的函数来动态加载Mach-O文件中的Objective-C模块（objc_loadModules，在objc/objc-load.h中定义），Cocoa 的NSBundle类为动态加载提供了一个更方便的接口——一个面向对象的，已经和相关服务集成的接口。关于NSBundle类的更多相关信息请参考Foundation 框架中关于NSBundle类的文档。关于Mach-O文件的有关信息请参考《Mac OS X ABI Mach-O  文件格式参考库》。&lt;/p&gt;
&lt;h1 id=&quot;7-消息转发&quot;&gt;&lt;a href=&quot;#7-消息转发&quot; class=&quot;headerlink&quot; title=&quot;7 消息转发&quot;&gt;&lt;/a&gt;7 消息转发&lt;/h1&gt;&lt;p&gt;通常，给一个对象发送它不能处理的消息会得到出错提示，然而，Objective-C运行时系统在抛出错误之前，会给消息接收对象发送一条特别的消息来通知该对象。&lt;/p&gt;
&lt;h2 id=&quot;7-1-消息转发&quot;&gt;&lt;a href=&quot;#7-1-消息转发&quot; class=&quot;headerlink&quot; title=&quot;7.1 消息转发&quot;&gt;&lt;/a&gt;7.1 消息转发&lt;/h2&gt;&lt;p&gt;如果一个对象收到一条无法处理的消息，运行时系统会在抛出错误前，给该对象发送一条forwardInvocation:消息，该消息的唯一参数是个NSInvocation类型的对象——该对象封装了原始的消息和消息的参数。&lt;/p&gt;
&lt;p&gt;程序员可以实现forwardInvocation:方法来对不能处理的消息做一些默认的处理，也可以以其它的某种方式来避免错误被抛出。如forwardInvocation:的名字所示，它通常用来将消息转发给其它的对象。 &lt;/p&gt;
&lt;p&gt;关于消息转发的作用，您可以考虑如下情景：假设，需要设计一个能够响应negotiate 消息的对象，并且能够包括其它类型的对象对消息的响应。通过在negotiate 方法的实现中将negotiate 消息转发给其它的对象这种方式可以很容易的达到这一目的。&lt;/p&gt;
&lt;p&gt;更进一步，假设您希望您的对象和另外一个类的对象对 negotiate 的消息的响应完全一致。一种可能的方式就是让您的类继承其它类的方法实现。然而，有时候这种方式不可行，因为您的类和其它类可能需要在不同的继承体系中响应negotiate 消息。&lt;/p&gt;
&lt;p&gt;虽然您的类无法继承其它类的negotiate 方法，您仍然可以提供一个方法实现，这个方法实现只是简单的将negotiate 消息转发给其他类的对象，就好像从其它类那里“借”来的实现一样。如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- negotiate &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( [someOtherObject respondsTo:@selector(negotiate)] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return [someOtherObject negotiate];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种方式显得有欠灵活，特别是有很多消息您都希望传递给其它对象时，您必须为每一种消息提供方法实现。此外，这种方式不能处理未知的消息。当您写下代码时，所有您需要转发的消息的集合也必须确定。然而，实际上，这个集合会随着运行时事件的发生，新方法或者新类的定义而变化。&lt;/p&gt;
&lt;p&gt;forwardInvocation:消息给这个问题提供了一个更特别的，动态的解决方案：当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过 forwardInvocation:消息通知该对象。每个对象都从NSObject类中继承了forwardInvocation:方法。然而，NSObject中的方法实现只是简单地调用了doesNotRecognizeSelector:。通过实现您自己的forwardInvocation:方法，您可以在该方法实现中将消息转发给其它对象。&lt;/p&gt;
&lt;p&gt;要转发消息给其它对象，forwardInvocation:方法所必须做的有：&lt;/p&gt;
&lt;p&gt;1）决定将消息转发给谁，并且 &lt;/p&gt;
&lt;p&gt;2）将消息和原来的参数一块转发出去 &lt;/p&gt;
&lt;p&gt;消息可以通过invokeWithTarget:方法来转发：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([someOtherObject respondsToSelector: [anInvocation selector]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [anInvocation invokeWithTarget:someOtherObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [super forwardInvocation:anInvocation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;转发消息后的返回值将返回给原来的消息发送者。返回值可以是任何类型的，包括：id，结构体，浮点数等。&lt;/p&gt;
&lt;p&gt;forwardInvocation:方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以像一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的“吃掉”某些消息，因此没有响应也没有错误。forwardInvocation:方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供的是将不同的对象链接到消息链的能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;forwardInvocation: 方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果您希望您的对象将negotiate 消息转发给其它对象，您的对象不能有negotiate 方法。否则，forwardInvocation:将不可能会被调用。&lt;/p&gt;
&lt;p&gt;更多消息转发的信息，参考Foundation框架参考库中NSInvocation类的文档。&lt;/p&gt;
&lt;h2 id=&quot;7-2-消息转发和多重继承&quot;&gt;&lt;a href=&quot;#7-2-消息转发和多重继承&quot; class=&quot;headerlink&quot; title=&quot;7.2 消息转发和多重继承&quot;&gt;&lt;/a&gt;7.2 消息转发和多重继承&lt;/h2&gt;&lt;p&gt;消息转发很像继承，并且可以用来在Objective-C程序中模拟多重继承。如下图所示，  一个对象通过转发来响应消息，看起来就像该对象从别的类那借来了或者“继承”了方法实现一样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-f060df75ab9be460.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在上图中，Warrior类的一个对象实例将negotiate 消息转发给Diplomat 类的一个实例。看起来，Warrior类似乎和Diplomat 类一样，响应negotiate消息，并且行为和Diplomat 一样（尽管实际上是Diplomat类响应了该消息）。&lt;/p&gt;
&lt;p&gt;转发消息的对象看起来有两个继承体系分支——自己的和响应消息的对象的。在上面的例子中，Warrior看起来同时继承自Diplomat 和自己的父类。&lt;/p&gt;
&lt;p&gt;消息转发提供了多重继承的很多特性。然而，两者有很大的不同：多重继承是将不同的行为封装到单个的对象中，有可能导致庞大的，复杂的对象。而消息转发是将问题分解到更小的对象中，但是又以一种对消息发送对象来说完全透明的方式将这些对象联系起来。&lt;/p&gt;
&lt;h2 id=&quot;7-3-消息代理对象&quot;&gt;&lt;a href=&quot;#7-3-消息代理对象&quot; class=&quot;headerlink&quot; title=&quot;7.3 消息代理对象&quot;&gt;&lt;/a&gt;7.3 消息代理对象&lt;/h2&gt;&lt;p&gt;消息转发不仅和继承很像，它也使得以一个轻量级的对象（消息代理对象）代表更多的对象进行消息处理成为可能。&lt;/p&gt;
&lt;p&gt;《Objective-C 2.0 程序设计语言》中“远程消息”一节中的代理类就是这样一个代理对象。代理类负责将消息转发给远程消息接收对象的管理细节，保证消息参数的传输等等。但是消息类没有进一步的复制远程对象的功能，它只是将远程对象映射到一个本地地址上，从而能够接收其它应用程序的消息。 &lt;/p&gt;
&lt;p&gt;同时也存在着其它类型的消息代理对象。例如，假设您有个对象需要操作大量的数据——它可能需要创建一个复杂的图片或者需要从磁盘上读一个文件的内容。创建一个这样的对象是很费时的，您可能希望能推迟它的创建时间——直到它真正需要时，或者系统资源空闲时。同时，您又希望至少有一个预留的对象和程序中其它对象交互。&lt;/p&gt;
&lt;p&gt;在这种情况下，您可以为该对象创建一个轻量的代理对象。该代理对象可以有一些自己的功能，例如响应数据查询消息，但是它主要的功能是代表某个对象，当时间到来时，将消息转发给被代表的对象。当代理对象的forwardInvocation:方法收到需要转发给被代表的对象的消息时，代理对象会保证所代表的对象已经存在，否则就创建它。所有发到被代表的对象的消息都要经过代理对象，对程序来说，代理对象和被代表的对象是一样的。&lt;/p&gt;
&lt;h2 id=&quot;7-4-消息转发和类继承&quot;&gt;&lt;a href=&quot;#7-4-消息转发和类继承&quot; class=&quot;headerlink&quot; title=&quot;7.4 消息转发和类继承&quot;&gt;&lt;/a&gt;7.4 消息转发和类继承&lt;/h2&gt;&lt;p&gt;尽管消息转发很“像”继承，但它不是继承。例如在NSObject类中，方法respondsToSelector:和isKindOfClass:只会出现在继承链中，而不是消息转发链中。例如，如果向一个 Warrior类的对象询问它能否响应negotiate 消息，&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if ( [aWarrior respondsToSelector:@selector(negotiate)] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值是NO，尽管该对象能够接收和响应negotiate。&lt;/p&gt;
&lt;p&gt;大部分情况下，NO是正确的响应。但不是所有时候都是的。例如，如果您使用消息转发来创建一个代理对象以扩展某个类的能力，这里的消息转发必须和继承一样，尽可能的对用户透明。如果您希望您的代理对象看起来就像是继承自它代表的对象一样，您需要重新实现respondsToSelector:和isKindOfClass:方法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)respondsToSelector:(SEL)aSelector &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ( [super respondsToSelector:aSelector] )&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        /* Here, test whether the aSelector message can     *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * be forwarded to another object and whether that  *&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         * object can respond to it. Return YES if it can.  */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;除了respondsToSelector:和isKindOfClass:方法外，instancesRespondToSelector:方法也必须重新实现。如果您使用的是协议类，需要重新实现的还有conformsToProtocol:方法。类似地，如果对象需要转发远程消息，则 methodSignatureForSelector:方法必须能够返回实际响应消息的方法的描述。例如，如果对象需要将消息转发给它所代表的对象，您可能需要如下的methodSignatureForSelector:实现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMethodSignature* signature = [super methodSignatureForSelector:selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!signature) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       signature = [surrogate methodSignatureForSelector:selector];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return signature;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;您也可以将消息转发的部分放在一段私有的代码里，然后从forwardInvocation:调用它。&lt;br&gt;注意：消息转发是一个比较高级的技术，仅适用于没有其它更好的解决办法的情况。它并不是用来代替继承的。如果您必须使用该技术，请确定您已经完全理解了转发消息的类和接收转发消息的类的行为。&lt;/p&gt;
&lt;p&gt;本节中涉及的方法在Foundation框架参考库中的NSObject类的文档中都有描述。关于invokeWithTarget:的具体信息，请参考Foundation框架参考库中NSInvocation类的文档。&lt;/p&gt;
&lt;h1 id=&quot;8-属性声明&quot;&gt;&lt;a href=&quot;#8-属性声明&quot; class=&quot;headerlink&quot; title=&quot;8 属性声明&quot;&gt;&lt;/a&gt;8 属性声明&lt;/h1&gt;&lt;p&gt;当编译器遇到一个属性（Property ）声明时（参考《Objective-C 2.0 程序设计语言》中的“属性”小节），编译器将产生一些描述性的元数据与属性所在的类或者协议类关联。您可以通过函数访问元数据，这些函数支持在类或者协议类中通过名字来查找，通过@encode获得属性的类型编码，将属性的特征（Attribute ）作为C字符串的数组返回等。每个类或者协议类都维护了一个声明了的属性列表。&lt;/p&gt;
&lt;h2 id=&quot;8-1-属性类型和相关函数&quot;&gt;&lt;a href=&quot;#8-1-属性类型和相关函数&quot; class=&quot;headerlink&quot; title=&quot;8.1 属性类型和相关函数&quot;&gt;&lt;/a&gt;8.1 属性类型和相关函数&lt;/h2&gt;&lt;p&gt;属性（Property ）类型定义了对描述属性的结构体objc_property 的不透明的句柄。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_property *Property;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;您可以使用函数class_copyPropertyList和protocol_copyPropertyList 来获得类（包括范畴类）或者协议类中的属性列表：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例如，有如下的类声明：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Lender : NSObject &amp;#123; float alone;&amp;#125;@property float alone;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以像这样获得它的属性：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id LenderClass = objc_getClass(&amp;quot;Lender&amp;quot;);unsigned int outCount;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;amp;outCount);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还可以通过property_getName函数获得属性的名字：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const char *property_getName(objc_property_t property)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;函数class_getProperty 和protocol_getProperty则在类或者协议类中返回具有给定名字的属性的引用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t class_getProperty(Class cls, const char *name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t protocol_getProperty(Protocol *proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过property_getAttributes函数可以获得属性的名字和@encode编码。关于类型编码的更多细节，参考“类型编码”一节；关于属性的类型编码，见“属性类型编码”及“属性特征的描述范例”。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const char *property_getAttributes(objc_property_t property)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;综合起来，您可以通过下面的代码得到一个类中所有的属性。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id LenderClass = objc_getClass(&amp;quot;Lender&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsigned int outCount, i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;amp;outCount);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (i = 0; i &amp;lt; outCount; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    objc_property_t property = properties[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fprintf(stdout,  &amp;quot;%s  %s\n&amp;quot;,  property_getName(property), property_getAttributes(property));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;8-2-属性类型编码&quot;&gt;&lt;a href=&quot;#8-2-属性类型编码&quot; class=&quot;headerlink&quot; title=&quot;8.2 属性类型编码&quot;&gt;&lt;/a&gt;8.2 属性类型编码&lt;/h2&gt;&lt;p&gt;property_getAttributes函数将返回属性（Property）的名字，@encode 编码，以及其它特征（Attribute ）。&lt;/p&gt;
&lt;p&gt;1）property_getAttributes返回的字符串以字母T 开始，接着是@encode 编码和逗号。&lt;/p&gt;
&lt;p&gt;2）如果属性有readonly修饰，则字符串中含有R 和逗号。 &lt;/p&gt;
&lt;p&gt;3）如果属性有copy或者retain修饰，则字符串分别含有C 或者&amp;amp;，然后是逗号。 &lt;/p&gt;
&lt;p&gt;4）如果属性定义有定制的getter 和setter 方法，则字符串中有G 或者S 跟着相应的方法名以及逗号（例如，GcustomGetter，ScustomSetter:，，）。&lt;/p&gt;
&lt;p&gt;如果属性是只读的，且有定制的get 访问方法，则描述到此为止。&lt;/p&gt;
&lt;p&gt;5）字符串以V 然后是属性的名字结束。&lt;/p&gt;
&lt;p&gt;范例请参考 “属性特征的描述范例” 一节。&lt;/p&gt;
&lt;h2 id=&quot;8-3-属性特征的描述范例&quot;&gt;&lt;a href=&quot;#8-3-属性特征的描述范例&quot; class=&quot;headerlink&quot; title=&quot;8.3 属性特征的描述范例&quot;&gt;&lt;/a&gt;8.3 属性特征的描述范例&lt;/h2&gt;&lt;p&gt;给定如下定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;enum FooManChu &amp;#123; FOO, MAN, CHU &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct YorkshireTeaStruct &amp;#123; int pot; char lady; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct YorkshireTeaStruct YorkshireTeaStructType;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;union MoneyUnion &amp;#123; float alone; double down; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下表给出了属性（Property ）声明以及property_getAttributes返回的相应的字符串：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性声明&lt;/th&gt;
&lt;th&gt;属性描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;@property char charDefault;&lt;/td&gt;
&lt;td&gt;Tc,VcharDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property double doubleDefault;&lt;/td&gt;
&lt;td&gt;Td,VdoubleDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property enum FooManChuenumDefault;&lt;/td&gt;
&lt;td&gt;Ti,VenumDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property float floatDefault;&lt;/td&gt;
&lt;td&gt;Tf,VfloatDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int intDefault;&lt;/td&gt;
&lt;td&gt;Ti,VintDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property long longDefault;&lt;/td&gt;
&lt;td&gt;Tl,VlongDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property short shortDefault;&lt;/td&gt;
&lt;td&gt;Ts,VshortDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property singed singedDefault;&lt;/td&gt;
&lt;td&gt;Ti,VsingedDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property struct YorkshireTeaStruct structDefault;&lt;/td&gt;
&lt;td&gt;T{ YorkshireTeaStruct =”pot”i”lady”c},VstructDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property YorkshireTeaStructType typedefDefault;&lt;/td&gt;
&lt;td&gt;T{ YorkshireTeaStruct =”pot”i”lady”c},VtypedefDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property union MoneyUnion unionDefault;&lt;/td&gt;
&lt;td&gt;T(MoneyUnion=”alone”f”down”d),VunionDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property unsigned unsignedDefault;&lt;/td&gt;
&lt;td&gt;TI,VunsignedDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int (&lt;em&gt;functionPointerDefault)(char &lt;/em&gt;);&lt;/td&gt;
&lt;td&gt;T^?,VfunctionPointerDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property void *voidPointerDefault;&lt;/td&gt;
&lt;td&gt;T^v,VvoidPointerDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property id idDefault;&lt;/td&gt;
&lt;td&gt;T@,VidDefault&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int *intPointer;&lt;/td&gt;
&lt;td&gt;T^i,VintPointer&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property int intSynthEquals;In the implementation block: @synthesize intSynthEquals = _intSynthEquals;&lt;/td&gt;
&lt;td&gt;Ti,V_intSynthEquals&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (getter=intGetFoo, setter=intSetFoo:) int intSetterGetter;&lt;/td&gt;
&lt;td&gt;Ti,GintGetFoo,SintSetFoo:,VintSetterGetter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (readonly)  int intReadonly;&lt;/td&gt;
&lt;td&gt;Ti,R,VintReadonly&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (getter=isIntReadOnlyGetter,  readonly)  int intReadonlyGetter;&lt;/td&gt;
&lt;td&gt;Ti,R,GisIntReadOnlyGetter&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (readwrite)  int intReadwrite;&lt;/td&gt;
&lt;td&gt;Ti,VintReadwrite&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (assign)  int intAssign;&lt;/td&gt;
&lt;td&gt;Ti,VintAssign&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (retain)  id idRetain;&lt;/td&gt;
&lt;td&gt;T@,&amp;amp;,VidRetain&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (copy) id idCopy;&lt;/td&gt;
&lt;td&gt;T@,C,VidCopy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property (nonatomic)  int intNonatomic;&lt;/td&gt;
&lt;td&gt;Ti,VintNonatomic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property(nonatomic, readonly,  copy)  id idReadonlyCopyNonatomic;&lt;/td&gt;
&lt;td&gt;T@,R,C,VidReadonlyCopyNonatomic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@property(nonatomic, readonly,  retain)  id idReadonlyRetainNonatomic;&lt;/td&gt;
&lt;td&gt;T@,R,&amp;amp;,VidReadonlyRetainNonatomic&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;9-类型编码&quot;&gt;&lt;a href=&quot;#9-类型编码&quot; class=&quot;headerlink&quot; title=&quot;9 类型编码&quot;&gt;&lt;/a&gt;9 类型编码&lt;/h1&gt;&lt;p&gt;为了和运行时系统协作，编译器将方法的返回类型和参数类型都编码成一个字符串，并且和方法选标关联在一起。这些编码在别的上下文环境中同样有用，所以您可以直接使@encode()编译指令来得到具体的编码。给定一个类型， @encode()将返回该类型的编码字符串。类型可以是基本类型例如整形，指针，结构体或者联合体，也可以是一个类，就和 C 语言中的sizeof()操作符的参数一样，可以是任何类型。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;char *buf1 = @encode(int **);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *buf2 = @encode(struct key);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *buf3 = @encode(Rectangle);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;下表列出了这些类型编码。注意，它们可能很多和您使用的对象编码有一些重合。然而，这里列出来的有些编码是您写编码器的时候不会使用的，也有一些不是@encode()产生的，但是在您写编码器的时候是会使用的。（关于对象编码的更多信息，请参考Foundation框架参考库中的NSCoder类文档。）&lt;/p&gt;
&lt;p&gt;Objective-C类型编码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l&lt;/td&gt;
&lt;td&gt;long，在64位程序中，l为32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;unsigned char&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;unsigned int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;S&lt;/td&gt;
&lt;td&gt;unsigned short&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;unsigned long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Q&lt;/td&gt;
&lt;td&gt;unsigned long long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;f&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;C++标准的bool或者C99标准的_Bool&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v&lt;/td&gt;
&lt;td&gt;void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;字符串（char *）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;对象（无论是静态指定的还是通过id引用的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;#&lt;/td&gt;
&lt;td&gt;类（Class）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;:&lt;/td&gt;
&lt;td&gt;方法选标（SEL）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;[array type]&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;{name=type…}&lt;/td&gt;
&lt;td&gt;结构体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(name=type…)&lt;/td&gt;
&lt;td&gt;联合体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bnum&lt;/td&gt;
&lt;td&gt;num个bit的位域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;^type&lt;/td&gt;
&lt;td&gt;type类型的指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;未知类型（其他时候，一般用来指函数指针）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt; Objective-C 不支持long double 类型。@encode(long double)和double 一样，返回的字符串都是d。&lt;/p&gt;
&lt;p&gt;数组的类型编码以方括号来表示，紧接着左方括号的是数组元素的数量，然后是数据元素的类型。例如，一个12个浮点数（floats）指针的数组可以表示如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[12^f]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结构体和联合体分别用大括号和小括号表示。括号中首先是结构体标签，然后是一个“=”符号，接着是结构体中各个成员的编码。例如，结构体&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct example &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id   anObject;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char *aString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int  anInt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; Example;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;的编码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;example=@*i&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;定义的类型名（Example）和结构体标签（example）有同样的编码结果。指向结构体类型的指针的编码同样也包含了结构体内部数据成员的编码信息，如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;^&amp;#123;example=@*i&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而，更高层次的间接关联就没有了内部数据成员的编码信息：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;^^&amp;#123;example&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对象的编码类似结构体。例如， @encode()对NSObject编码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;NSObject=#&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;NSObject类仅声明了一个Class 类型的实例变量，isa。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管有一些编码无法从 @encode()的结果中直接得到，但是运行时系统会使用它们来表示协议类中方法的修饰符，这些编码如表所示。&lt;/p&gt;
&lt;p&gt;Objective-C方法编码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;const&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;in&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;inout&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;o&lt;/td&gt;
&lt;td&gt;out&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;O&lt;/td&gt;
&lt;td&gt;bycopy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;R&lt;/td&gt;
&lt;td&gt;byref&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;oneway&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;10-附言&quot;&gt;&lt;a href=&quot;#10-附言&quot; class=&quot;headerlink&quot; title=&quot;10 附言&quot;&gt;&lt;/a&gt;10 附言&lt;/h1&gt;&lt;p&gt;在此，运行时机制相关问题已经全部阐述。消息发送和转发是Runtime的强大之处，通过它，您可以为程序增加很多动态的行为，虽然在实际开发中很少直接使用这些机制（如直接调用objc_msgSend），但了解它们有助于您更多地去了解底层的实现。其实在实际的编码过程中，您也可以灵活地使用这些机制，去实现一些特殊的功能，如hook操作等。&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;http://www.apple.com.cn/developer/Documentation/index.html&quot;&gt;http://www.apple.com.cn/developer/Documentation/index.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Objective-C语言将决定尽可能的从编译和链接时推迟到运行时。只要有可能，Objective-C总是使用动态的方式来解决问题。这意味着Objective-C语言不仅需要一个编译器，同时也需要一个运行时系统来执行编译好的代码。这里的运行时系统扮演的角色类似于Objective-C语言的操作系统，Objective-C基于该系统来工作。本文章将具体介绍NSObject类以及Objective-C程序是如何与运行时系统交互的。特别地，本文章还给出来怎样在运行时动态地加载新类和将消息转发给其它对象的范例，同时也给出了怎样在程序运行时获取对象信息的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="Objective-C" scheme="http://charsdavy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Git 使用 - 远程操作</title>
    <link href="http://charsdavy.github.io/2016/06/05/git-using-remote/"/>
    <id>http://charsdavy.github.io/2016/06/05/git-using-remote/</id>
    <published>2016-06-05T03:03:55.000Z</published>
    <updated>2016-07-12T23:17:32.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt;是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
&lt;p&gt;Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop 的项目也迁移到了 Git 上。&lt;/p&gt;
&lt;p&gt;Git有很多优势，其中之一就是远程操作非常简单。但是，Git也是一把双刃剑，使用得当，将会尽享Git的便利与强大。本文将主要介绍几个常用的Git远程操作命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:05:git-using-remote:1.jpg?imageView/2/w/560&quot; alt=&quot;introduction&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;git-clone&quot;&gt;&lt;a href=&quot;#git-clone&quot; class=&quot;headerlink&quot; title=&quot;git clone&quot;&gt;&lt;/a&gt;git clone&lt;/h1&gt;&lt;p&gt;远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到&lt;code&gt;git clone&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone &amp;lt;版本库的网址&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，克隆Weibo的版本库。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone https://github.com/charsdavy/iWeibo.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为&lt;code&gt;git clone&lt;/code&gt;命令的第二个参数。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone &amp;lt;版本库的网址&amp;gt; &amp;lt;本地目录名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;git clone&lt;/code&gt;支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone http[s]://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone ssh://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone git://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone /opt/git/project.git &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone file:///opt/git/project.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone ftp[s]://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git clone rsync://example.com/path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;SSH协议还有另一种写法：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone [user@]example.com:path/to/repo.git/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考&lt;a href=&quot;http://git-scm.com/book/en/Git-on-the-Server-The-Protocols&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;git-remote&quot;&gt;&lt;a href=&quot;#git-remote&quot; class=&quot;headerlink&quot; title=&quot;git remote&quot;&gt;&lt;/a&gt;git remote&lt;/h1&gt;&lt;p&gt;为了便于管理，Git要求每个远程主机都必须指定一个主机名。&lt;code&gt;git remote&lt;/code&gt;命令就用于管理主机名。&lt;/p&gt;
&lt;p&gt;不带选项的时候，&lt;code&gt;git remote&lt;/code&gt;命令列出所有远程主机。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用-v选项，可以参看远程主机的网址。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git remote -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin  git@github.com:charsdavy/iWeibo.git (fetch)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin  git@github.com:charsdavy/iWeibo.git (push)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。&lt;/p&gt;
&lt;p&gt;克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用&lt;code&gt;git clone&lt;/code&gt;命令的-o选项指定。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git clone -o Weibo https://github.com/charsdavy/iWeibo.git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git remote&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Weibo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，克隆的时候，指定远程主机叫做Weibo。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git remote show命令加上主机名，可以查看该主机的详细信息。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote show &amp;lt;主机名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote add命令用于添加远程主机。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote add &amp;lt;主机名&amp;gt; &amp;lt;网址&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote rm命令用于删除远程主机。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote rm &amp;lt;主机名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git remote rename命令用于远程主机的改名。&lt;/p&gt;
&lt;p&gt;  &lt;code&gt;$ git remote rename &amp;lt;原主机名&amp;gt; &amp;lt;新主机名&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;git-fetch&quot;&gt;&lt;a href=&quot;#git-fetch&quot; class=&quot;headerlink&quot; title=&quot;git fetch&quot;&gt;&lt;/a&gt;git fetch&lt;/h1&gt;&lt;p&gt;一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到&lt;code&gt;git fetch&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch &amp;lt;远程主机名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令将某个远程主机的更新，全部取回本地。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git fetch&lt;/code&gt;命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;git fetch&lt;/code&gt;取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，取回origin主机的master分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt;命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;origin/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git branch -a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  remotes/origin/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，本地主机的当前分支是master，远程分支是origin/master。&lt;/p&gt;
&lt;p&gt;取回远程主机的更新以后，可以在它的基础上，使用&lt;code&gt;git checkout&lt;/code&gt;命令创建一个新的分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b newBrach origin/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，在origin/master的基础上，创建一个新分支。&lt;/p&gt;
&lt;p&gt;此外，也可以使用&lt;code&gt;git merge&lt;/code&gt;命令或者&lt;code&gt;git rebase&lt;/code&gt;命令，在本地分支上合并远程分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git merge origin/master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git rebase origin/master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示在当前分支上，合并origin/master。&lt;/p&gt;
&lt;h1 id=&quot;git-pull&quot;&gt;&lt;a href=&quot;#git-pull&quot; class=&quot;headerlink&quot; title=&quot;git pull&quot;&gt;&lt;/a&gt;git pull&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin next:master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果远程分支是与当前分支合并，则冒号后面的部分可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做&lt;code&gt;git fetch&lt;/code&gt;，再做&lt;code&gt;git merge&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git merge origin/next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在&lt;code&gt;git clone&lt;/code&gt;的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。&lt;/p&gt;
&lt;p&gt;Git也允许手动建立追踪关系。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git branch --set-upstream master origin/next&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令指定master分支追踪origin/next分支。&lt;/p&gt;
&lt;p&gt;如果当前分支与远程分支存在追踪关系，&lt;code&gt;git pull&lt;/code&gt;就可以省略远程分支名。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。&lt;/p&gt;
&lt;p&gt;如果当前分支只有一个追踪分支，连远程主机名都可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，当前分支自动与唯一一个追踪分支进行合并。&lt;/p&gt;
&lt;p&gt;如果合并需要采用rebase模式，可以使用–rebase选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull --rebase &amp;lt;远程主机名&amp;gt; &amp;lt;远程分支名&amp;gt;:&amp;lt;本地分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果远程主机删除了某个分支，默认情况下，&lt;code&gt;git pull&lt;/code&gt; 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止由于其他人操作了远程主机，导致&lt;code&gt;git pull&lt;/code&gt;不知不觉删除了本地分支。&lt;/p&gt;
&lt;p&gt;但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git pull -p&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 等同于下面的命令&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch --prune origin &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch -p&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;git-push&quot;&gt;&lt;a href=&quot;#git-push&quot; class=&quot;headerlink&quot; title=&quot;git push&quot;&gt;&lt;/a&gt;git push&lt;/h1&gt;&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;命令用于将本地分支的更新，推送到远程主机。它的格式与&lt;code&gt;git pull&lt;/code&gt;命令相仿。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名&amp;gt;:&amp;lt;远程分支名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;分支推送顺序的写法是&amp;lt;来源地&amp;gt;:&amp;lt;目的地&amp;gt;，所以&lt;code&gt;git pull&lt;/code&gt;是&amp;lt;远程分支&amp;gt;:&amp;lt;本地分支&amp;gt;，而&lt;code&gt;git push&lt;/code&gt;是&amp;lt;本地分支&amp;gt;:&amp;lt;远程分支&amp;gt;。&lt;/p&gt;
&lt;p&gt;如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。&lt;/p&gt;
&lt;p&gt;如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin :master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 等同于&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin --delete master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示删除origin主机的master分支。&lt;/p&gt;
&lt;p&gt;如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，将当前分支推送到origin主机的对应分支。&lt;/p&gt;
&lt;p&gt;如果当前分支只有一个追踪分支，那么主机名都可以省略。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用&lt;code&gt;git push&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push -u origin master&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用&lt;code&gt;git push&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;不带任何参数的&lt;code&gt;git push&lt;/code&gt;，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用&lt;code&gt;git config&lt;/code&gt;命令。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global push.default matching&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ git config --global push.default simple&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push --all origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令表示，将所有本地分支都推送到origin主机。&lt;/p&gt;
&lt;p&gt;如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做&lt;code&gt;git pull&lt;/code&gt;合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push --force origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;git push&lt;/code&gt;不会推送标签（tag），除非使用–tags选项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git push origin --tags&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;git-fetch-1&quot;&gt;&lt;a href=&quot;#git-fetch-1&quot; class=&quot;headerlink&quot; title=&quot;git fetch&quot;&gt;&lt;/a&gt;git fetch&lt;/h1&gt;&lt;p&gt;最近工作上有点忙，不免回家之后还需要办公，可是工作用公司的设备。回家之后只能使用自己的MAC。不过，如何在两台设备同步代码就成了问题。需要能够在一个文件夹不断的同步新的分支，而不会产生新的文件夹。这里，分享博主的解决办法。&lt;/p&gt;
&lt;p&gt;1）从远端获取分支&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git fetch origin&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2）基于远端分支创建本地分支&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ git checkout -b local_branch_name origin/remote_branch_name&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样，就会在本地创建一个基于远端分支的分支。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git的读音为/gɪt/。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Git&quot;&gt;Git&lt;/a&gt;是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。&lt;/p&gt;
&lt;p&gt;Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。例如 最近就迁移到 Git 上来了，很多 Freedesktop 的项目也迁移到了 Git 上。&lt;/p&gt;
&lt;p&gt;Git有很多优势，其中之一就是远程操作非常简单。但是，Git也是一把双刃剑，使用得当，将会尽享Git的便利与强大。本文将主要介绍几个常用的Git远程操作命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://o88e8any8.bkt.clouddn.com/http-::charsdavy.github.io:2016:06:05:git-using-remote:1.jpg?imageView/2/w/560&quot; alt=&quot;introduction&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://charsdavy.github.io/categories/tool/"/>
    
    
      <category term="Git" scheme="http://charsdavy.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>七牛云存储应用</title>
    <link href="http://charsdavy.github.io/2016/06/02/qiniu-using/"/>
    <id>http://charsdavy.github.io/2016/06/02/qiniu-using/</id>
    <published>2016-06-02T00:17:42.000Z</published>
    <updated>2016-08-03T12:21:16.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。&lt;br&gt;七牛云官网&lt;a href=&quot;http://www.qiniu.com/&quot;&gt;http://www.qiniu.com/&lt;/a&gt; ，进入开发者平台，浏览了所有的开发指南，可是却是没有具体清晰的操作步骤。今天自己试着通过网络，实现了使用七牛云存储文件。现在，将操作步骤记录如下。&lt;/p&gt;
&lt;h1 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h1&gt;&lt;p&gt;1.注册七牛云账号。&lt;/p&gt;
&lt;p&gt;2.创建空间。&lt;/p&gt;
&lt;p&gt;3.获取Access Key。&lt;/p&gt;
&lt;p&gt;4.获取Secret Key。&lt;/p&gt;
&lt;p&gt;5.获取官方SDK（&lt;a href=&quot;https://github.com/qiniu/objc-sdk&quot;&gt;https://github.com/qiniu/objc-sdk&lt;/a&gt; ）。&lt;/p&gt;
&lt;h1 id=&quot;导入工程&quot;&gt;&lt;a href=&quot;#导入工程&quot; class=&quot;headerlink&quot; title=&quot;导入工程&quot;&gt;&lt;/a&gt;导入工程&lt;/h1&gt;&lt;p&gt;1.打开Xcode创建Project。&lt;/p&gt;
&lt;p&gt;2.从获取的官方SDK导入库，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-cd5c98eeccbbaef5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;br&gt;3.获取token&lt;/p&gt;
&lt;p&gt;这一步，网上大家都说得很简单，在这一步卡壳许久。现在说说自己使用的方法：&lt;/p&gt;
&lt;p&gt;1）获取服务器代码，编译工程，以备生成token。&lt;/p&gt;
&lt;p&gt;服务器代码地址：&lt;a href=&quot;https://github.com/CharsDavy/QiNiuGenertorToken&quot;&gt;https://github.com/CharsDavy/QiNiuGenertorToken&lt;/a&gt;&lt;br&gt;2）使用Eclipse导入上述服务器代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1492739-825661cf6c402c56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在Test.java文件中，修改自己的空间名称，Access Key和Secret Key。运行程序，即可获得token。&lt;/p&gt;
&lt;p&gt;这种方式生成的token的有效期是可以自己设定的，如果你想，设定1000年过期也是可以的。&lt;/p&gt;
&lt;p&gt;4.使用代码上传文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;QiniuSDK.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString token = @&amp;quot;从服务端SDK获取&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QNUploadManager *upManager = [[QNUploadManager alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data = [@&amp;quot;Hello, World!&amp;quot; dataUsingEncoding : NSUTF8StringEncoding];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [upManager putData:data key:@&amp;quot;hello&amp;quot; token:token&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        complete: ^(QNResponseInfo *info, NSString *key, NSDictionary *resp) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, info);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, resp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; option:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h1 id=&quot;调试&quot;&gt;&lt;a href=&quot;#调试&quot; class=&quot;headerlink&quot; title=&quot;调试&quot;&gt;&lt;/a&gt;调试&lt;/h1&gt;&lt;p&gt;工程导入之后，可能会出现以下几种可能的错误。&lt;/p&gt;
&lt;p&gt;1.若报 &lt;code&gt;Undefined symbols for architecture x86_64: &amp;quot;_crc32&amp;quot;, referenced from:&lt;/code&gt;，项目中需导入 libz.dylib。(Build Phases—Link Binary With Libraries)&lt;/p&gt;
&lt;p&gt;2.若报&lt;code&gt;&amp;quot;_res_9_ninit&amp;quot;, referenced from: _setup_dns_server in QNResolver.o&lt;/code&gt;等，&lt;/p&gt;
&lt;p&gt;1）项目中需导入 libresolv.dylib或libresolv.9.dylib。(Build Phases— Link Binary With Libraries)；&lt;/p&gt;
&lt;p&gt;2）或 (Build Settings— Linking— Other Linker Flags) 添加 -lresolv选项。&lt;/p&gt;
&lt;p&gt;3.若报 Thread 1: EXC_BAD_ACCESS(code=1,address=0x180f4beb8)类似错误，将 QN打头的都设置 arc (Build Phases — Compile Sources)&lt;/p&gt;
&lt;p&gt;4.可能需要修改部分内容，如 &lt;code&gt;#import &amp;lt;AFNetworking/AFNetworking.h&amp;gt;&lt;/code&gt;改为 &lt;code&gt;#import &amp;quot;AFNetworking.h&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;小结&quot;&gt;&lt;a href=&quot;#小结&quot; class=&quot;headerlink&quot; title=&quot;小结&quot;&gt;&lt;/a&gt;小结&lt;/h1&gt;&lt;p&gt;以上就是本人在工程中使用七牛云进行文件云存储的过程，本文中使用的仅仅是上传文件，更多其他操作功能请参照官方文档。&lt;/p&gt;
&lt;p&gt;最后，附上一个使用七牛云存储的软件，源码地址：&lt;a href=&quot;https://github.com/CharsDavy/MyNotes&quot;&gt;https://github.com/CharsDavy/MyNotes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实，对于获取token来完成上载操作，也可以参考官方文档，地址&lt;br&gt;&lt;a href=&quot;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&quot;&gt;http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：七牛云存储，是专为移动时代开发者打造的数据管理平台，为互联网网站和移动App提供数据的在线托管、传输加速以及图片、音视频等富媒体的云处理服务。本文讲述如何使用七牛云存储来作为自己APP的数据云存储空间。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://charsdavy.github.io/categories/iOS/"/>
    
    
      <category term="持久化" scheme="http://charsdavy.github.io/tags/persistence/"/>
    
  </entry>
  
  <entry>
    <title>你和日本的距离只差5mm</title>
    <link href="http://charsdavy.github.io/2016/06/01/chopsticks-using/"/>
    <id>http://charsdavy.github.io/2016/06/01/chopsticks-using/</id>
    <published>2016-06-01T12:38:19.000Z</published>
    <updated>2016-07-17T03:01:36.000Z</updated>
    
    <content type="html">&lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;日本在使用筷子的时候，也有很大的「箸（はし）」学问，有什么禁忌是千万不要犯的呢？！&lt;/p&gt;
&lt;p&gt;✖握り箸（にぎりばし）——握筷子，这是初级错误，一般来说只有初学使用筷子的孩子和外国人会犯。&lt;/p&gt;
&lt;p&gt;✖クロス箸——两根筷子交叉，很不雅观。 &lt;/p&gt;
&lt;p&gt;✖迷い箸（まよいばし）——拿起筷子犹豫不决，前后左右晃动，似乎在挑拣食物。&lt;/p&gt;
&lt;p&gt;✖移り箸（うつりばし）——前面食物的味道还残留在口中，就取另外的食物。&lt;/p&gt;
&lt;p&gt;✖こじ箸——在碗底翻腾取食物。&lt;/p&gt;
&lt;p&gt;✖寄せ箸（よせばし）——用筷子拨动、移动盘子。&lt;/p&gt;
&lt;p&gt;✖刺し箸（さしばし）——用筷子扎取食物（对于不会用筷子的人来说，吃丸子的时候不这样会很难~）。&lt;/p&gt;
&lt;p&gt;✖涙箸——“泪筷子”，这个名称很形象，筷子夹起食物滴滴答答的流汤。&lt;/p&gt;
&lt;p&gt;✖かき箸——把碗放在嘴边，用筷子把食品拨拉到嘴里。&lt;/p&gt;
&lt;p&gt;✖込み箸（こみばし）——筷子进嘴塞食。&lt;/p&gt;
&lt;p&gt;✖持ち箸（もちばし）——把筷子拿在手里，端起碗吸食，日本农民 。&lt;/p&gt;
&lt;p&gt;✖ねぶり箸——把筷子放在嘴里吸允。&lt;/p&gt;
&lt;p&gt;✖渡し箸（わたしばし）——把筷子架在碗上。&lt;/p&gt;
&lt;p&gt;✖叩き箸（はたきばし）——用筷子敲碗催促他人（这样真的很招人烦）。&lt;/p&gt;
&lt;p&gt;✖指さし箸（ゆびさしばし）——用筷子指人（用手指人也是很不好的）。&lt;/p&gt;
&lt;p&gt;✖直箸（じかばし）——有公筷不用，直接使用自己的筷子在盘内取食。&lt;/p&gt;
&lt;p&gt;✖立箸——把筷子插在米饭碗里。&lt;/p&gt;
&lt;p&gt;✖そろえ箸——用舌头、嘴唇或者其他平面整理、理顺两根筷子（为什么不用手，这样多累啊）。 &lt;/p&gt;
&lt;p&gt;✖探り箸（さぐりばし）——用筷子在盘子里搅拌、寻找食物（瞄准一个直接吃得了，在那ba la啥）。&lt;/p&gt;
&lt;p&gt;✖せせり箸——把筷子当牙签使（小花儿表示：她的牙缝没这么大）。&lt;/p&gt;
&lt;p&gt;✖かみ箸——用牙齿咬筷子。&lt;/p&gt;
&lt;p&gt;✖振り箸（ふりばし）——甩手抖落筷子上的汤汁（轻微洁癖真的有点接受不了）。&lt;/p&gt;
&lt;p&gt;✖洗い箸（あらい）——在碗盘汤中涮洗筷子。&lt;/p&gt;
&lt;p&gt;✖箸渡し（はしわたし）——用筷子向他人的筷子递送食品。&lt;br&gt;✖そら箸——筷子靠近了盘子，却又不取食品。&lt;/p&gt;
&lt;p&gt;以上是25条使用筷子的禁忌。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：世界上使用筷子的国家并不是很多，很多人都认为能够使用筷子是件很神奇的事情。那么，不同的国家地区使用筷子的讲究也有所不同。这里主要说说日本使用筷子的禁忌，有些也很符合天朝国情的。&lt;/p&gt;
    
    </summary>
    
      <category term="爱好" scheme="http://charsdavy.github.io/categories/hobby/"/>
    
    
      <category term="日语" scheme="http://charsdavy.github.io/tags/Japanese/"/>
    
  </entry>
  
</feed>
