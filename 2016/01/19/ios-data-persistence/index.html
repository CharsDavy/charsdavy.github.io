
<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Chars&#39;s Blog">
    <title>拆拆 iOS 数据持久化 - Chars&#39;s Blog</title>
    <meta name="author" content="Chars">
    
    
        <link rel="icon" href="http://chars.tech/assets/images/avatar.png">
    
    
        <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
    
    <meta name="description" content="持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制：
1）属性列表；
2）对象归档；
3）iOS的嵌入式关系数据库SQLite3；
4）Core Data。
在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I/O调用（比如，fopen()）读写数据，">
<meta property="og:type" content="blog">
<meta property="og:title" content="拆拆 iOS 数据持久化">
<meta property="og:url" content="http://chars.tech/2016/01/19/ios-data-persistence/index.html">
<meta property="og:site_name" content="Chars's Blog">
<meta property="og:description" content="持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制：
1）属性列表；
2）对象归档；
3）iOS的嵌入式关系数据库SQLite3；
4）Core Data。
在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I/O调用（比如，fopen()）读写数据，">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-1.png?imageView/2/w/200">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-2.png">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-3.png">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-4.png">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-5.png">
<meta property="og:image" content="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-6.png">
<meta property="og:updated_time" content="2017-07-05T08:03:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="拆拆 iOS 数据持久化">
<meta name="twitter:description" content="持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制：
1）属性列表；
2）对象归档；
3）iOS的嵌入式关系数据库SQLite3；
4）Core Data。
在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I/O调用（比如，fopen()）读写数据，">
<meta name="twitter:image" content="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-1.png?imageView/2/w/200">
<meta name="twitter:creator" content="@charsdavy">
    
    
        
    
    
        <meta property="og:image" content="http://chars.tech/assets/images/avatar.png"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/style-sxklfps8ywgfyyjcowvnb4gxdgt0zjts3hsguljmv9uqanxjbnitrovtbrek.min.css">
    <!--STYLES END-->
    
    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-80507808-1']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

    
    
  <script type="text/javascript" src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("{{theme.leancloud_visitors.app_id}}", "{{theme.leancloud_visitors.app_key}}");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>


</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a class="header-title-link" href="/ ">Chars&#39;s Blog</a>
    </div>
    
        
            <a  class="header-right-picture "
                href="#about">
        
        
            <img class="header-picture" src="/assets/images/avatar.png" alt="Author&#39;s picture"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a href="/#about">
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.png" alt="Author&#39;s picture"/>
                </a>
                <h4 class="sidebar-profile-name">Chars</h4>
                
                    <h5 class="sidebar-profile-bio"><p>Currently engaged in iOS development, learning Unity, like to study all kinds of novelty</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/ "
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-home"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/categories"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
                        <span class="sidebar-button-desc">Categories</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/tags"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-tags"></i>
                        <span class="sidebar-button-desc">Tags</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/archives"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-archive"></i>
                        <span class="sidebar-button-desc">Archives</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link open-algolia-search"
                             href="#search"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-search"></i>
                        <span class="sidebar-button-desc">Search</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link "
                             href="/about"
                            
                        >
                    
                        <i class="sidebar-button-icon fa fa-lg fa-user"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://github.com/charsdavy" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-github"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://twitter.com/charsdavy" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="https://facebook.com/wei.deng.1460" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-facebook"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="http://weibo.com/u/3875245858" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-weibo"></i>
                        <span class="sidebar-button-desc">Weibo</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a  class="sidebar-button-link " href="mailto:chars.davy@gmail.com" target="_blank" rel="noopener">
                    
                        <i class="sidebar-button-icon fa fa-lg fa-envelope-o"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post" itemscope itemType="http://schema.org/BlogPosting">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title" itemprop="headline">
            拆拆 iOS 数据持久化
        </h1>
    
    
        <div class="post-meta">
    <time itemprop="datePublished" datetime="2016-01-19T14:50:24+08:00">
	
		    Jan 19, 2016
    	
    </time>
    
        <span>In </span>
        
    <a class="category-link" href="/categories/pieces/">pieces</a>


    
</div>

    
</div>
    
    <div class="post-content markdown" itemprop="articleBody">
        <div class="main-content-wrap">
            <p>持久存储是一种非易失性存储，在重启设备时也不会丢失数据。Cocoa框架提供了几种数据持久化机制：</p>
<p>1）属性列表；</p>
<p>2）对象归档；</p>
<p>3）iOS的嵌入式关系数据库SQLite3；</p>
<p>4）Core Data。</p>
<p>在iOS开发中，持久化数据的方法也并不限于属性列表、对象归档、SQLite3和Core Data。它们只是四种最常用且简单的方法。其实也可以使用传统C语言I/O调用（比如，fopen()）读写数据，也可以使用Cocoa的底层文件管理工具。只不过这两种方法都需要写很多代码，并且没有必要这么做。</p>
<a id="more"></a>
<h1 id="一、应用的沙盒"><a href="#一、应用的沙盒" class="headerlink" title="一、应用的沙盒"></a>一、应用的沙盒</h1><p>Cocoa提供的四种数据持久化机制都涉及一个共同因素，即应用的/Documents文件夹。每个应用都有自己的/Documents文件夹，且能读写各自的/Documents目录中的内容。</p>
<p>为了便于理解，我们先来看一下iPhone模拟器使用的文件夹布局，从而了解iOS中应用是如何组织的。打开Finder窗口，找到主目录，找到Library（资源库）目录，找到Developer/CoreSimulator/Devices/，在该目录中可以看到一些子目录，分别对应Xcode中的模拟器。子目录的名称是Xcode自动生成的GUID（Globally Unique Identifier，全局唯一标识符），因此无法确定每个目录对应哪一个模拟器。解决这个问题的方法是找到模拟器目录中名为device.plist的文件，并打开它，就可以看见一个对应模拟器设备名称的键。</p>
<p>虽然这是模拟器的目录，但实际设备上的文件结构与此相似。如果想看到设备上应用程序的沙盒，就将它连接到Mac上并打开Xcode的Devices窗口，在窗口边侧栏可以看到该设备，选中它然后在Installed Apps表中选择一个应用程序。在表的下方有一个看起来像齿轮的图表。点击它并在弹出菜单中选择Show Container选项就可以看到应用程序沙盒的内容。</p>
<p>每个应用程序沙盒都包含以下三个目录：</p>
<p>1）Documents：应用程序可以将数据存储在Documents目录中。如果这个应用程序启用了iTunes文件分享功能，用户就可以在iTunes中看到目录的内容（以及应用程序创建的所有子目录），还可以对其更新文件。</p>
<p>如果要为应用程序启用文件分享功能，需要打开它的Info.plist文件并添加键为Application supports iTunes file sharing值为YES的条目。</p>
<p>2）Library：应用程序也可以在这里存储数据。它用来存放不想共享给用户的文件。需要时可以创建自己的子目录。系统创建了名为Cache和Preferences的子目录。后者包含了存储应用程序偏好设置的plist文件，通过NSUserDefaults来操作。</p>
<p>3）tmp：tmp目录供应用存储临时文件。当iOS设备执行同步时，iTunes不会备份tmp中的文件。在不需要这些文件时，应用要负责删除tmp中的文件，以免占用文件系统空间。</p>
<h2 id="获取Documents目录"><a href="#获取Documents目录" class="headerlink" title="获取Documents目录"></a>获取Documents目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *documentsDirectory = paths[0];</span><br></pre></td></tr></table></figure>
<p>常量<code>NSDocumentDirectory</code>表明我们正在查找Documents目录的路径。第二个常量<code>NSUserDomainMask</code>表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *filename = [documentsDirectory stringByAppendingPathComponent:@”theFile.txt”];</span><br></pre></td></tr></table></figure>
<p>完成此调用之后，filename就包含了指向应用Documents目录中theFile.txt文件的完整路径。</p>
<h2 id="获取Library目录"><a href="#获取Library目录" class="headerlink" title="获取Library目录"></a>获取Library目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);</span><br><span class="line">NSString *libraryDirectory = paths[0];</span><br></pre></td></tr></table></figure>
<p>常量<code>NSLibraryDirectory</code>表明我们正在查找Library目录的路径。第二个常量<code>NSUserDomainMask</code>表明我们希望将搜索限制在应用的沙盒内，在OS X中表明我们希望该函数查看用户的主目录。</p>
<h2 id="获取tmp目录"><a href="#获取tmp目录" class="headerlink" title="获取tmp目录"></a>获取tmp目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *tempPath = NSTemporaryDirectory();</span><br><span class="line">NSString *filename = [tempPath stringByAppendingPathComponent:@”theFile.txt”];</span><br></pre></td></tr></table></figure>
<h1 id="二、文件保存方案"><a href="#二、文件保存方案" class="headerlink" title="二、文件保存方案"></a>二、文件保存方案</h1><p>Cocoa提供的四种实现数据持久化的方法，都使用iOS的文件系统。使用SQLite3将创建一个SQLite3数据库文件，并让SQLite3去存储和检索数据。Core Data则以其最简单的形式帮助开发者完成所有的文件系统的管理工作。使用属性列表则需要考虑将数据存储在一个文件中，还是存储在多个文件中。</p>
<h2 id="单文件持久化"><a href="#单文件持久化" class="headerlink" title="单文件持久化"></a>单文件持久化</h2><p>把数据保存在一个文件中是最简单的方法，而且对于许多应用，这也是完全可以接受的方法。首先，创建一个根对象，通常是数组或字典（使用归档容器的情况下根对象可以给予这个自定义类）。接下来，使用所有需要保存的程序数据填充根对象。真正保存时，代码会将该根对象的全部内容重新写入单个文件。应用在启动时会将该文件的全部内容读入内存，并在退出时注销。</p>
<p>使用单文件的缺点：必须将全部数据加载到内存中，并且不管有多小的更改也必须将所有数据全部重新写入文件系统。</p>
<h2 id="多文件持久化"><a href="#多文件持久化" class="headerlink" title="多文件持久化"></a>多文件持久化</h2><p>使用多文件持久化是另一种实现持久化的方法。例如，电子邮件应用可能会将每封邮件都单独存储在一个文件中。</p>
<p>这种方法的优点，例如应用可以只加载用户请求的数据（另一种形式的延迟加载），当用户进行更改时只保存更改的文件。此方法允许开发者在收到内存不足通知时释放内存。用户当前未查看的任何数据都可以从内存中删除，下次需要时再从文件系统重新加载即可。</p>
<p>使用多文件持久化的缺点：它大大增加了应用的复杂性。</p>
<h1 id="三、属性列表"><a href="#三、属性列表" class="headerlink" title="三、属性列表"></a>三、属性列表</h1><p>属性列表使用起来非常方便，可以使用Xcode或Property List Editor应用手动编辑它们。而且只要字典或数组包含特定可序列化对象，就可以将NSDictionary和NSArray实例写入属性列表或者从属性列表创建它们。</p>
<h2 id="属性列表序列化"><a href="#属性列表序列化" class="headerlink" title="属性列表序列化"></a>属性列表序列化</h2><p>序列化对象，是指可以被转换为字节流以便于存储到文件中或通过网络进行传输的对象。虽然任何对象都可以被序列化，但是只有某些对象才能放置到某个集合类中（如NSDictionary或NSArray中），然后才使用该集合类的writeToFile:atomically:或writeToURL:atomically:方法将它们存储到属性列表中。可以按照该方法序列化下面的类：</p>
<p>1）NSArray、NSMutableArray</p>
<p>2）NSDictionary、NSMutableDictionary</p>
<p>3）NSData、NSMutableData</p>
<p>4）NSString、NSMutableString</p>
<p>5）NSNumber</p>
<p>6）NSDate</p>
<p>如果只使用这些对象构建数据模型，就可以使用属性列表来方便地保护和加载数据。如果打算使用属性列表持久保存应用数据，则可以使用数组或字典。假设放到字典或数组中的所有对象都是前面列出的可序列化对象，则可以通过对字典或数组的实例调用writeToFile:atomically:方法来写入属性列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myArray writeToFile:@”/some/file/location/output.plist” atomically:YES];</span><br></pre></td></tr></table></figure>
<p>说明：这里的atomically参数让该方法将数据写入辅助文件，而不是写入指定位置。成功写入该文件之后，辅助文件将被复制到第一个参数指定的位置。这是更安全的写入文件的方法，因为如果应用在保存期间崩溃，则现有文件（如果有）不会被破坏。尽管增加一点开销，但是多数情况下还是值得的。</p>
<p>属性列表方法的一个问题就是，无法将自定义对象序列化到属性列表中，另外也不能使用没有在可序列化对象类型列表中指定的Cocoa Touch的其他类。这意味着无法使用NSURL、UIImage和UIColor等类。</p>
<p>且不说序列化问题，将这些模型对象保存到属性列表中还意味着无法轻松创建派生的或需要计算的属性（例如，等于两个属性之后的属性），并且必须将实际上应该包含在模型中的某些代码移动到控制器类。这些限制也适用于简单数据模型和简单应用。但在多数情况下，如果创建了专用的模型类，则应用更容易维护。</p>
<p>在复杂的应用中，简单属性列表仍然非常有用。它们是将静态数据包含在应用中的最佳方法。例如，当应用包含一个选取器时，创建一个属性列表文件并将其放在项目的Resources文件夹中，就是将项目列表包含到选取器中的最佳方法，这样能把项目列表编译到应用中。</p>
<h2 id="NSData"><a href="#NSData" class="headerlink" title="NSData"></a>NSData</h2><p>NSData主要是提供一块原始数据的封装，方便数据的封装与流动，比较常见的是NSString/NSImage数据的封装与传递。在应用中，最常用于访问存储在文件中或者网络资源中的数据。</p>
<p>这个类提供的封装/解封方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+(id)dataWithBytes:(const void *)bytes length:(NSUInteger)length;</span><br><span class="line">-(NSUInteger)length;</span><br><span class="line">-(const void *)bytes NS_RETURNS_INNER_POINTER;</span><br></pre></td></tr></table></figure>
<p>从这几个方法可以看出，NSData根本不管传递的内容到底是什么，仅仅是传递一块内存——仅需内存的起始地址和长度。</p>
<h2 id="解析plist"><a href="#解析plist" class="headerlink" title="解析plist"></a>解析plist</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">idresult = [NSPropertyListSerialization propertyListWithData:data options:0format:NULL error:NULL];</span><br></pre></td></tr></table></figure>
<h2 id="读写plist"><a href="#读写plist" class="headerlink" title="读写plist"></a>读写plist</h2><p>1）写入文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSArray*phrase;</span><br><span class="line">phrase =[NSArray arrayWithObjects:@&quot;I&quot;, @&quot;seem&quot;, @&quot;to&quot;,@&quot;be&quot; ,@&quot;a&quot;, @&quot;verb&quot;, nil];</span><br><span class="line">[phrasewriteToFile:@&quot;/tmp/verbiage.txt&quot; atomically:YES];</span><br></pre></td></tr></table></figure>
<p>现在看一下文件/tmp/verbiage.txt，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xmlversion=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPEplist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;</span><br><span class="line"> &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plistversion=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;array&gt;</span><br><span class="line">  &lt;string&gt;I&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;seem&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;to&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;be&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;a&lt;/string&gt;</span><br><span class="line">  &lt;string&gt;verb&lt;/string&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>
<p>这些属性列表文件可以为任意复杂的形式，可以是包含字符串、数字和日期数组的字典数组。Xcode还包含一个属性列表编辑器，所以可以查看plist文件并进行编辑。</p>
<p><strong>说明：</strong>有些属性列表文件（特别是首选项文件）是以压缩的二进制格式存储的。通过使用plutil命令：<code>plutil -convert xml1 filename.plist</code>，可以将这些文件转换为人们可读的形式。</p>
<p>2）读取</p>
<p>之前已经将verbiage.txt文件存放在磁盘上，可以使用<code>+arrayWithContentsOfFile:</code>方法读取该文件。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSArray*pharse = [NSArray arrayWithContentsOfFile:@&quot;/tmp/ verbiage.txt &quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;,phrase);</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong>注意到<code>writeToFile:</code>方法中的单词<code>atomically</code>了吗？这种调用有什么负面作用吗？没有。<code>atomically:</code>参数的值为BOOL类型，用于通知Cocoa是否应该首先将文件内容保存在临时文件中，当文件成功保存后，再将该临时文件和原始文件交换。这是一种安全机制：如果在保存过程中出现意外，不会破坏原始文件。但这种安全机制需要付出一定的代价：在保存过程中，由于原始文件仍然保存在磁盘中，所以需要使用双倍的磁盘空间。除非保存的文件非常大，将会占用用户硬盘空间，否则应该自动保存文件。</p>
<p>如果能将数据精简为属性列表类型，则可以使用这些非常便捷的调用来将内容保存到磁盘中，供以后读取。如果你正在从事一项新创意或设计一个新项目，可以使用这些便捷方法来快速编写和运行程序。即使只想把数据块保存到磁盘中，并且根本不需要使用对象，也可以使用NSData来简化工作。只需要将数据包装在一个NSData对象中，然后再NSData对象上调用<code>writeToFile: atomically:</code>方法。</p>
<p>这些函数的一个缺点就是，它们不会返回任何错误信息。如果不能加载文件，只能从方法中得到nil指针，而不能确定出现了何种错误。</p>
<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>在Xcode中，使用Single View Application模板创建一个项目，命名Persistence，点击Main.storyboard，布局如下图</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-1.png?imageView/2/w/200" alt="布局"></p>
<p>连线，添加处理函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@interface PlistViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">        NSArray *array = [[NSArray alloc] initWithContentsOfFile:filePath];</span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            UITextField *theField = self.lineFields[i];</span><br><span class="line">            theField.text = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.plist&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    NSArray *array = [self.lineFields valueForKey:@&quot;text&quot;];</span><br><span class="line">    [array writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、归档"><a href="#四、归档" class="headerlink" title="四、归档"></a>四、归档</h1><p>在Cocoa世界中，归档是指另一中形式的序列化，但它是任何对象都可以实现的更常规的类型。专门编写用于保存数据的任何模型对象都应该支持归档。使用对模型对象进行归档的技术可以轻松将复杂的对象写入文件，然后再从中读取它们。</p>
<p>只要在类中实现的每个属性都是标量（如整型或浮点型）或都是遵循NSCoding协议的某个类的实例，就可以对整个对象进行完全的归档。由于大多数支持存储数据的Foundation和Cocoa Touch类都遵循NSCoding协议（不过，有一些例外，如UIImage），对于大多数类来说，归档相对而言比较容易实现。</p>
<p>尽管对归档的使用没有严格要求，但还有一个协议应该与NSCoding一起实现，即NSCopying协议。后者允许复制对象，这使开发者在使用数据模型对象时具备了较大的灵活性。</p>
<h2 id="遵循NSCoding协议"><a href="#遵循NSCoding协议" class="headerlink" title="遵循NSCoding协议"></a>遵循NSCoding协议</h2><p>NSCoding协议声明了两个必须实现的方法，一个方法将对象编码到归档中，另一个方法对归档解码来创建一个新对象。这两个方法都传递一个NSCoder实例，使用方式与NSUserDefaults非常相似。也可以使用KVC对对象和原生数据类型进行编码和解码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@protocolNSCoding</span><br><span class="line">-(void)encodeWithCoder:(NSCoder*)aCoder;</span><br><span class="line">-(id)initWithCoder:(NSCoder*)aDecoder;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>当对象需要保存自身时，<code>encodeWithCoder:</code>方法将被调用；当对象需要加载自身时，<code>initWithCoder:</code>方法将被调用。</p>
<p>那么，这个编码器是什么呢？NSCoder是一个抽象类，定义一些有用的方法来在对象与NSData之间来回转换。完全不需要创建新NSCoder，因为它实际上并无多大作用。但是，我们实际上要使用NSCoder的一些具体的子类来编码和解码对象。我们将使用其中两个子类NSKeyedArchiver和NSKeyedUnarchiver。</p>
<p><code>initWithCoder:</code>和其他任何init方法一样，在对对象执行操作之前，需要使用超类对它们进行初始化。为此，可以采用两种方式，具体取决于父类。如果父类采用NSCoding协议，则应该调用<code>[super initWithCoder:decoder]</code>；否则，只需要调用<code>[super init]</code>即可。NSObject不采用NSCoding协议，因此我们使用简单的init方法。</p>
<p><code>+ archivedDataWithRootObject:</code>类方法编码thing对象。首先，它在后台创建一个NSKeyedArchiver实例；然后，它将NSKeyedArchiver实例传递给对象thing的<code>-encodeWithCoder:</code>方法。当thing编码自身的属性时，它可能对其他对象也进行编码，例如，字符串、数组以及我们可能输入到该数组中的任何内容。整个对象集合完成键和值的编码后，具有键/值对的归档程序将所有对象扁平化为一个NSData类并将其返回。</p>
<p>如果愿意，可以使用<code>-writeToFile:atomically:</code>方法将这个NSData类保存到磁盘中。在此，我们先处理thing对象，然后通过freezeDried表示法重新创建它，并将它输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thing =[NSKeyedUnarchiveObjectWithData: freezeDried];</span><br><span class="line">NSLog(@&quot;reconstitutedthing:%@&quot;,thing);</span><br></pre></td></tr></table></figure>
<p>如果被编码的数据中含有循环将会怎么样？例如，如果thing包含在自身的subThingies数组中会怎样？thing会对数组进行编码吗？哪个对象对thing进行编码，哪个对象对数组进行编码，哪个对象再次对thing进行编码，依此类推？幸运的是，Cocoa在归档程序和解压程序实现上非常灵活，能够保存并恢复对象周期。</p>
<h2 id="实现NSCopying协议"><a href="#实现NSCopying协议" class="headerlink" title="实现NSCopying协议"></a>实现NSCopying协议</h2><p>遵循NSCopying对于任何数据模型对象来说都是非常好的事情。NSCopying有一个copyWithZone:方法，可用来复制对象。实现NSCopying与实现initWithCoder:非常相似，只需要创建一个同一类的新实例，然后将新实例的所有属性都设置为与该对象属性相同的值即可。</p>
<p>说明：不要过于担心NSZone参数。它指向系统用于管理内存的struct。只有在极少数情况下，开发者才需要关注zone或者创建自己的zone。目前，还没有使用多个zone的说法。对某个对象调用copy的方法与使用默认zone调用copyWithZone的方法完全相同，几乎始终能满足你的需求。事实上，现在的iOS上完全可以忽略zone。NSCopying用zone在本质上是考虑向后兼容性所致。</p>
<h2 id="创建工程-1"><a href="#创建工程-1" class="headerlink" title="创建工程"></a>创建工程</h2><p>按照上文创建工程，设计界面（与上文界面相同），连线，添加响应方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ArchiverViewController.h&quot;</span><br><span class="line">#import &quot;Lines.h&quot;</span><br><span class="line"></span><br><span class="line">static NSString *const kRootKey = @&quot;kRootKey&quot;;</span><br><span class="line"></span><br><span class="line">@interface ArchiverViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    if ([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">        NSData *data = [[NSMutableData alloc] initWithContentsOfFile:filePath];</span><br><span class="line">        NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data];</span><br><span class="line">        Lines *lines = [unarchiver decodeObjectForKey:kRootKey];</span><br><span class="line">        [unarchiver finishDecoding];</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">            UITextField *theField = self.lineFields[i];</span><br><span class="line">            theField.text = lines.lines[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.archive&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    NSString *filePath = [self dataFilePath];</span><br><span class="line">    Lines *lines = [[Lines alloc] init];</span><br><span class="line">    lines.lines = [self.lineFields valueForKey:@&quot;text&quot;];</span><br><span class="line">    NSMutableData *data = [[NSMutableData alloc] init];</span><br><span class="line">    NSKeyedArchiver *archiver = [[NSKeyedArchiver alloc] initForWritingWithMutableData:data];</span><br><span class="line">    [archiver encodeObject:lines forKey:kRootKey];</span><br><span class="line">    [archiver finishEncoding];</span><br><span class="line">    [data writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与属性列表序列化实现多几行代码，那么是否就是使用归档比使用序列化属性列表更有优势呢？答案是否定的。如果我们拥有一个包含可归档对象的数组，则可以对数组实例本身进行归档来归档整个数组。对集合类（如数组）进行归档时，也会归档其包含的所有对象。只要放入数组或字典中的对象遵循NSCoding，就可以归档数组或字典并还原它。这样，对其进行归档时，其中所有对象都将位于已还原的数组和字典中。这一点并不适用于属性链接的持久化，它只支持一小部分的Foundation对象类型。如果没有编写额外的代码，来将这些自定义类的实例与字典通过每个对象属性的键进行互相转化，就不能对其进行持久化。</p>
<p>换句话说，NSCoding方法具有非常好的伸缩性，因为无论添加多少对象，将这些对象写入磁盘的方式都完全相同。不过使用属性列表的话，工作量会随着添加对象而增加。</p>
<h1 id="五、SQLite3"><a href="#五、SQLite3" class="headerlink" title="五、SQLite3"></a>五、SQLite3</h1><p>SQLite3在存储和检索大量数据方面非常有效。它能够对数据进行复杂的聚合，与使用对象执行这些操作相比，获得结果的速度更快。</p>
<p>SQLite3使用SQL（Structured Query Language，结构化查询语言），SQL是与关系数据库交互的标准语言。</p>
<p>这里推荐两篇SQLite3深入研究探索的参考文章：</p>
<p>An Introduction to the SQLite3 C/C++ Interface (<a href="http://www.sqlite.org/cintro.html" target="_blank" rel="external">www.sqlite.org/cintro.html</a>)</p>
<p>SQL As Understood by SQLite (<a href="http://www.sqlite.org/lang.html" target="_blank" rel="external">www.sqlite.org/lang.html</a>)</p>
<p>关系数据库（包括SQLite3）和面向对象的编程语言使用完全不同的方法来存储和组织数据。这些方法差异很大，因而出现了在两者之间进行转换的各种技术以及很多库和工具。这些技术统称为ORM（Object-Relational-Mapping，对象关系映射）。目前有很多种ORM工具可用于Cocoa Touch。</p>
<h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p>虽然可以通过创建SQL字符串来插入值，但常用的方法是使用绑定变量来执行数据库插入操作。正确处理字符串并确保它们没有无效字符（以及引号处理过的属性）是非常烦琐的事情。借助绑定变量，这些问题将迎刃而解。</p>
<p>要使用绑定变量插入值，只需要按正常方式创建SQL语句即可，不过要在SQL字符串中添加一个问号。每个问号都表示一个需要在语句执行之前进行绑定的变量。然后，准备好SQL语句，将值绑定到各个变量并执行命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*将整型数据绑定到第一个变量，将字符串绑定到第二个变量，然后执行并结束语句*/</span><br><span class="line">char *sql = “insert into foo values (?, ?);”;</span><br><span class="line">sqlite3_stmt *stmt;</span><br><span class="line"></span><br><span class="line">if(sqlite3_prepare_v2(database, sql, -1, &amp;stmt, nil) == SQLITE_OK)&#123;</span><br><span class="line">    sqlite3_bind_int(stmt, 1, 235);</span><br><span class="line">    sqlite3_bind_text(stmt, 2, “Bar”, -1, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(sqlite3_step(stmt) != SQLITE_DONE)&#123;</span><br><span class="line">    NSLog(@”This should be real error checking!”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sqlite3_finalize(stmt);</span><br></pre></td></tr></table></figure>
<p>根据希望使用的数据类型，可以选择不同的绑定语句。大部分绑定函数都只有3个参数。</p>
<p>1）无论针对哪种数据类型，任何绑定函数的第一个参数都指向之前在sqlite3_prepare_v2()调用中使用的sqlite3_stmt。</p>
<p>2）第二个参数是被绑定变量的索引。它是一个有序索引值，者这表示SQL语句中的第一个问号是索引1，其后面的每个问号都依次按序增加1。</p>
<p>3）第三个参数始终表示应该替换问号的值。</p>
<p>有些绑定函数（比如用于绑定文本和二进制数据的绑定函数）拥有另外两个参数。</p>
<p>1）一个参数是在上面第三个参数中传递的数据长度。对于C字符串，可以传递-1来代替字符串长度，这样函数将使用整个字符串。对于所有其他情况，需要指定所传递数据的长度。</p>
<p>2）另外一个参数是可选的函数回调，用于在语句执行后完成内存清理工作。通常，这种函数使用malloc()释放已分配的内存。</p>
<h2 id="创建工程-2"><a href="#创建工程-2" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建工程，设计布局，与前文工程相同操作，连线，添加响应方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SqliteViewController.h&quot;</span><br><span class="line">#import &lt;sqlite3.h&gt;</span><br><span class="line"></span><br><span class="line">@interface SqliteViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>导入sqlite库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    sqlite3 *database;</span><br><span class="line">    //打开数据库</span><br><span class="line">    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Failed to open database&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     有用的C语言知识：</span><br><span class="line">     如果两个内联的字符串之间只有空白（包括换行符）而没有其他字符，</span><br><span class="line">     那么这两个字符串会被连接为一个字符串。</span><br><span class="line">     */</span><br><span class="line">    </span><br><span class="line">    //创建数据库SQL</span><br><span class="line">    NSString *createSQL = @&quot;create table if not exists fields (row integer primary key, field_data text);&quot;;</span><br><span class="line">    char *errorMsg;</span><br><span class="line">    //执行SQL语句</span><br><span class="line">    if (sqlite3_exec(database, [createSQL UTF8String], NULL, NULL, &amp;errorMsg) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Error creating table: %s&quot;, errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //查询数据库</span><br><span class="line">    NSString *query = @&quot;select row, field_data from fields order by row;&quot;;</span><br><span class="line">    sqlite3_stmt *statement;</span><br><span class="line">    if (sqlite3_prepare_v2(database, [query UTF8String], -1, &amp;statement, nil) == SQLITE_OK) &#123;</span><br><span class="line">        //遍历返回的每行</span><br><span class="line">        while (sqlite3_step(statement) == SQLITE_ROW) &#123;</span><br><span class="line">            int row = sqlite3_column_int(statement, 0);</span><br><span class="line">            char *rowData = (char *)sqlite3_column_text(statement, 1);</span><br><span class="line">            NSString *fieldValue = [[NSString alloc] initWithUTF8String:rowData];</span><br><span class="line">            UITextField *field = self.lineFields[row];</span><br><span class="line">            field.text = fieldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(statement);</span><br><span class="line">    &#125;</span><br><span class="line">    //关闭数据库</span><br><span class="line">    sqlite3_close(database);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)dataFilePath&#123;</span><br><span class="line">    NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);</span><br><span class="line">    NSString *documentsDirectory = [paths objectAtIndex:0];</span><br><span class="line">    return [documentsDirectory stringByAppendingPathComponent:@&quot;data.sqlite&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    sqlite3 *database;</span><br><span class="line">    if (sqlite3_open([[self dataFilePath] UTF8String], &amp;database) != SQLITE_OK) &#123;</span><br><span class="line">        sqlite3_close(database);</span><br><span class="line">        NSAssert(0, @&quot;Failed to open database&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        UITextField *field = self.lineFields[i];</span><br><span class="line">        //内联字符串的连接，又一次派上用场</span><br><span class="line">        char *update = &quot;insert or replace into fields (row, field_data) values (?, ?);&quot;;</span><br><span class="line">        char *errorMsg = NULL;</span><br><span class="line">        sqlite3_stmt *stmt;</span><br><span class="line">        //绑定变量</span><br><span class="line">        if (sqlite3_prepare_v2(database, update, -1, &amp;stmt, nil) == SQLITE_OK) &#123;</span><br><span class="line">            sqlite3_bind_int(stmt, 1, i);</span><br><span class="line">            sqlite3_bind_text(stmt, 2, [field.text UTF8String], -1, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">        //判断执行更新是否成功</span><br><span class="line">        if (sqlite3_step(stmt) != SQLITE_DONE) &#123;</span><br><span class="line">            NSAssert(0, @&quot;Error updating table: %s&quot;, errorMsg);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlite3_finalize(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlite3_close(database);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，以上者三种方式没有什么差异，只不过是三种不同的持久化机制而已。</p>
<h1 id="六、Core-Data"><a href="#六、Core-Data" class="headerlink" title="六、Core Data"></a>六、Core Data</h1><p>Core Data是一款稳定、功能全面的持久化工具。</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>实体：表示对对象的描述。</p>
<p>托管对象：表示在运行时创建该实体的具体实例。</p>
<p>注意，在数据模型编辑器中，你将创建实体；而在代码中，你将创建并检索托管对象。实体和托管对象之间的差异类似于类与类的实例。 </p>
<p>实体由属性组成，属性分为3种类型：</p>
<p>1）特性（attribute）：特性在Core Data实体中的作用与实例变量在Objective-C类中的作用完全相同，它们都用于保存数据。</p>
<p>2）关系（relationship）：关系用于定义实体之间的关系。举例来说，假设要定义一个Person实体，你可能首先会定义一些特性，比如height和weight，还可以定义地址特性，比如state和zipCode，或者将它们嵌入到单独的HomeAddr实体中。使用后面这种方法，你可能希望在Person与HomeAddr之间创建一个关系。关系可以是一对一或一对多。从Person到HomeAddr的关系可以是“一对一”，因为大多数人都只有一个家庭地址。从HomeAddr到Person的关系则可以是“一对多”，因为可能多个人住在同一个家庭地址。</p>
<p>3）提取属性（fetched property）：提取属性是关系的备选方法。用提取属性可以创建一个能在提取时被评估的查询，从而确定哪些对象属于这个关系。沿用刚才的例子，一个Person对象可以拥有一个名为Neighbors的提取属性，该属性查找数据存储中与这个Person的HomeAddr拥有相同zipCode的所有HomeAddr对象。由于提取属性的结构和使用方式，它们通常都是一对一关系。提取属性也是唯一一种能够让你跨越多个数据存储的关系。</p>
<h2 id="创建工程-3"><a href="#创建工程-3" class="headerlink" title="创建工程"></a>创建工程</h2><p>依旧如前文方式创建工程，添加响应参数，不过在这里要注意的是，Core Data的创建方法步骤：</p>
<p>1）创建Model文件</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-2.png" alt="创建Model文件"></p>
<p>2）编辑Model文件，点击“Add Entity”添加实体，点击“Add Attribute”添加特性</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-3.png" alt="编辑Model文件"></p>
<p>3）创建NSManagedObject文件，关联数据模型</p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-4.png" alt="创建NSManagedObject文件-1"></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-5.png" alt="创建NSManagedObject文件-2"></p>
<p><img src="http://o88e8any8.bkt.clouddn.com/ios-data-persistence-6.png" alt="创建NSManagedObject文件-3"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;CoreDataViewController.h&quot;</span><br><span class="line">#import &lt;CoreData/CoreData.h&gt;</span><br><span class="line"></span><br><span class="line">static NSString *const kLineEntityName = @&quot;Line&quot;;</span><br><span class="line">static NSString *const kLineNumberKey = @&quot;lineNumber&quot;;</span><br><span class="line">static NSString *const kLineTextKey = @&quot;lineText&quot;;</span><br><span class="line"></span><br><span class="line">@interface CoreDataViewController ()</span><br><span class="line">- (IBAction)saveClicked:(id)sender;</span><br><span class="line">@property (strong, nonatomic) IBOutletCollection(UITextField) NSArray *lineFields;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    NSManagedObjectContext *context = [self myContext];</span><br><span class="line"></span><br><span class="line">    NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];</span><br><span class="line">    NSError *error;</span><br><span class="line">    NSArray *objects = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">    if (objects == nil) &#123;</span><br><span class="line">        NSLog(@&quot;There was an error!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (NSManagedObject *oneObject in objects) &#123;</span><br><span class="line">        int lineNum = [[oneObject valueForKey:kLineNumberKey] intValue];</span><br><span class="line">        NSString *lineText = [oneObject valueForKey:kLineTextKey];</span><br><span class="line"></span><br><span class="line">        UITextField *theField = self.lineFields[lineNum];</span><br><span class="line">        theField.text = lineText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSManagedObjectContext *)myContext&#123;</span><br><span class="line">    //上下文 关联Company.xcdatamodeld模型文件</span><br><span class="line">    NSManagedObjectContext *context = [[NSManagedObjectContext alloc] init];</span><br><span class="line">    //模型文件</span><br><span class="line">    NSManagedObjectModel *model = [NSManagedObjectModel mergedModelFromBundles:nil];</span><br><span class="line">    //持久化存储调度器</span><br><span class="line">    NSPersistentStoreCoordinator *store = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:model];</span><br><span class="line">    NSString *doc = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">    NSString *sqlitePath = [doc stringByAppendingPathComponent:@&quot;line.sqlite&quot;];</span><br><span class="line">    //数据存储的类型 数据库存储路径</span><br><span class="line">    [store addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:[NSURL fileURLWithPath:sqlitePath] options:nil error:nil];</span><br><span class="line">    context.persistentStoreCoordinator = store;</span><br><span class="line">    </span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (IBAction)saveClicked:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSManagedObjectContext *context = [self myContext];</span><br><span class="line">    </span><br><span class="line">    NSError *error;</span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        UITextField *theField = self.lineFields[i];</span><br><span class="line">        NSFetchRequest *request = [[NSFetchRequest alloc] initWithEntityName:kLineEntityName];</span><br><span class="line">        NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;(%K = %d)&quot;, kLineNumberKey, i];</span><br><span class="line">        [request setPredicate:pred];</span><br><span class="line"></span><br><span class="line">        NSArray *objects = [context executeFetchRequest:request error:&amp;error];</span><br><span class="line">        if (objects == nil) &#123;</span><br><span class="line">            NSLog(@&quot;There was an error!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        NSManagedObject *theLine = nil;</span><br><span class="line">        if ([objects count] &gt; 0) &#123;</span><br><span class="line">            theLine = [objects objectAtIndex:0];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            theLine = [NSEntityDescription insertNewObjectForEntityForName:kLineEntityName inManagedObjectContext:context];</span><br><span class="line">        &#125;</span><br><span class="line">        [theLine setValue:[NSNumber numberWithInt:i] forKey:kLineNumberKey];</span><br><span class="line">        [theLine setValue:theField.text forKey:kLineTextKey];</span><br><span class="line">    &#125;</span><br><span class="line">    [context save:nil];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Core Data版本与之前的版本功能完全相同。Core Data需要的工作量很大。对于这种简单的应用，它并没有提供明显的优势。但是在比较复杂的应用中，Core Data可以显著减少设计和编写数据模型所需的时间。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>四种数据持久化机制，各有优势，根据使用情况选择对应机制进行数据持久化。</p>
<p><a href="https://github.com/charsdavy/Persistence" target="_blank" rel="external">Demo on Github</a></p>

            
        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">Tag In</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/ios/">ios</a> <a class="tag tag--primary tag--small t-link" href="/tags/persistence/">存储</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/02/10/memory-alignment/"  data-tooltip="内存对齐详解">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">Previous</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/01/15/ios-preference-setting/" data-tooltip="iOS App 偏好设置">
                
                    <span class="hide-xs hide-sm text-small icon-mr">Next</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-facebook-official"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-twitter"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-google-plus"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-weibo"></i>
                </a>
            </li>
        
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-angle-double-up"></i>
            </a>
        </li>
    </ul>
</div>


        
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
    	&copy; 
    	 
    		2016 - 
    	
        2017 Chars. All Rights Reserved.
    </span>
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/02/10/memory-alignment/"  data-tooltip="内存对齐详解">
                
                    <i class="fa fa-angle-left"></i>
                    <span class="hide-xs hide-sm text-small icon-ml">Previous</span>
                </a>
            </li>
            <li class="post-action">
                
                    <a class="post-action-btn btn btn--default tooltip--top" href="/2016/01/15/ios-preference-setting/" data-tooltip="iOS App 偏好设置">
                
                    <span class="hide-xs hide-sm text-small icon-mr">Next</span>
                    <i class="fa fa-angle-right"></i>
                </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a class="post-action-btn btn btn--default btn-open-shareoptions"  href="#btn-open-shareoptions">
                <i class="fa fa-share-alt"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-facebook-official"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-twitter"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-google-plus"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a class="post-action-btn btn btn--default" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-weibo"></i>
                </a>
            </li>
        
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#">
            
                <i class="fa fa-angle-double-up"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                <div id="share-options-bar" class="share-options-bar" data-behavior="4">
    <i id="btn-close-shareoptions" class="fa fa-close"></i>
    <ul class="share-options">
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-facebook-official"></i><span>Share on Facebook</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-twitter"></i><span>Share on Twitter</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-google-plus"></i><span>Share on Google+</span>
                </a>
            </li>
        
            
            
            <li class="share-option">
                <a class="share-option-btn" target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://chars.tech/2016/01/19/ios-data-persistence/">
                    <i class="fa fa-weibo"></i><span>Share on Weibo</span>
                </a>
            </li>
        
    </ul>
</div>

            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-remove"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.png" alt="Author&#39;s picture"/>
        
            <h4 id="about-card-name">Chars</h4>
        
            <div id="about-card-bio"><p>Currently engaged in iOS development, learning Unity, like to study all kinds of novelty</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>iOS developer @ZAKER</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker"></i>
                <br/>
                Guangzhou, China
            </div>
        
    </div>
</div>

        <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-close"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">no post found</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/18/college-thesis-summary-skill/">
                            <h3 class="media-heading">毕业论文摘要的书写方法和技巧</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 18, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>摘要也就是内容提要，是论文中不可缺少的一部分。论文摘要是一篇具有独立性的短文，有其特别的地方。它是建立在对论文进行总结的基础之上，用简单、明确、易懂、精辟的语言对全文内容加以概括，留主干去枝叶，提取论文的主要信息。作者的观点、论文的主要内容、研究成果、独到的见解，这些都应该在摘要中体现出来。好的摘要便于索引与查找，易于收录到大型资料库中并为他人提供信息。因此摘要在资料交流方面承担着至关重要的作用。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/18/vc-6-mfc-develop-summary/">
                            <h3 class="media-heading">VC++6.0 MFC编程心得小结</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 18, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>作为一个正经的科班出身软件工程专业者，想必都知道什么是VC++6.0。这个充满神奇的工具。而作为专业教学课的首选编程IDE，它有着不可撼动的地位。博主不知道别家院系使用何种启蒙工具，反正博主就是这个工具启蒙的。对它，有着又爱又恨得情怀。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/19/os-32-64-bit/">
                            <h3 class="media-heading">操作系统 32位和64位</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 19, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>两者之间存在的“五大不同”。与此同时，着重说明Microsoft Windows64位（x64）操作系统，相对于32位（x86）操作系统的最大优势和劣势是什么？</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/20/sql-server-state-code-list-1/">
                            <h3 class="media-heading">SQL Server 错误代码和解释 (上篇)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 20, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>SQL Server 是高校专业在教学数据库时一定会选用的案例之一，这个数据库是结合微软产品一起使用的，不仅贵，而且不好用。这是在使用之后的心得体会。在代码层面来说，这个是很难使用的。但是，老师说这个以后工作了都会使用到，所以，还是要好好学的。</p>
<p>文中罗列了各种状态码的解释，这些对调试SQL Server数据库程序是很有帮助的。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/21/sql-server-state-code-list-2/">
                            <h3 class="media-heading">SQL Server 错误代码和解释 (中篇)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 21, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>承接《上篇》继续罗列分享SQL Server状态码。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/22/sql-server-state-code-list-3/">
                            <h3 class="media-heading">SQL Server 错误代码和解释 (下篇)</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 22, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>承接《下篇》继续罗列分享SQL Server状态码。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/23/factory-prototype-diff/">
                            <h3 class="media-heading">Factory模式与Prototype模式的异同</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 23, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-body">
                        <a class="link-unstyled" href="http://chars.tech/2013/01/24/vc-invoke-dll/">
                            <h3 class="media-heading">VC 调用 DLL</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    Jan 24, 2013
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>DLL 动态数据链路库。</p>
<p>调用DLL有两种方法：静态调用和动态调用.</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="no post found"
                data-message-one="1 post found"
                data-message-other="{n} posts found">
                89 posts found
            </p>
        </div>
    </div>
</div>

        
<div id="cover" style="background-image:url('/assets/images/cover-v1.2.0.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/script-ivwiy10zeb8fifc4swnhkwneuk64y53w2scmdmtp8thi9cqfxh31aowtroaz.min.js"></script>
<!--SCRIPTS END-->


    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment-with-locales.min.js"></script>
    <script src="//cdn.jsdelivr.net/algoliasearch/3/algoliasearch.min.js"></script>
    <script>
        var algoliaClient = algoliasearch('UG7I248E1X', '39daa80db5305fba3705069658223736');
        var algoliaIndex = algoliaClient.initIndex('Chars_Blog');
    </script>

    </body>
</html>
